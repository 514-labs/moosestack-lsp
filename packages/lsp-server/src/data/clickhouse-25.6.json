{
  "version": "25.6",
  "extractedAt": "2025-12-05T20:06:46.527Z",
  "functions": [
    {
      "name": "BIT_AND",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "groupBitAnd",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "BIT_OR",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "groupBitOr",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "BIT_XOR",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "groupBitXor",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "BLAKE3",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\n    Calculates BLAKE3 hash string and returns the resulting set of bytes as FixedString.\n    This cryptographic hash-function is integrated into ClickHouse with BLAKE3 Rust library.\n    The function is rather fast and shows approximately two times faster performance compared to SHA-2, while generating hashes of the same length as SHA-256.\n    It returns a BLAKE3 hash as a byte array with type FixedString(32).\n    ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**hash**\n\n```sql title=Query\nSELECT hex(BLAKE3('ABC'))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "CAST",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "CHARACTER_LENGTH",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "lengthUTF8",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "CHAR_LENGTH",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "lengthUTF8",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "COVAR_POP",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "covarPop",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "COVAR_SAMP",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "covarSamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "CRC32",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "CRC32IEEE",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "CRC64",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DATABASE",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentDatabase",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DATE",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DATE_DIFF",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "dateDiff",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DATE_FORMAT",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "formatDateTime",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DATE_TRUNC",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "dateTrunc",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DAY",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toDayOfMonth",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DAYOFMONTH",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toDayOfMonth",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DAYOFWEEK",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toDayOfWeek",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "DAYOFYEAR",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toDayOfYear",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "FORMAT_BYTES",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "formatReadableSize",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "FQDN",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "FROM_BASE64",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "base64Decode",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "FROM_DAYS",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "fromDaysSinceYearZero",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "FROM_UNIXTIME",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "fromUnixTimestamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "HOUR",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toHour",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "INET6_ATON",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "IPv6StringToNum",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "INET6_NTOA",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "IPv6NumToString",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "INET_ATON",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "IPv4StringToNum",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "INET_NTOA",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "IPv4NumToString",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4CIDRToRange",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4NumToString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4NumToStringClassC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4StringToNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4StringToNumOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4StringToNumOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv4ToIPv6",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv6CIDRToRange",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv6NumToString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv6StringToNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv6StringToNumOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "IPv6StringToNumOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONAllPaths",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "JSONAllPaths(json)",
      "description": "\nReturns the list of all paths stored in each row in JSON column.\n",
      "arguments": "- `json` — JSON column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;\nINSERT INTO test FORMAT JSONEachRow {\"json\" : {\"a\" : 42}}, {\"json\" : {\"b\" : \"Hello\"}}, {\"json\" : {\"a\" : [1, 2, 3], \"c\" : \"2020-01-01\"}}\nSELECT json, JSONAllPaths(json) FROM test;\n```\n\n```response title=Response\n┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐\n│ {\"a\":\"42\"}                           │ ['a']              │\n│ {\"b\":\"Hello\"}                        │ ['b']              │\n│ {\"a\":[\"1\",\"2\",\"3\"],\"c\":\"2020-01-01\"} │ ['a','c']          │\n└──────────────────────────────────────┴────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "JSONAllPathsWithTypes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "JSONAllPathsWithTypes(json)",
      "description": "\nReturns the list of all paths and their data types stored in each row in JSON column.\n",
      "arguments": "- `json` — JSON column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;\nINSERT INTO test FORMAT JSONEachRow {\"json\" : {\"a\" : 42}}, {\"json\" : {\"b\" : \"Hello\"}}, {\"json\" : {\"a\" : [1, 2, 3], \"c\" : \"2020-01-01\"}}\nSELECT json, JSONAllPathsWithTypes(json) FROM test;\n```\n\n```response title=Response\n┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐\n│ {\"a\":\"42\"}                           │ {'a':'Int64'}                             │\n│ {\"b\":\"Hello\"}                        │ {'b':'String'}                            │\n│ {\"a\":[\"1\",\"2\",\"3\"],\"c\":\"2020-01-01\"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │\n└──────────────────────────────────────┴───────────────────────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "JSONArrayLength",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns the number of elements in the outermost JSON array. The function returns NULL if input JSON string is invalid.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "JSON"
    },
    {
      "name": "JSONDynamicPaths",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "JSONDynamicPaths(json)",
      "description": "\nReturns the list of dynamic paths that are stored as separate subcolumns in JSON column.\n",
      "arguments": "- `json` — JSON column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;\nINSERT INTO test FORMAT JSONEachRow {\"json\" : {\"a\" : 42}}, {\"json\" : {\"b\" : \"Hello\"}}, {\"json\" : {\"a\" : [1, 2, 3], \"c\" : \"2020-01-01\"}}\nSELECT json, JSONDynamicPaths(json) FROM test;\n```\n\n```response title=Response\n┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐\n│ {\"a\":\"42\"}                           │ ['a']                  │\n│ {\"b\":\"Hello\"}                        │ []                     │\n│ {\"a\":[\"1\",\"2\",\"3\"],\"c\":\"2020-01-01\"} │ ['a']                  │\n└──────────────────────────────────────┴────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "JSONDynamicPathsWithTypes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "JSONDynamicPathsWithTypes(json)",
      "description": "\nReturns the list of dynamic paths that are stored as separate subcolumns and their types in each row in JSON column.\n",
      "arguments": "- `json` — JSON column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;\nINSERT INTO test FORMAT JSONEachRow {\"json\" : {\"a\" : 42}}, {\"json\" : {\"b\" : \"Hello\"}}, {\"json\" : {\"a\" : [1, 2, 3], \"c\" : \"2020-01-01\"}}\nSELECT json, JSONDynamicPathsWithTypes(json) FROM test;\n```\n\n```response title=Response\n┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐\n│ {\"a\":\"42\"}                           │ {'a':'Int64'}                   │\n│ {\"b\":\"Hello\"}                        │ {}                              │\n│ {\"a\":[\"1\",\"2\",\"3\"],\"c\":\"2020-01-01\"} │ {'a':'Array(Nullable(Int64))'}  │\n└──────────────────────────────────────┴─────────────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "JSONExtract",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractArrayRaw",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractBool",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractFloat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractInt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractKeys",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractKeysAndValues",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractKeysAndValuesRaw",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractRaw",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONExtractUInt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONHas",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONKey",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONLength",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSONMergePatch",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns the merged JSON object string, which is formed by merging multiple JSON objects.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "JSON"
    },
    {
      "name": "JSONSharedDataPaths",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "JSONDynamicPaths(json)",
      "description": "\nReturns the list of paths that are stored in shared data structure in JSON column.\n",
      "arguments": "- `json` — JSON column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;\nINSERT INTO test FORMAT JSONEachRow {\"json\" : {\"a\" : 42}}, {\"json\" : {\"b\" : \"Hello\"}}, {\"json\" : {\"a\" : [1, 2, 3], \"c\" : \"2020-01-01\"}}\nSELECT json, JSONSharedDataPaths(json) FROM test;\n```\n\n```response title=Response\n┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐\n│ {\"a\":\"42\"}                           │ []                        │\n│ {\"b\":\"Hello\"}                        │ ['b']                     │\n│ {\"a\":[\"1\",\"2\",\"3\"],\"c\":\"2020-01-01\"} │ ['c']                     │\n└──────────────────────────────────────┴───────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "JSONSharedDataPathsWithTypes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "JSONDynamicPathsWithTypes(json)",
      "description": "\nReturns the list of paths that are stored in shared data structure and their types in each row in JSON column.\n",
      "arguments": "- `json` — JSON column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;\nINSERT INTO test FORMAT JSONEachRow {\"json\" : {\"a\" : 42}}, {\"json\" : {\"b\" : \"Hello\"}}, {\"json\" : {\"a\" : [1, 2, 3], \"c\" : \"2020-01-01\"}}\nSELECT json, JSONDynamicPathsWithTypes(json) FROM test;\n```\n\n```response title=Response\n┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐\n│ {\"a\":\"42\"}                           │ {'a':'Int64'}                   │\n│ {\"b\":\"Hello\"}                        │ {}                              │\n│ {\"a\":[\"1\",\"2\",\"3\"],\"c\":\"2020-01-01\"} │ {'a':'Array(Nullable(Int64))'}  │\n└──────────────────────────────────────┴─────────────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "JSONType",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSON_ARRAY_LENGTH",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "JSONArrayLength",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSON_EXISTS",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSON_QUERY",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "JSON_VALUE",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L1Distance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L1Norm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L1Normalize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L2Distance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L2Norm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L2Normalize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L2SquaredDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "L2SquaredNorm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LAST_DAY",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toLastDayOfMonth",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LinfDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LinfNorm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LinfNormalize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LpDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LpNorm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "LpNormalize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MACNumToString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MACStringToNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MACStringToOUI",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MAP_FROM_ARRAYS",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "mapFromArrays",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MD4",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT MD4(s);",
      "description": "Calculates the MD4 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The MD4 hash of the given input string returned as a [FixedString(16)](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(MD4('abc'));\n```\n\n```response title=Response\n┌─hex(MD4('abc'))──────────────────┐\n│ A448017AAF21D8525FC10AE87AA6729D │\n└──────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "MD5",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT MD5(s);",
      "description": "Calculates the MD5 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The MD5 hash of the given input string returned as a [FixedString(16)](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(MD5('abc'));\n```\n\n```response title=Response\n┌─hex(MD5('abc'))──────────────────┐\n│ 900150983CD24FB0D6963F7D28E17F72 │\n└──────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "MILLISECOND",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toMillisecond",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MINUTE",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toMinute",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "MONTH",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toMonth",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "OCTET_LENGTH",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "length",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "QUARTER",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toQuarter",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "REGEXP_EXTRACT",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "regexpExtract",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "REGEXP_MATCHES",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "match",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "REGEXP_REPLACE",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "replaceRegexpAll",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "RIPEMD160",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT RIPEMD160(s);",
      "description": "Calculates the RIPEMD-160 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The RIPEMD160 hash of the given input string returned as a [FixedString(20)](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(RIPEMD160('The quick brown fox jumps over the lazy dog'));\n```\n\n```response title=Response\n┌─HEX(RIPEMD160('The quick brown fox jumps over the lazy dog'))─┐\n│ 37F332F68DB77BD9D7EDD4969571AD671CF9DD3B                      │\n└───────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "SCHEMA",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentDatabase",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "SECOND",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toSecond",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "SHA1",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT SHA1(s);",
      "description": "Calculates the SHA1 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The SHA1 hash of the given input string returned as a [FixedString](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(SHA1('abc'));\n```\n\n```response title=Response\n┌─hex(SHA1('abc'))─────────────────────────┐\n│ A9993E364706816ABA3E25717850C26C9CD0D89D │\n└──────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "SHA224",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT SHA224(s);",
      "description": "Calculates the SHA224 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The SHA224 hash of the given input string returned as a [FixedString](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(SHA224('abc'));\n```\n\n```response title=Response\n┌─hex(SHA224('abc'))───────────────────────────────────────┐\n│ 23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7 │\n└──────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "SHA256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT SHA256(s);",
      "description": "Calculates the SHA256 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The SHA256 hash of the given input string returned as a [FixedString](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(SHA256('abc'));\n```\n\n```response title=Response\n┌─hex(SHA256('abc'))───────────────────────────────────────────────┐\n│ BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "SHA384",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT SHA384(s);",
      "description": "Calculates the SHA384 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The SHA384 hash of the given input string returned as a [FixedString](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(SHA384('abc'));\n```\n\n```response title=Response\n┌─hex(SHA384('abc'))───────────────────────────────────────────────────────────────────────────────┐\n│ CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED1631A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7 │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "SHA512",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT SHA512(s);",
      "description": "Calculates the SHA512 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The SHA512 hash of the given input string returned as a [FixedString](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(SHA512('abc'));\n```\n\n```response title=Response\n┌─hex(SHA512('abc'))───────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA20A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD454D4423643CE80E2A9AC94FA54CA49F │\n└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "SHA512_256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT SHA512_256(s);",
      "description": "Calculates the SHA512_256 hash of the given string.",
      "arguments": "- `s` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "The SHA512_256 hash of the given input string returned as a [FixedString](../../sql-reference/data-types/fixedstring.md).",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(SHA512_256('abc'));\n```\n\n```response title=Response\n┌─hex(SHA512_256('abc'))───────────────────────────────────────────┐\n│ 53048E2681941EF99B2E29B76B4C7DABE4C2D0C634FC6D46E0E2F13107E7AF23 │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "STD",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "stddevPop",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "STDDEV_POP",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "stddevPop",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "STDDEV_SAMP",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "stddevSamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ST_LineFromWKB",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "readWKBLineString",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ST_MLineFromWKB",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "readWKBMultiLineString",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ST_MPolyFromWKB",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "readWKBMultiPolygon",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ST_PointFromWKB",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "readWKBPoint",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ST_PolyFromWKB",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "readWKBPolygon",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "SUBSTRING_INDEX",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "substringIndex",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "SVG",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "svg",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "TIMESTAMP_DIFF",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "dateDiff",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "TO_BASE64",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "base64Encode",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "TO_DAYS",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toDaysSinceYearZero",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "TO_UNIXTIME",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "parseDateTime",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ULIDStringToDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nThis function extracts the timestamp from a ULID and returns it as a DateTime64(3) typed value.\nThe function expects the ULID to be provided as the first argument, which can be either a String or a FixedString(26) data type.\nAn optional second argument can be passed to specify a timezone for the timestamp.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**ulid**\n\n```sql title=Query\nSELECT ULIDStringToDateTime(generateULID())\n```\n\n```response title=Response\n\n```\n\n**timezone**\n\n```sql title=Query\nSELECT ULIDStringToDateTime(generateULID(), 'Asia/Istanbul')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "ULID"
    },
    {
      "name": "URLHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "URLHierarchy",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "URLPathHierarchy",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "UTCTimestamp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the current date and time at the moment of query analysis. The function is a constant expression.\nSame as `now('UTC')`. Was added only for MySQL support. `now` is preferred.\n\nExample:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT UTCTimestamp();\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "UTC_timestamp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "UTCTimestamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "UUIDNumToString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "UUIDStringToNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "UUIDToNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nThis function accepts a UUID and returns a FixedString(16) as its binary representation, with its format optionally specified by variant (Big-endian by default).\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**uuid**\n\n```sql title=Query\nselect toUUID(UUIDNumToString(toFixedString('a/<@];!~p{jTj={)', 16))) as uuid, UUIDToNum(uuid) as uuidNum, UUIDToNum(uuid, 2) as uuidMsNum\n```\n\n```response title=Response\n┌─uuid─────────────────────────────────┬─uuidNum──────────┬─uuidMsNum────────┐\n│ 612f3c40-5d3b-217e-707b-6a546a3d7b29 │ a/<@];!~p{jTj={) │ @</a];!~p{jTj={) │\n└──────────────────────────────────────┴──────────────────┴──────────────────┘\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "UUIDv7ToDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nThis function extracts the timestamp from a UUID and returns it as a DateTime64(3) typed value.\nThe function expects the UUID having version 7 to be provided as the first argument.\nAn optional second argument can be passed to specify a timezone for the timestamp.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**uuid**\n\n```sql title=Query\nselect UUIDv7ToDateTime(generateUUIDv7())\n```\n\n```response title=Response\n\n```\n\n**uuid**\n\n```sql title=Query\nselect generateUUIDv7() as uuid, UUIDv7ToDateTime(uuid), UUIDv7ToDateTime(uuid, 'America/New_York')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "VAR_POP",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "varPop",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "VAR_SAMP",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "varSamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "YEAR",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toYear",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "YYYYMMDDToDate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "YYYYMMDDToDate(YYYYMMDD)",
      "description": "\nConverts a number containing the year, month and day number to a `Date`.\nThis function is the opposite of function [`toYYYYMMDD()`](/sql-reference/functions/date-time-functions#toYYYYMMDD).\nThe output is undefined if the input does not encode a valid Date value.\n    ",
      "arguments": "- `YYYYMMDD` — Number containing the year, month and day. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n",
      "returnedValue": "Returns a `Date` value from the provided arguments. [`Date`](../data-types/date.md).",
      "examples": "**Example**\n\n```sql title=Query\nSELECT YYYYMMDDToDate(20230911);\n```\n\n```response title=Response\n┌─toYYYYMMDD(20230911)─┐\n│           2023-09-11 │\n└──────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "YYYYMMDDToDate32",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "YYYYMMDDToDate32(YYYYMMDD)",
      "description": "\nConverts a number containing the year, month and day number to a `Date32`.\nThis function is the opposite of function [`toYYYYMMDD()`](/sql-reference/functions/date-time-functions#toYYYYMMDD).\nThe output is undefined if the input does not encode a valid `Date32` value.\n    ",
      "arguments": "- `YYYYMMDD` — Number containing the year, month and day. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n",
      "returnedValue": "Returns a `Date32` value from the provided arguments. [`Date32`](../data-types/date32.md).",
      "examples": "**Example**\n\n```sql title=Query\nSELECT YYYYMMDDToDate32(20000507);\n```\n\n```response title=Response\n┌─YYYYMMDDToDate32(20000507)─┐\n│                 2000-05-07 │\n└────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "YYYYMMDDhhmmssToDateTime",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "YYYYMMDDhhmmssToDateTime(YYYYMMDDhhmmss[, timezone])",
      "description": "\nConverts a number containing the year, month, day, hour, minute, and second to a `DateTime`.\nThis function is the opposite of function [`toYYYYMMDDhhmmss()`](/sql-reference/functions/date-time-functions#toYYYYMMDDhhmmss).\nThe output is undefined if the input does not encode a valid `DateTime` value.\n    ",
      "arguments": "- `YYYYMMDDhhmmss` — Number containing the year, month, day, hour, minute, and second. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `timezone` — Optional. Timezone name. [`String`](../data-types/string.md).\n",
      "returnedValue": "Returns a `DateTime` value from the provided arguments. [`DateTime`](../data-types/datetime.md).",
      "examples": "**Example**\n\n```sql title=Query\nSELECT YYYYMMDDToDateTime(20230911131415);\n```\n\n```response title=Response\n┌──────YYYYMMDDhhmmssToDateTime(20230911131415)─┐\n│                           2023-09-11 13:14:15 │\n└───────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "YYYYMMDDhhmmssToDateTime64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "YYYYMMDDhhmmssToDateTime64(YYYYMMDDhhmmss[, precision[, timezone]])",
      "description": "\nConverts a number containing the year, month, day, hour, minute, and second to a `DateTime64`.\nThis function is the opposite of function [`toYYYYMMDDhhmmss()`](/sql-reference/functions/date-time-functions#toYYYYMMDDhhmmss).\nThe output is undefined if the input does not encode a valid `DateTime64` value.\n    ",
      "arguments": "- `YYYYMMDDhhmmss` — Number containing the year, month, day, hour, minute, and second. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `precision` — Optional. Precision for the fractional part (0-9). [`UInt8`](../data-types/int-uint.md).\n- `timezone` — Optional. Timezone name. [`String`](../data-types/string.md).\n",
      "returnedValue": "Returns a `DateTime64` value from the provided arguments. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Example**\n\n```sql title=Query\nSELECT YYYYMMDDhhmmssToDateTime64(20230911131415, 3, 'Asia/Istanbul');\n```\n\n```response title=Response\n┌─YYYYMMDDhhmm⋯/Istanbul')─┐\n│  2023-09-11 13:14:15.000 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "_CAST",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__actionName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__bitBoolMaskAnd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__bitBoolMaskOr",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__bitSwapLastTwo",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__bitWrapperFunc",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__getScalar",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "__scalarSubqueryResult",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "abs",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "abs(x)",
      "description": "Calculates the absolute value of `x`. Has no effect if `x` is of an unsigned type. If `x` is of a signed type, it returns an unsigned number.",
      "arguments": "- `x` — Value to get the absolute value of\n",
      "returnedValue": "The absolute value of `x`",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT abs(-0.5)\n```\n\n```response title=Response\n0.5\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "accurateCast",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "accurateCastOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "accurateCastOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "acos",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "acosh",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "addDate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "addDays",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addDays(datetime, num)",
      "description": "\nAdds a specified number of days to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of days to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of days to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` days. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add days to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addDays(date, 5) AS add_days_with_date,\n    addDays(date_time, 5) AS add_days_with_date_time,\n    addDays(date_time_string, 5) AS add_days_with_date_time_string\n```\n\n```response title=Response\n┌─add_days_with_date─┬─add_days_with_date_time─┬─add_days_with_date_time_string─┐\n│         2024-01-06 │     2024-01-06 00:00:00 │        2024-01-06 00:00:00.000 │\n└────────────────────┴─────────────────────────┴────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 day)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯valDay(10))─┐\n│               1998-06-26 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addHours",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addHours(datetime, num)",
      "description": "\nAdds a specified number of hours to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of hours to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of hours to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` hours. [`DateTime`](../data-types/datetime.md)/[`DateTime64(3)`](../data-types/datetime64.md).",
      "examples": "**Add hours to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addHours(date, 12) AS add_hours_with_date,\n    addHours(date_time, 12) AS add_hours_with_date_time,\n    addHours(date_time_string, 12) AS add_hours_with_date_time_string\n```\n\n```response title=Response\n┌─add_hours_with_date─┬─add_hours_with_date_time─┬─add_hours_with_date_time_string─┐\n│ 2024-01-01 12:00:00 │      2024-01-01 12:00:00 │         2024-01-01 12:00:00.000 │\n└─────────────────────┴──────────────────────────┴─────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 hour)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯alHour(10))─┐\n│      1998-06-16 10:00:00 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addInterval",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addInterval(interval_1, interval_2)",
      "description": "\nAdds an interval to another interval or tuple of intervals.\n\nNote: Intervals of the same type will be combined into a single interval. For instance if `toIntervalDay(1)` and `toIntervalDay(2)` are passed then the result will be `(3)` rather than `(1,1)`.\n    ",
      "arguments": "- `interval_1` — First interval or tuple of intervals. [`interval`](../data-types/special-data-types/interval.md)/[`tuple`](../data-types/tuple.md)([`interval`](../data-types/special-data-types/interval.md)).\n- `interval_2` — Second interval to be added. [`interval`](../data-types/special-data-types/interval.md).\n",
      "returnedValue": "Returns a tuple of intervals. [`tuple`](../data-types/tuple.md)([`interval`](../data-types/special-data-types/interval.md)).",
      "examples": "**Add intervals**\n\n```sql title=Query\nSELECT addInterval(INTERVAL 1 DAY, INTERVAL 1 MONTH);\nSELECT addInterval((INTERVAL 1 DAY, INTERVAL 1 YEAR), INTERVAL 1 MONTH);\nSELECT addInterval(INTERVAL 2 DAY, INTERVAL 1 DAY)\n```\n\n```response title=Response\n┌─addInterval(toIntervalDay(1), toIntervalMonth(1))─┐\n│ (1,1)                                             │\n└───────────────────────────────────────────────────┘\n┌─addInterval((toIntervalDay(1), toIntervalYear(1)), toIntervalMonth(1))─┐\n│ (1,1,1)                                                                │\n└────────────────────────────────────────────────────────────────────────┘\n┌─addInterval(toIntervalDay(2), toIntervalDay(1))─┐\n│ (3)                                             │\n└─────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addMicroseconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addMicroseconds(datetime, num)",
      "description": "\nAdds a specified number of microseconds to a date with time or a string-encoded date with time.\n    ",
      "arguments": "- `datetime` — Date with time to add specified number of microseconds to. [`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of microseconds to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `date_time` plus `num` microseconds. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add microseconds to different date time types**\n\n```sql title=Query\nWITH\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addMicroseconds(date_time, 1000000) AS add_microseconds_with_date_time,\n    addMicroseconds(date_time_string, 1000000) AS add_microseconds_with_date_time_string\n```\n\n```response title=Response\n┌─add_microseconds_with_date_time─┬─add_microseconds_with_date_time_string─┐\n│      2024-01-01 00:00:01.000000 │             2024-01-01 00:00:01.000000 │\n└─────────────────────────────────┴────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::DateTime, INTERVAL 10 microsecond)\n```\n\n```response title=Response\n┌─plus(CAST('19⋯osecond(10))─┐\n│ 1998-06-16 00:00:00.000010 │\n└────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addMilliseconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addMilliseconds(datetime, num)",
      "description": "\nAdds a specified number of milliseconds to a date with time or a string-encoded date with time.\n    ",
      "arguments": "- `datetime` — Date with time to add specified number of milliseconds to. [`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of milliseconds to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` milliseconds. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add milliseconds to different date time types**\n\n```sql title=Query\nWITH\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addMilliseconds(date_time, 1000) AS add_milliseconds_with_date_time,\n    addMilliseconds(date_time_string, 1000) AS add_milliseconds_with_date_time_string\n```\n\n```response title=Response\n┌─add_milliseconds_with_date_time─┬─add_milliseconds_with_date_time_string─┐\n│         2024-01-01 00:00:01.000 │                2024-01-01 00:00:01.000 │\n└─────────────────────────────────┴────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::DateTime, INTERVAL 10 millisecond)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯second(10))─┐\n│  1998-06-16 00:00:00.010 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addMinutes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addMinutes(datetime, num)",
      "description": "\nAdds a specified number of minutes to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of minutes to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of minutes to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` minutes. [`DateTime`](../data-types/datetime.md)/[`DateTime64(3)`](../data-types/datetime64.md).",
      "examples": "**Add minutes to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addMinutes(date, 20) AS add_minutes_with_date,\n    addMinutes(date_time, 20) AS add_minutes_with_date_time,\n    addMinutes(date_time_string, 20) AS add_minutes_with_date_time_string\n```\n\n```response title=Response\n┌─add_minutes_with_date─┬─add_minutes_with_date_time─┬─add_minutes_with_date_time_string─┐\n│   2024-01-01 00:20:00 │        2024-01-01 00:20:00 │           2024-01-01 00:20:00.000 │\n└───────────────────────┴────────────────────────────┴───────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 minute)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯Minute(10))─┐\n│      1998-06-16 00:10:00 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addMonths",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addMonths(datetime, num)",
      "description": "\nAdds a specified number of months to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of months to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of months to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` months. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add months to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addMonths(date, 6) AS add_months_with_date,\n    addMonths(date_time, 6) AS add_months_with_date_time,\n    addMonths(date_time_string, 6) AS add_months_with_date_time_string\n```\n\n```response title=Response\n┌─add_months_with_date─┬─add_months_with_date_time─┬─add_months_with_date_time_string─┐\n│           2024-07-01 │       2024-07-01 00:00:00 │          2024-07-01 00:00:00.000 │\n└──────────────────────┴───────────────────────────┴──────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 month)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯lMonth(10))─┐\n│               1999-04-16 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addNanoseconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addNanoseconds(datetime, num)",
      "description": "\nAdds a specified number of nanoseconds to a date with time or a string-encoded date with time.\n    ",
      "arguments": "- `datetime` — Date with time to add specified number of nanoseconds to. [`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of nanoseconds to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` nanoseconds. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add nanoseconds to different date time types**\n\n```sql title=Query\nWITH\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addNanoseconds(date_time, 1000) AS add_nanoseconds_with_date_time,\n    addNanoseconds(date_time_string, 1000) AS add_nanoseconds_with_date_time_string\n```\n\n```response title=Response\n┌─add_nanoseconds_with_date_time─┬─add_nanoseconds_with_date_time_string─┐\n│  2024-01-01 00:00:00.000001000 │         2024-01-01 00:00:00.000001000 │\n└────────────────────────────────┴───────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::DateTime, INTERVAL 1000 nanosecond)\n```\n\n```response title=Response\n┌─plus(CAST('199⋯osecond(1000))─┐\n│ 1998-06-16 00:00:00.000001000 │\n└───────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addQuarters",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addQuarters(datetime, num)",
      "description": "\nAdds a specified number of quarters to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of quarters to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of quarters to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` quarters. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add quarters to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addQuarters(date, 1) AS add_quarters_with_date,\n    addQuarters(date_time, 1) AS add_quarters_with_date_time,\n    addQuarters(date_time_string, 1) AS add_quarters_with_date_time_string\n```\n\n```response title=Response\n┌─add_quarters_with_date─┬─add_quarters_with_date_time─┬─add_quarters_with_date_time_string─┐\n│             2024-04-01 │         2024-04-01 00:00:00 │            2024-04-01 00:00:00.000 │\n└────────────────────────┴─────────────────────────────┴────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 quarter)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯uarter(10))─┐\n│               2000-12-16 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addSeconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addSeconds(datetime, num)",
      "description": "\nAdds a specified number of seconds to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of seconds to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of seconds to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` seconds. [`DateTime`](../data-types/datetime.md)/[`DateTime64(3)`](../data-types/datetime64.md).",
      "examples": "**Add seconds to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addSeconds(date, 30) AS add_seconds_with_date,\n    addSeconds(date_time, 30) AS add_seconds_with_date_time,\n    addSeconds(date_time_string, 30) AS add_seconds_with_date_time_string\n```\n\n```response title=Response\n┌─add_seconds_with_date─┬─add_seconds_with_date_time─┬─add_seconds_with_date_time_string─┐\n│   2024-01-01 00:00:30 │        2024-01-01 00:00:30 │           2024-01-01 00:00:30.000 │\n└───────────────────────┴────────────────────────────┴───────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 second)\n```\n\n```response title=Response\n┌─dateAdd('1998-06-16'::Date, INTERVAL 10 second)─┐\n│                             1998-06-16 00:00:10 │\n└─────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addTupleOfIntervals",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addTupleOfIntervals(datetime, intervals)",
      "description": "\nConsecutively adds a tuple of intervals to a date or a date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add intervals to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n- `intervals` — Tuple of intervals to add to `datetime`. [`tuple`](../data-types/tuple.md)([`interval`](../data-types/special-data-types/interval.md)).\n",
      "returnedValue": "Returns `date` with added `intervals`. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add tuple of intervals to date**\n\n```sql title=Query\nWITH toDate('2018-01-01') AS date\nSELECT addTupleOfIntervals(date, (INTERVAL 1 DAY, INTERVAL 1 MONTH, INTERVAL 1 YEAR))\n```\n\n```response title=Response\n┌─addTupleOfIntervals(date, (toIntervalDay(1), toIntervalMonth(1), toIntervalYear(1)))─┐\n│                                                                           2019-02-02 │\n└──────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addWeeks",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addWeeks(datetime, num)",
      "description": "\nAdds a specified number of weeks to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of weeks to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of weeks to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` weeks. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add weeks to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addWeeks(date, 5) AS add_weeks_with_date,\n    addWeeks(date_time, 5) AS add_weeks_with_date_time,\n    addWeeks(date_time_string, 5) AS add_weeks_with_date_time_string\n```\n\n```response title=Response\n┌─add_weeks_with_date─┬─add_weeks_with_date_time─┬─add_weeks_with_date_time_string─┐\n│          2024-02-05 │      2024-02-05 00:00:00 │         2024-02-05 00:00:00.000 │\n└─────────────────────┴──────────────────────────┴─────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 week)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯alWeek(10))─┐\n│               1998-08-25 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addYears",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "addYears(datetime, num)",
      "description": "\nAdds a specified number of years to a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to add specified number of years to. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of years to add. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` plus `num` years. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Add years to different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    addYears(date, 1) AS add_years_with_date,\n    addYears(date_time, 1) AS add_years_with_date_time,\n    addYears(date_time_string, 1) AS add_years_with_date_time_string\n```\n\n```response title=Response\n┌─add_years_with_date─┬─add_years_with_date_time─┬─add_years_with_date_time_string─┐\n│          2025-01-01 │      2025-01-01 00:00:00 │         2025-01-01 00:00:00.000 │\n└─────────────────────┴──────────────────────────┴─────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateAdd('1998-06-16'::Date, INTERVAL 10 year)\n```\n\n```response title=Response\n┌─plus(CAST('1⋯alYear(10))─┐\n│               2008-06-16 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "addressToLine",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "addressToLineWithInlines",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "addressToSymbol",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aes_decrypt_mysql",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aes_encrypt_mysql",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "age",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "alphaTokens",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVariance",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "and",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anova",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "analysisOfVariance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavy",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastRespectNulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "anyLast_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyRespectNulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "any_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyValueRespectNulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "any_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_value",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "any",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_value_respect_nulls",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "any_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "appendTrailingCharIfAbsent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_count",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "approx_top_k",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_k",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sum",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "array",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "array(x1 [, x2, ..., xN])",
      "description": "\nCreates an array from the function arguments.\n\nThe arguments should be constants and have types that share a common supertype.\nAt least one argument must be passed, because otherwise it isn't clear which type of array to create.\nThis means that you can't use this function to create an empty array. To do so, use the `emptyArray*` function.\n\nUse the `[ ]` operator for the same functionality.\n    ",
      "arguments": "- `x1` — Constant value of any type T. If only this argument is provided, the array will be of type T.\n- `[, x2, ..., xN]` — Additional N constant values sharing a common supertype with `x1`\n",
      "returnedValue": "Returns an 'Array(T)' type result, where 'T' is the smallest common type out of the passed arguments.",
      "examples": "**Valid usage**\n\n```sql title=Query\nSELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)\n```\n\n```response title=Response\n┌─a───────┬─toTypeName(a)─┐\n│ [1,2,3] │ Array(Int32)  │\n└─────────┴───────────────┘\n```\n\n**Invalid usage**\n\n```sql title=Query\nSELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)\n```\n\n```response title=Response\nReceived exception from server (version 25.4.3):\nCode: 386. DB::Exception: Received from localhost:9000. DB::Exception:\nThere is no supertype for types Int32, DateTime, Int8 ...\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayAUC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "arrayROCAUC",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "arrayAUCPR",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayAUCPR(scores, labels[, partial_offsets])",
      "description": "\nCalculates the area under the precision-recall (PR) curve.\nA precision-recall curve is created by plotting precision on the y-axis and recall on the x-axis across all thresholds.\nThe resulting value ranges from 0 to 1, with a higher value indicating better model performance.\nThe PR AUC is particularly useful for imbalanced datasets, providing a clearer comparison of performance compared to ROC AUC on those cases.\nFor more details, please see [here](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [here](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) and [here](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).\n",
      "arguments": "- `cores` — Scores prediction model gives. [Array](/sql-reference/data-types/array) of [Integers](../data-types/int-uint.md) or [Floats](../data-types/float.md).\n- `labels` — Labels of samples, usually 1 for positive sample and 0 for negative sample. [Array](/sql-reference/data-types/array) of [Integers](../data-types/int-uint.md) or [Enums](../data-types/enum.md).\n- `partial_offsets` — \n- Optional. An [`Array(T)`](/sql-reference/data-types/array) of three non-negative integers for calculating a partial area under the PR curve (equivalent to a vertical band of the PR space) instead of the whole AUC. This option is useful for distributed computation of the PR AUC. The array must contain the following elements [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]. [Array](/sql-reference/data-types/array) of non-negative [Integers](../data-types/int-uint.md). Optional.\n    - `higher_partitions_tp`: The number of positive labels in the higher-scored partitions.\n    - `higher_partitions_fp`: The number of negative labels in the higher-scored partitions.\n    - `total_positives`: The total number of positive samples in the entire dataset.\n\n::::note\nWhen `arr_partial_offsets` is used, the `arr_scores` and `arr_labels` should be only a partition of the entire dataset, containing an interval of scores.\nThe dataset should be divided into contiguous partitions, where each partition contains the subset of the data whose scores fall within a specific range.\nFor example:\n- One partition could contain all scores in the range [0, 0.5).\n- Another partition could contain scores in the range [0.5, 1.0].\n::::\n\n",
      "returnedValue": "Returns area under the precision-recall (PR) curve. [Float64](../data-types/float.md).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);\n```\n\n```response title=Response\n┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐\n│                              0.8333333333333333 │\n└─────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns `1` if lambda `func(x [, y1, y2, ... yN])` returns true for all elements. Otherwise, it returns `0`.\n",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns `1` if the lambda function returns true for all elements, `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**All elements match**\n\n```sql title=Query\nSELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])\n```\n\n```response title=Response\n1\n```\n\n**Not all elements match**\n\n```sql title=Query\nSELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayAvg",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the average of elements in the source array.\n\nIf a lambda function `func` is specified, returns the average of elements of the lambda results.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — Optional. A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the average of elements in the source array, or the average of elements of the lambda results if provided. [`Float64`](/sql-reference/data-types/float).",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT arrayAvg([1, 2, 3, 4]);\n```\n\n```response title=Response\n2.5\n```\n\n**Usage with lambda function**\n\n```sql title=Query\nSELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;\n```\n\n```response title=Response\n6.5\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayCompact",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayCompact(arr)",
      "description": "Removes consecutive duplicate elements from an array, including `null` values. The order of values in the resulting array is determined by the order in the source array.",
      "arguments": "- `arr` — An array to remove duplicates from. [`Array(T)`](/sql-reference/data-types/array)\n",
      "returnedValue": "Returns an array without duplicate values. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);\n```\n\n```response title=Response\n[1,nan,2,3]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayConcat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayConcat(arr1 [, arr2, ... , arrN])",
      "description": "Combines arrays passed as arguments.",
      "arguments": "- `arr1 [, arr2, ... , arrN]` — N number of arrays to concatenate. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns a single combined array from the provided array arguments.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res\n```\n\n```response title=Response\n[1,2,3,4,5,6]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayCount",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayCount([func, ] arr1, ...)",
      "description": "\nReturns the number of elements for which `func(arr1[i], ..., arrN[i])` returns true.\nIf `func` is not specified, it returns the number of non-zero elements in the array.\n\n`arrayCount` is a [higher-order function](/sql-reference/functions/overview#higher-order-functions).\n    ",
      "arguments": "- `func` — Function to apply to each element of the array(s). Optional. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda)\n- `arr1, ..., arrN` — N arrays. [Array(T)](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the number of elements for which `func` returns true. Otherwise, returns the number of non-zero elements in the array.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayCount(x -> (x % 2), groupArray(number) FROM numbers(10)\n```\n\n```response title=Response\n5\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayCumSum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayCumSum([func,] arr1[, arr2, ... , arrN])",
      "description": "Returns an array of the partial (running) sums of the elements in the source array. If a lambda function is specified, the sum is computed from applying the lambda to the array elements at each position.",
      "arguments": "- `func` — Optional. A lambda function to apply to the array elements at each position. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `arr1` — The source array of numeric values. [`Array(T)`](/sql-reference/data-types/array).\n- `[arr2, ..., arrN]` — Optional. Additional arrays of the same size, passed as arguments to the lambda function if specified. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of the partial sums of the elements in the source array. The result type matches the input array's numeric type.",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT arrayCumSum([1, 1, 1, 1]) AS res\n```\n\n```response title=Response\n[1, 2, 3, 4]\n```\n\n**With lambda**\n\n```sql title=Query\nSELECT arrayCumSum(x -> x * 2, [1, 2, 3]) AS res\n```\n\n```response title=Response\n[2, 6, 12]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayCumSumNonNegative",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayCumSumNonNegative([func,] arr1[, arr2, ... , arrN])",
      "description": "Returns an array of the partial (running) sums of the elements in the source array, replacing any negative running sum with zero. If a lambda function is specified, the sum is computed from applying the lambda to the array elements at each position.",
      "arguments": "- `func` — Optional. A lambda function to apply to the array elements at each position. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `arr1` — The source array of numeric values. [`Array(T)`](/sql-reference/data-types/array).\n- `[arr2, ..., arrN]` — Optional. Additional arrays of the same size, passed as arguments to the lambda function if specified. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of the partial sums of the elements in the source array, with any negative running sum replaced by zero. The result type matches the input array's numeric type.",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res\n```\n\n```response title=Response\n[1, 2, 0, 1]\n```\n\n**With lambda**\n\n```sql title=Query\nSELECT arrayCumSumNonNegative(x -> x * 2, [1, -2, 3]) AS res\n```\n\n```response title=Response\n[2, 0, 6]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayDifference",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayDifference(arr)",
      "description": "\nCalculates an array of differences between adjacent array elements.\nThe first element of the result array will be 0, the second `arr[1] - arr[0]`, the third `arr[2] - arr[1]`, etc.\nThe type of elements in the result array are determined by the type inference rules for subtraction (e.g. `UInt8` - `UInt8` = `Int16`).\n    ",
      "arguments": "- `arr` — Array for which to calculate differences between adjacent elements. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of differences between adjacent array elements. [`UInt*`](/sql-reference/data-types/int-uint#integer-ranges), [`Int*`](/sql-reference/data-types/int-uint#integer-ranges), [`Float*`](/sql-reference/data-types/float).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayDifference([1, 2, 3, 4]);\n```\n\n```response title=Response\n[0,1,1,1]\n```\n\n**Example of overflow due to result type Int64**\n\n```sql title=Query\nSELECT arrayDifference([0, 10000000000000000000]);\n```\n\n```response title=Response\n┌─arrayDifference([0, 10000000000000000000])─┐\n│ [0,-8446744073709551616]                   │\n└────────────────────────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayDistinct",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayDistinct(arr)",
      "description": "Returns an array containing only the distinct elements of an array.",
      "arguments": "- `arr` — Array for which to extract distinct elements. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array containing the distinct elements. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayDistinct([1, 2, 2, 3, 1]);\n```\n\n```response title=Response\n[1,2,3]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayDotProduct",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayDotProduct(v1, v2)",
      "description": "\nReturns the dot product of two arrays.\n\n:::note\nThe sizes of the two vectors must be equal. Arrays and Tuples may also contain mixed element types.\n:::\n",
      "arguments": "- `v1` — First vector. [Array(T)](/sql-reference/data-types/array) or [Tuple(T1, T2, ...)](../data-types/tuple.md) of numeric values.\n- `v2` — Second vector. [Array(T)](/sql-reference/data-types/array) or [Tuple(T1, T2, ...)](../data-types/tuple.md) of numeric values.\n",
      "returnedValue": "The dot product of the two vectors. [Numeric](/native-protocol/columns#numeric-types).\n\n:::note\nThe return type is determined by the type of the arguments. If Arrays or Tuples contain mixed element types then the result type is the supertype.\n:::",
      "examples": "**Array example**\n\n```sql title=Query\nSELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);\n```\n\n```response title=Response\n32    UInt16\n```\n\n**Tuple example**\n\n```sql title=Query\nSELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);\n```\n\n```response title=Response\n32    Float64\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayElement",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayElement(arr, n)",
      "description": "\nGets the element of the provided array with index `n` where `n` can be any integer type.\nIf the index falls outside of the bounds of an array, it returns a default value (0 for numbers, an empty string for strings, etc.),\nexcept for arguments of a non-constant array and a constant index 0. In this case there will be an error `Array indices are 1-based`.\n\n:::note\nArrays in ClickHouse are one-indexed.\n:::\n\nNegative indexes are supported. In this case, the corresponding element is selected, numbered from the end. For example, `arr[-1]` is the last item in the array.\n\nOperator `[n]` provides the same functionality.\n    ",
      "arguments": "- `arr` — The array to search. [`Array(T)`](/sql-reference/data-types/array).\n- `n` — Position of the element to get. [`(U)Int*`](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "Returns a single combined array from the provided array arguments. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\n2\n```\n\n**Negative indexing**\n\n```sql title=Query\nSELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\n3\n```\n\n**Using [n] notation**\n\n```sql title=Query\nSELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\n2\n```\n\n**Index out of array bounds**\n\n```sql title=Query\nSELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayElementOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayElementOrNull(arrays)",
      "description": "\nGets the element of the provided array with index `n` where `n` can be any integer type.\nIf the index falls outside of the bounds of an array, `NULL` is returned instead of a default value.\n\n:::note\nArrays in ClickHouse are one-indexed.\n:::\n\nNegative indexes are supported. In this case, it selects the corresponding element numbered from the end. For example, `arr[-1]` is the last item in the array.\n",
      "arguments": "- `arrays` — Arbitrary number of arguments of [`Array`](/sql-reference/data-types/array) type.\n",
      "returnedValue": "Returns a single combined array from the provided array arguments.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\n2\n```\n\n**Negative indexing**\n\n```sql title=Query\nSELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\n3\n```\n\n**Index out of array bounds**\n\n```sql title=Query\nSELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)\n```\n\n```response title=Response\nNULL\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayEnumerate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayEnumerate(arr)",
      "description": "\nReturns the array `[1, 2, 3, ..., length (arr)]`\n\nThis function is normally used with the [`ARRAY JOIN`](/sql-reference/statements/select/array-join) clause. It allows counting something just\nonce for each array after applying `ARRAY JOIN`.\nThis function can also be used in higher-order functions. For example, you can use it to get array indexes for elements that match a condition.\n",
      "arguments": "- `arr` — The array to enumerate. [`Array`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the array `[1, 2, 3, ..., length (arr)]`. Array(UInt32)",
      "examples": "**Basic example with ARRAY JOIN**\n\n```sql title=Query\nCREATE TABLE test\n(\n    `id` UInt8,\n    `tag` Array(String),\n    `version` Array(String)\n)\nENGINE = MergeTree\nORDER BY id;\n\nINSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);\n\nSELECT\n    id,\n    tag,\n    version,\n    seq\nFROM test\nARRAY JOIN\n    tag,\n    version,\n    arrayEnumerate(tag) AS seq\n```\n\n```response title=Response\n┌─id─┬─tag────────────┬─version─────┬─seq─┐\n│  1 │ release-stable │ 2.4.0       │   1 │\n│  1 │ dev            │ 2.6.0-alpha │   2 │\n│  1 │ security       │ 2.4.0-sec1  │   3 │\n└────┴────────────────┴─────────────┴─────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayEnumerateDense",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayEnumerateDense(arr)",
      "description": "Returns an array of the same size as the source array, indicating where each element first appears in the source array.",
      "arguments": "- `arr` — The array to enumerate. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of the same size as `arr`, indicating where each element first appears in the source array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayEnumerateDense([10, 20, 10, 30])\n```\n\n```response title=Response\n[1,2,1,3]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayEnumerateDenseRanked",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)",
      "description": "Returns an array the same size as the source array, indicating where each element first appears in the source array. It allows for enumeration of a multidimensional array with the ability to specify how deep to look inside the array.",
      "arguments": "- `clear_depth` — Enumerate elements at the specified level separately. [`(U)Int*`](../data-types/int-uint.md) less than or equal to `max_arr_depth`.\n- `arr` — N-dimensional array to enumerate. [`Array(T)`](/sql-reference/data-types/array).\n- `max_array_depth` — The maximum effective depth. Positive [`(U)Int*`](../data-types/int-uint.md) less than or equal to the depth of `arr`.\n",
      "returnedValue": "Returns an array denoting where each element first appears in the source array. [Array](/sql-reference/data-types/array).",
      "examples": "**Basic usage**\n\n```sql title=Query\n-- With clear_depth=1 and max_array_depth=1, the result is identical to what arrayEnumerateDense would give.\n\nSELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);\n```\n\n```response title=Response\n[1,2,1,3]\n```\n\n**Usage with a multidimensional array**\n\n```sql title=Query\n-- In this example, arrayEnumerateDenseRanked is used to obtain an array indicating, for each element of the\n-- multidimensional array, what its position is among elements of the same value.\n-- For the first row of the passed array, [10, 10, 30, 20], the corresponding first row of the result is [1, 1, 2, 3],\n-- indicating that 10 is the first number encountered in position 1 and 2, 30 the second number encountered in position 3\n-- and 20 is the third number encountered in position 4.\n-- For the second row, [40, 50, 10, 30], the corresponding second row of the result is [4,5,1,2], indicating that 40\n-- and 50 are the fourth and fifth numbers encountered in position 1 and 2 of that row, that another 10\n-- (the first encountered number) is in position 3 and 30 (the second number encountered) is in the last position.\n\nSELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);\n```\n\n```response title=Response\n[[1,1,2,3],[4,5,1,2]]\n```\n\n**Example with increased clear_depth**\n\n```sql title=Query\n-- Changing clear_depth=2 results in the enumeration occurring separately for each row anew.\n\nSELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);\n```\n\n```response title=Response\n[[1, 1, 2, 3], [1, 2, 3, 4]]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayEnumerateUniq",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayEnumerateUniq(arr1[, arr2, ... , arrN])",
      "description": "\nReturns an array the same size as the source array, indicating for each element what its position is among elements with the same value.\n\nThis function is useful when using `ARRAY JOIN` and aggregation of array elements.\n\nThe function can take multiple arrays of the same size as arguments. In this case, uniqueness is considered for tuples of elements in the same positions in all the arrays.\n",
      "arguments": "- `arr1` — First array. [`Array(T)`](/sql-reference/data-types/array).\n- `[arr2, ..., arrN]` — Optional. Additional arrays of the same size for tuple uniqueness. [`Array(UInt32)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array where each element is the position among elements with the same value or tuple. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT arrayEnumerateUniq([10, 20, 10, 30]);\n```\n\n```response title=Response\n[1, 1, 2, 1]\n```\n\n**Multiple arrays**\n\n```sql title=Query\nSELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]);\n```\n\n```response title=Response\n[1,2,1,1,2,1]\n```\n\n**ARRAY JOIN aggregation**\n\n```sql title=Query\n-- Each goal ID has a calculation of the number of conversions (each element in the Goals nested data structure is a goal that was reached, which we refer to as a conversion)\n-- and the number of sessions. Without ARRAY JOIN, we would have counted the number of sessions as sum(Sign). But in this particular case,\n-- the rows were multiplied by the nested Goals structure, so in order to count each session one time after this, we apply a condition to the\n-- value of the arrayEnumerateUniq(Goals.ID) function.\n\nSELECT\n    Goals.ID AS GoalID,\n    sum(Sign) AS Reaches,\n    sumIf(Sign, num = 1) AS Visits\nFROM test.visits\nARRAY JOIN\n    Goals,\n    arrayEnumerateUniq(Goals.ID) AS num\nWHERE CounterID = 160656\nGROUP BY GoalID\nORDER BY Reaches DESC\nLIMIT 10\n```\n\n```response title=Response\n┌──GoalID─┬─Reaches─┬─Visits─┐\n│   53225 │    3214 │   1097 │\n│ 2825062 │    3188 │   1097 │\n│   56600 │    2803 │    488 │\n│ 1989037 │    2401 │    365 │\n│ 2830064 │    2396 │    910 │\n│ 1113562 │    2372 │    373 │\n│ 3270895 │    2262 │    812 │\n│ 1084657 │    2262 │    345 │\n│   56599 │    2260 │    799 │\n│ 3271094 │    2256 │    812 │\n└─────────┴─────────┴────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayEnumerateUniqRanked",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)",
      "description": "\nReturns an array (or multi-dimensional array) with the same dimensions as the source array,\nindicating for each element what it's position is among elements with the same value.\nIt allows for enumeration of a multi-dimensional array with the ability to specify how deep to look inside the array.\n",
      "arguments": "- `clear_depth` — Enumerate elements at the specified level separately. Positive [Integer](../data-types/int-uint.md) less than or equal to `max_arr_depth`.\n- `arr` — N-dimensional array to enumerate. [Array](/sql-reference/data-types/array).\n- `max_array_depth` — The maximum effective depth. Positive [Integer](../data-types/int-uint.md) less than or equal to the depth of `arr`.\n",
      "returnedValue": "Returns an N-dimensional array the same size as `arr` with each element showing the position of that element in relation to other elements of the same value.",
      "examples": "**Example 1**\n\n```sql title=Query\n-- With clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked\n-- is identical to that which arrayEnumerateUniq would give for the same array.\n\nSELECT arrayEnumerateUniqRanked(1, [1, 2, 1], 1);\n```\n\n```response title=Response\n[1, 1, 2]\n```\n\n**Example 2**\n\n```sql title=Query\n-- with clear_depth=1 and max_array_depth=1, the result of arrayEnumerateUniqRanked\n-- is identical to that which arrayEnumerateUniqwould give for the same array.\n\nSELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);\", \"[[1, 1, 1], [2, 3, 2], [2]]\n```\n\n```response title=Response\n[1, 1, 2]\n```\n\n**Example 3**\n\n```sql title=Query\n-- In this example, arrayEnumerateUniqRanked is used to obtain an array indicating,\n-- for each element of the multidimensional array, what its position is among elements\n-- of the same value. For the first row of the passed array, [1, 2, 3], the corresponding\n-- result is [1, 1, 1], indicating that this is the first time 1, 2 and 3 are encountered.\n-- For the second row of the provided array, [2, 2, 1], the corresponding result is [2, 3, 3],\n-- indicating that 2 is encountered for a second and third time, and 1 is encountered\n-- for the second time. Likewise, for the third row of the provided array [3] the\n-- corresponding result is [2] indicating that 3 is encountered for the second time.\n\nSELECT arrayEnumerateUniqRanked(1, [[1, 2, 3], [2, 2, 1], [3]], 2);\n```\n\n```response title=Response\n[[1, 1, 1], [2, 3, 2], [2]]\n```\n\n**Example 4**\n\n```sql title=Query\n-- Changing clear_depth=2, results in elements being enumerated separately for each row.\nSELECT arrayEnumerateUniqRanked(2,[[1, 2, 3],[2, 2, 1],[3]], 2);\n```\n\n```response title=Response\n[[1, 1, 1], [1, 2, 1], [1]]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayExists",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns `1` if there is at least one element in a source array for which `func(x[, y1, y2, ... yN])` returns true. Otherwise, it returns `0`.\n",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns `1` if the lambda function returns true for at least one element, `0` otherwise. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFill",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nThe `arrayFill` function sequentially processes a source array from the first element\nto the last, evaluating a lambda condition at each position using elements from\nthe source and condition arrays. When the lambda function evaluates to false at\nposition i, the function replaces that element with the element at position i-1\nfrom the current state of the array. The first element is always preserved\nregardless of any condition.\n",
      "arguments": "- `func(x [, y1, ..., yN])` — A lambda function `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])` which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Example with single array**\n\n```sql title=Query\nSELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res\n```\n\n```response title=Response\n[1,1,2,2]\n```\n\n**Example with two arrays**\n\n```sql title=Query\nSELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res\n```\n\n```response title=Response\n[5,5,6,6]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFilter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]",
      "description": "Returns an array containing only the elements in the source array for which a lambda function returns true.",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns a subset of the source array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Example 1**\n\n```sql title=Query\nSELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res\n```\n\n```response title=Response\n['abc World']\n```\n\n**Example 2**\n\n```sql title=Query\nSELECT\n    arrayFilter(\n        (i, x) -> x LIKE '%World%',\n        arrayEnumerate(arr),\n        ['Hello', 'abc World'] AS arr)\n    AS res\n```\n\n```response title=Response\n[2]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFirst",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the first element in the source array for which `func(x[, y1, y2, ... yN])` returns true, otherwise it returns a default value.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the first element of the source array for which `λ` is true, otherwise returns the default value of `T`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])\n```\n\n```response title=Response\nb\n```\n\n**No match**\n\n```sql title=Query\nSELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)\n```\n\n```response title=Response\n0 UInt8\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFirstIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the index of the first element in the source array for which `func(x[, y1, y2, ... yN])` returns true, otherwise it returns '0'.\n",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the index of the first element of the source array for which `func` is true, otherwise returns `0`. [`UInt32`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])\n```\n\n```response title=Response\n2\n```\n\n**No match**\n\n```sql title=Query\nSELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFirstOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the first element in the source array for which `func(x[, y1, y2, ... yN])` returns true, otherwise it returns `NULL`.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the first element of the source array for which `func` is true, otherwise returns `NULL`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])\n```\n\n```response title=Response\nb\n```\n\n**No match**\n\n```sql title=Query\nSELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)\n```\n\n```response title=Response\nNULL Nullable(UInt8)\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFlatten",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFlatten(arr)",
      "description": "\nConverts an array of arrays to a flat array.\n\nFunction:\n\n- Applies to any depth of nested arrays.\n- Does not change arrays that are already flat.\n\nThe flattened array contains all the elements from all source arrays.\n",
      "arguments": "- `arr` — A multidimensional array. [`Array(T)`](/sql-reference/data-types/array)(`Array`)\n",
      "returnedValue": "Returns a flattened array from the multidimensional array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayFlatten([[[1]], [[2], [3]]]);\n```\n\n```response title=Response\n[1,2,3]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayFold",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)",
      "description": "Applies a lambda function to one or more equally-sized arrays and collects the result in an accumulator.",
      "arguments": "- `λ(x, x1 [, x2, x3, ... xN])` — A lambda function `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])` where `F` is an operation applied to `acc` and array values from `x` with the result of `acc` re-used. [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `arr1 [, arr2, arr3, ... arrN]` — N arrays over which to operate. [`Array(T)`](/sql-reference/data-types/array)\n- `acc` — Accumulator value with the same type as the return type of the Lambda function.\n",
      "returnedValue": "Returns the final `acc` value.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;\n```\n\n```response title=Response\n23\n```\n\n**Fibonacci sequence**\n\n```sql title=Query\nSELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);\n```\n\n```response title=Response\n┌─fibonacci─┐\n│         0 │\n│         1 │\n│         1 │\n│         2 │\n│         3 │\n│         5 │\n│         8 │\n│        13 │\n│        21 │\n│        34 │\n└───────────┘\n```\n\n**Example using multiple arrays**\n\n```sql title=Query\nSELECT arrayFold(\n(acc, x, y) -> acc + (x * y),\n[1, 2, 3, 4],\n[10, 20, 30, 40],\n0::Int64\n) AS res;\n```\n\n```response title=Response\n300\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayIntersect",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayIntersect(arr, arr1, ..., arrN)",
      "description": "Takes multiple arrays and returns an array with elements which are present in all source arrays. The result contains only unique values.",
      "arguments": "- `arrN` — N arrays from which to make the new array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array with distinct elements that are present in all N arrays. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT\narrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,\narrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection\n```\n\n```response title=Response\n┌─non_empty_intersection─┬─empty_intersection─┐\n│ []                     │ [1]                │\n└────────────────────────┴────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayJaccardIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayJaccardIndex(arr_x, arr_y)",
      "description": "Returns the [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) of two arrays.",
      "arguments": "- `arr_x` — First array. [`Array(T)`](/sql-reference/data-types/array).\n- `arr_y` — Second array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the Jaccard index of `arr_x` and `arr_y`.[Float64](/sql-reference/data-types/float)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayJaccardIndex([1, 2], [2, 3]) AS res\n```\n\n```response title=Response\n0.3333333333333333\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayJoin",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayJoin(arr)",
      "description": "\nThe `arrayJoin` function takes a row that contains an array and unfolds it, generating multiple rows – one for each element in the array.\nThis is in contrast to Regular Functions in ClickHouse which map input values to output values within the same row,\nand Aggregate Functions which take a group of rows and \"compress\" or \"reduce\" them into a single summary row\n(or a single value within a summary row if used with `GROUP BY`).\n\nAll the values in the columns are simply copied, except the values in the column where this function is applied;\nthese are replaced with the corresponding array value.\n",
      "arguments": "- `arr` — An array to unfold. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns a set of rows unfolded from `arr`.",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src\n```\n\n```response title=Response\n┌─dst─┬─\\'Hello\\'─┬─src─────┐\n│   1 │ Hello     │ [1,2,3] │\n│   2 │ Hello     │ [1,2,3] │\n│   3 │ Hello     │ [1,2,3] │\n└─────┴───────────┴─────────┘\n```\n\n**arrayJoin affects all sections of the query**\n\n```sql title=Query\n-- The arrayJoin function affects all sections of the query, including the WHERE section. Notice the result 2, even though the subquery returned 1 row.\n\nSELECT sum(1) AS impressions\nFROM\n(\n    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities\n)\nWHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];\n```\n\n```response title=Response\n┌─impressions─┐\n│           2 │\n└─────────────┘\n```\n\n**Using multiple arrayJoin functions**\n\n```sql title=Query\n- A query can use multiple arrayJoin functions. In this case, the transformation is performed multiple times and the rows are multiplied.\n\nSELECT\n    sum(1) AS impressions,\n    arrayJoin(cities) AS city,\n    arrayJoin(browsers) AS browser\nFROM\n(\n    SELECT\n        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,\n        ['Firefox', 'Chrome', 'Chrome'] AS browsers\n)\nGROUP BY\n    2,\n    3\n```\n\n```response title=Response\n┌─impressions─┬─city─────┬─browser─┐\n│           2 │ Istanbul │ Chrome  │\n│           1 │ Istanbul │ Firefox │\n│           2 │ Berlin   │ Chrome  │\n│           1 │ Berlin   │ Firefox │\n│           2 │ Bobruisk │ Chrome  │\n│           1 │ Bobruisk │ Firefox │\n└─────────────┴──────────┴─────────┘\n```\n\n**Unexpected results due to optimizations**\n\n```sql title=Query\n-- Using multiple arrayJoin with the same expression may not produce the expected result due to optimizations.\n-- For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.\n- e.g. arrayJoin(arraySort(arr)), arrayJoin(arrayConcat(arr, []))\n\nSELECT\n    arrayJoin(dice) as first_throw,\n    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set\n    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation\nFROM (\n    SELECT [1, 2, 3, 4, 5, 6] as dice\n);\n```\n\n```response title=Response\n┌─first_throw─┬─second_throw─┐\n│           1 │            1 │\n│           1 │            2 │\n│           1 │            3 │\n│           1 │            4 │\n│           1 │            5 │\n│           1 │            6 │\n│           2 │            1 │\n│           2 │            2 │\n│           2 │            3 │\n│           2 │            4 │\n│           2 │            5 │\n│           2 │            6 │\n│           3 │            1 │\n│           3 │            2 │\n│           3 │            3 │\n│           3 │            4 │\n│           3 │            5 │\n│           3 │            6 │\n│           4 │            1 │\n│           4 │            2 │\n│           4 │            3 │\n│           4 │            4 │\n│           4 │            5 │\n│           4 │            6 │\n│           5 │            1 │\n│           5 │            2 │\n│           5 │            3 │\n│           5 │            4 │\n│           5 │            5 │\n│           5 │            6 │\n│           6 │            1 │\n│           6 │            2 │\n│           6 │            3 │\n│           6 │            4 │\n│           6 │            5 │\n│           6 │            6 │\n└─────────────┴──────────────┘\n```\n\n**Using the ARRAY JOIN syntax**\n\n```sql title=Query\n-- Note the ARRAY JOIN syntax in the `SELECT` query below, which provides broader possibilities.\n-- ARRAY JOIN allows you to convert multiple arrays with the same number of elements at a time.\n\nSELECT\n    sum(1) AS impressions,\n    city,\n    browser\nFROM\n(\n    SELECT\n        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,\n        ['Firefox', 'Chrome', 'Chrome'] AS browsers\n)\nARRAY JOIN\n    cities AS city,\n    browsers AS browser\nGROUP BY\n    2,\n    3\n```\n\n```response title=Response\n┌─impressions─┬─city─────┬─browser─┐\n│           1 │ Istanbul │ Firefox │\n│           1 │ Berlin   │ Chrome  │\n│           1 │ Bobruisk │ Chrome  │\n└─────────────┴──────────┴─────────┘\n```\n\n**Using Tuple**\n\n```sql title=Query\n-- You can also use Tuple\n\nSELECT\n    sum(1) AS impressions,\n    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,\n    t.2 AS browser\nFROM\n(\n    SELECT\n        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,\n        ['Firefox', 'Chrome', 'Chrome'] AS browsers\n)\nGROUP BY\n    2,\n    3\n```\n\n```response title=Response\n┌─impressions─┬─city─────┬─browser─┐\n│           1 │ Istanbul │ Firefox │\n│           1 │ Berlin   │ Chrome  │\n│           1 │ Bobruisk │ Chrome  │\n└─────────────┴──────────┴─────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayLast",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])",
      "description": "\nReturns the last element in the source array for which a lambda `func(x [, y1, y2, ... yN])` returns true, otherwise it returns a default value.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1, ... , condN]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the last element of the source array for which `func` is true, otherwise returns the default value of `T`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])\n```\n\n```response title=Response\nc\n```\n\n**No match**\n\n```sql title=Query\nSELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)\n```\n\n```response title=Response\n0 UInt8\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayLastIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayLastIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the index of the last element in the source array for which `func(x[, y1, y2, ... yN])` returns true, otherwise it returns '0'.\n",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the index of the last element of the source array for which `func` is true, otherwise returns `0`. [`UInt32`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c']);\n```\n\n```response title=Response\n3\n```\n\n**No match**\n\n```sql title=Query\nSELECT arrayLastIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f']);\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayLastOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the last element in the source array for which a lambda `func(x [, y1, y2, ... yN])` returns true, otherwise it returns `NULL`.\n    ",
      "arguments": "- `func(x [, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the last element of the source array for which `λ` is not true, otherwise returns `NULL`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])\n```\n\n```response title=Response\nc\n```\n\n**No match**\n\n```sql title=Query\nSELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)\n```\n\n```response title=Response\nNULL Nullable(UInt8)\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayLevenshteinDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayLevenshteinDistance(from, to)",
      "description": "Calculates the Levenshtein distance for two arrays.",
      "arguments": "- `from` — The first array. [`Array(T)`](/sql-reference/data-types/array).\n- `to` — The second array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Levenshtein distance between the first and the second arrays. [`Float64`](/sql-reference/data-types/float).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])\n```\n\n```response title=Response\n1\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayLevenshteinDistanceWeighted",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)",
      "description": "\nCalculates Levenshtein distance for two arrays with custom weights for each element.\nThe number of elements for the array and its weights should match.\n    ",
      "arguments": "- `from` — first array. [`Array(T)`](/sql-reference/data-types/array).\n- `to` — second array. [`Array(T)`](/sql-reference/data-types/array).\n- `from_weights` — weights for the first array. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array).\n- `to_weights` — weights for the second array. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Levenshtein distance between the first and the second arrays with custom weights for each element. [`Float64`](/sql-reference/data-types/float).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])\n```\n\n```response title=Response\n14\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayMap",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayMap(func, arr)",
      "description": "\nReturns an array obtained from the original arrays by applying a lambda function to each element.\n",
      "arguments": "- `func` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `arr` — N arrays to process. [Array(T)](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array from the lambda results. [`Array(T)`](/sql-reference/data-types/array)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;\n```\n\n```response title=Response\n[3,4,5]\n```\n\n**Creating a tuple of elements from different arrays**\n\n```sql title=Query\nSELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res\n```\n\n```response title=Response\n[(1,4),(2,5),(3,6)]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayMax",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the maximum element in the source array.\n\nIf a lambda function `func` is specified, returns the maximum element of the lambda results.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — Optional. A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the maximum element in the source array, or the minimum element of the lambda results if provided.",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT arrayMax([5, 3, 2, 7]);\n```\n\n```response title=Response\n7\n```\n\n**Usage with lambda function**\n\n```sql title=Query\nSELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);\n```\n\n```response title=Response\n12\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayMin",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the minimum element in the source array.\n\nIf a lambda function `func` is specified, returns the minimum element of the lambda results.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — Optional. A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the minimum element in the source array, or the minimum element of the lambda results if provided.",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT arrayMin([5, 3, 2, 7]);\n```\n\n```response title=Response\n2\n```\n\n**Usage with lambda function**\n\n```sql title=Query\nSELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);\n```\n\n```response title=Response\n4\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayNormalizedGini",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayNormalizedGini(predicted, label)",
      "description": "Calculates the normalized Gini coefficient.",
      "arguments": "- `predicted` — The predicted value. [`Array(T)`](/sql-reference/data-types/array).\n- `label` — The actual value. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "A tuple containing the Gini coefficients of the predicted values, the Gini coefficient of the normalized values, and the normalized Gini coefficient (= the ratio of the former two Gini coefficients). [Tuple(Float64, Float64, Float64)](/sql-reference/data-types/tuple).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);\n```\n\n```response title=Response\n(0.18055555555555558,0.2638888888888889,0.6842105263157896)\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPRAUC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "arrayAUCPR",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "arrayPartialReverseSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)",
      "description": "\nThis function is the same as `arrayReverseSort` but with an additional `limit` argument allowing partial sorting.\n\n:::tip\nTo retain only the sorted elements use `arrayResize`.\n:::\n    ",
      "arguments": "- `f(arr[, arr1, ... ,arrN])` — The lambda function to apply to elements of array `x`.\n- `arr` — Array to be sorted. [`Array(T)`](/sql-reference/data-types/array).\n- `arr1, ... ,arrN` — N additional arrays, in the case when `f` accepts multiple arguments. [`Array(T)`](/sql-reference/data-types/array).\n- `limit` — Index value up until which sorting will occur. [`(U)Int*`](/sql-reference/data-types/int-uint)`]\n",
      "returnedValue": "Returns an array of the same size as the original array where elements in the range `[1..limit]` are sorted\nin descending order. The remaining elements `(limit..N]` are in an unspecified order.",
      "examples": "**simple_int**\n\n```sql title=Query\nSELECT arrayPartialReverseSort(2, [5, 9, 1, 3])\n```\n\n```response title=Response\n[9,5,1,3]\n```\n\n**simple_string**\n\n```sql title=Query\nSELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])\n```\n\n```response title=Response\n['lasso','gladly','expenses','embolism']\n```\n\n**retain_sorted**\n\n```sql title=Query\nSELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)\n```\n\n```response title=Response\n[9,5]\n```\n\n**lambda_simple**\n\n```sql title=Query\nSELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])\n```\n\n```response title=Response\n[1,3,5,9]\n```\n\n**lambda_complex**\n\n```sql title=Query\nSELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res\n```\n\n```response title=Response\n[0,1,2]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPartialShuffle",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "arrayPartialShuffle(arr [, limit[, seed]])",
      "description": "\nReturns an array of the same size as the original array where elements in range `[1..limit]` are a random\nsubset of the original array. Remaining `(limit..n]` shall contain the elements not in `[1..limit]` range in undefined order.\nValue of limit shall be in range `[1..n]`. Values outside of that range are equivalent to performing full `arrayShuffle`:\n\n:::note\nThis function will not materialize constants.\n\nThe value of `limit` should be in the range `[1..N]`. Values outside of that range are equivalent to performing full [`arrayShuffle`](#arrayshuffle).\n:::\n    ",
      "arguments": "- `arr` — The array to shuffle. [`Array(T)`](/sql-reference/data-types/array).\n- `seed` — Optional. The seed to be used with random number generation. If not provided, a random one is used. [`(U)Int*`](../data-types/int-uint.md).\n- `limit` — Optional. The number to limit element swaps to, in the range `[1..N]`. [`(U)Int*`](../data-types/int-uint.md).\n",
      "returnedValue": "Array with elements partially shuffled. [`Array(T)`](/sql-reference/data-types/array)).",
      "examples": "**no_limit1**\n\n```sql title=Query\nSELECT arrayPartialShuffle([1, 2, 3, 4], 0)\n```\n\n```response title=Response\n[2,4,3,1]\n```\n\n**no_limit2**\n\n```sql title=Query\nSELECT arrayPartialShuffle([1, 2, 3, 4])\n```\n\n```response title=Response\n[4,1,3,2]\n```\n\n**random_seed**\n\n```sql title=Query\nSELECT arrayPartialShuffle([1, 2, 3, 4], 2)\n```\n\n```response title=Response\n[3,4,1,2]\n```\n\n**explicit_seed**\n\n```sql title=Query\nSELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)\n```\n\n```response title=Response\n[3,2,1,4]\n```\n\n**materialize**\n\n```sql title=Query\nSELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)\n```\n\n```response title=Response\n┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐\n│ [3,2,1,4]                │ [3,2,1]                  │\n│ [3,2,1,4]                │ [3,2,1]                  │\n│ [4,3,2,1]                │ [3,2,1]                  │\n│ [1,4,3,2]                │ [3,2,1]                  │\n│ [3,4,1,2]                │ [3,2,1]                  │\n│ [1,2,3,4]                │ [3,2,1]                  │\n│ [1,4,3,2]                │ [3,2,1]                  │\n│ [1,4,3,2]                │ [3,2,1]                  │\n│ [3,1,2,4]                │ [3,2,1]                  │\n│ [1,3,2,4]                │ [3,2,1]                  │\n└──────────────────────────┴──────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPartialSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)",
      "description": "\nThis function is the same as `arraySort` but with an additional `limit` argument allowing partial sorting.\n\n:::tip\nTo retain only the sorted elements use `arrayResize`.\n:::\n    ",
      "arguments": "- `f(arr[, arr1, ... ,arrN])` — The lambda function to apply to elements of array `x`.\n- `arr` — Array to be sorted. [`Array(T)`](/sql-reference/data-types/array).\n- `arr1, ... ,arrN` — N additional arrays, in the case when `f` accepts multiple arguments. [`Array(T)`](/sql-reference/data-types/array).\n- `limit` — Index value up until which sorting will occur. [`(U)Int*`](/sql-reference/data-types/int-uint)`]\n",
      "returnedValue": "Returns an array of the same size as the original array where elements in the range `[1..limit]` are sorted\nin ascending order. The remaining elements `(limit..N]` are in an unspecified order.",
      "examples": "**simple_int**\n\n```sql title=Query\nSELECT arrayPartialSort(2, [5, 9, 1, 3])\n```\n\n```response title=Response\n[1,3,5,9]\n```\n\n**simple_string**\n\n```sql title=Query\nSELECT arrayPartialSort(2, ['expenses','lasso','embolism','gladly'])\n```\n\n```response title=Response\n['embolism','expenses','gladly','lasso']\n```\n\n**retain_sorted**\n\n```sql title=Query\nSELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)\n```\n\n```response title=Response\n[1,3]\n```\n\n**lambda_simple**\n\n```sql title=Query\nSELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])\n```\n\n```response title=Response\n[9,5,1,3]\n```\n\n**lambda_complex**\n\n```sql title=Query\nSELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res\n```\n\n```response title=Response\n[2,1,0]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPopBack",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayPopBack(arr)",
      "description": "Removes the last element from the array.",
      "arguments": "- `arr` — The array for which to remove the last element from. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array identical to `arr` but without the last element of `arr`. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayPopBack([1, 2, 3]) AS res;\n```\n\n```response title=Response\n[1,2]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPopFront",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayPopFront(arr)",
      "description": "Removes the first item from the array.",
      "arguments": "- `arr` — The array for which to remove the first element from. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array identical to `arr` but without the first element of `arr`. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayPopFront([1, 2, 3]) AS res;\n```\n\n```response title=Response\n[2,3]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayProduct",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the product of elements in the source array.\n\nIf a lambda function `func` is specified, returns the product of elements of the lambda results.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — Optional. A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the product of elements in the source array, or the product of elements of the lambda results if provided. [`Float64`](/sql-reference/data-types/float).",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT arrayProduct([1, 2, 3, 4]);\n```\n\n```response title=Response\n24\n```\n\n**Usage with lambda function**\n\n```sql title=Query\nSELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;\n```\n\n```response title=Response\n16\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPushBack",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayPushBack(arr, x)",
      "description": "Adds one item to the end of the array.",
      "arguments": "- `arr` — The array for which to add value `x` to the end of. [`Array(T)`](/sql-reference/data-types/array).\n- `x` — \n- Single value to add to the end of the array. [`Array(T)`](/sql-reference/data-types/array).\n\n:::note\n- Only numbers can be added to an array with numbers, and only strings can be added to an array of strings.\n- When adding numbers, ClickHouse automatically sets the type of `x` for the data type of the array.\n- Can be `NULL`. The function adds a `NULL` element to an array, and the type of array elements converts to `Nullable`.\n\nFor more information about the types of data in ClickHouse, see [Data types](/sql-reference/data-types).\n:::\n    \n",
      "returnedValue": "Returns an array identical to `arr` but with an additional value `x` at the end of the array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayPushBack(['a'], 'b') AS res;\n```\n\n```response title=Response\n['a','b']\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayPushFront",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayPushFront(arr, x)",
      "description": "Adds one element to the beginning of the array.",
      "arguments": "- `arr` — The array for which to add value `x` to the end of. [`Array(T)`](/sql-reference/data-types/array).\n- `x` — \n- Single value to add to the start of the array. [`Array(T)`](/sql-reference/data-types/array).\n\n:::note\n- Only numbers can be added to an array with numbers, and only strings can be added to an array of strings.\n- When adding numbers, ClickHouse automatically sets the type of `x` for the data type of the array.\n- Can be `NULL`. The function adds a `NULL` element to an array, and the type of array elements converts to `Nullable`.\n\nFor more information about the types of data in ClickHouse, see [Data types](/sql-reference/data-types).\n:::\n    \n",
      "returnedValue": "Returns an array identical to `arr` but with an additional value `x` at the beginning of the array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayPushFront(['b'], 'a') AS res;\n```\n\n```response title=Response\n['a','b']\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayROCAUC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayROCAUC(scores, labels[, scale[, partial_offsets]])",
      "description": "\nCalculates the area under the receiver operating characteristic (ROC) curve.\nA ROC curve is created by plotting True Positive Rate (TPR) on the y-axis and False Positive Rate (FPR) on the x-axis across all thresholds.\nThe resulting value ranges from zero to one, with a higher value indicating better model performance.\n\nThe ROC AUC (also known as simply AUC) is a concept in machine learning.\nFor more details, please see [here](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [here](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) and [here](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).\n",
      "arguments": "- `scores` — Scores prediction model gives. [`Array(T)`](/sql-reference/data-types/array) of [Integers](../data-types/int-uint.md) or [Floats](../data-types/float.md).\n- `labels` — Labels of samples, usually 1 for positive sample and 0 for negative sample. [Array](/sql-reference/data-types/array) of [Integers](../data-types/int-uint.md) or [Enums](../data-types/enum.md).\n- `scale` — Decides whether to return the normalized area. If false, returns the area under the TP (true positives) x FP (false positives) curve instead. Default value: true. [Bool](../data-types/boolean.md). Optional.\n- `partial_offsets` — \n- An array of four non-negative integers for calculating a partial area under the ROC curve (equivalent to a vertical band of the ROC space) instead of the whole AUC. This option is useful for distributed computation of the ROC AUC. The array must contain the following elements [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) of non-negative [Integers](../data-types/int-uint.md). Optional.\n    - `higher_partitions_tp`: The number of positive labels in the higher-scored partitions.\n    - `higher_partitions_fp`: The number of negative labels in the higher-scored partitions.\n    - `total_positives`: The total number of positive samples in the entire dataset.\n    - `total_negatives`: The total number of negative samples in the entire dataset.\n\n::::note\nWhen `arr_partial_offsets` is used, the `arr_scores` and `arr_labels` should be only a partition of the entire dataset, containing an interval of scores.\nThe dataset should be divided into contiguous partitions, where each partition contains the subset of the data whose scores fall within a specific range.\nFor example:\n- One partition could contain all scores in the range [0, 0.5).\n- Another partition could contain scores in the range [0.5, 1.0].\n::::\n\n",
      "returnedValue": "Returns area under the receiver operating characteristic (ROC) curve. [Float64](../data-types/float.md).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);\n```\n\n```response title=Response\n0.75\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayRandomSample",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayRandomSample(arr, samples)",
      "description": "Returns a subset with `samples`-many random elements of an input array. If `samples` exceeds the size of the input array, the sample size is limited to the size of the array, i.e. all array elements are returned but their order is not guaranteed. The function can handle both flat arrays and nested arrays.",
      "arguments": "- `arr` — The input array or multidimensional array from which to sample elements. ([`Array(T)`](/sql-reference/data-types/array)).\n- `samples` — The number of elements to include in the random sample ([`(U)Int*`](../data-types/int-uint.md)).\n",
      "returnedValue": "An array containing a random sample of elements from the input array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;\n```\n\n```response title=Response\n['cherry','apple']\n```\n\n**Using a multidimensional array**\n\n```sql title=Query\nSELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;\n```\n\n```response title=Response\n[[3,4],[5,6]]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayReduce",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayReduce(agg_f, arr1 [, arr2, ... , arrN)]",
      "description": "\nApplies an aggregate function to array elements and returns its result.\nThe name of the aggregation function is passed as a string in single quotes `'max'`, `'sum'`.\nWhen using parametric aggregate functions, the parameter is indicated after the function name in parentheses `'uniqUpTo(6)'`.\n",
      "arguments": "- `agg_f` — The name of an aggregate function which should be a constant [String](/sql-reference/data-types/string).\n- `arr1 [, arr2, ... , arrN)]` — N arrays corresponding to the arguments of `agg_f`. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the result of the aggregate function",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayReduce('max', [1, 2, 3]);\n```\n\n```response title=Response\n┌─arrayReduce('max', [1, 2, 3])─┐\n│                             3 │\n└───────────────────────────────┘\n```\n\n**Example with aggregate function using multiple arguments**\n\n```sql title=Query\n--If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.\n\nSELECT arrayReduce('maxIf', [3, 5], [1, 0]);\n```\n\n```response title=Response\n┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐\n│                                    3 │\n└──────────────────────────────────────┘\n```\n\n**Example with a parametric aggregate function**\n\n```sql title=Query\nSELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n```\n\n```response title=Response\n┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐\n│                                                           4 │\n└─────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayReduceInRanges",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)]",
      "description": "\nApplies an aggregate function to array elements in the given ranges and returns an array containing the result corresponding to each range.\nThe function will return the same result as multiple `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.\n",
      "arguments": "- `agg_f` — The name of the aggregate function to use. [String](/sql-reference/data-types/string)\n- `ranges` — The range over which to aggregate. An array of tuples, `(i, r)` containing the index `i` from which to begin from and the range `r` over which to aggregate [`Array(T)`](/sql-reference/data-types/array)([`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple))\n- `arr1 [, arr2, ... ,arrN)]` — N arrays as arguments to the aggregate function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array containing results of the aggregate function over the specified ranges. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayReduceInRanges(\n    'sum',\n    [(1, 5), (2, 3), (3, 4), (4, 4)],\n    [1000000, 200000, 30000, 4000, 500, 60, 7]\n) AS res\n```\n\n```response title=Response\n┌─res─────────────────────────┐\n│ [1234500,234000,34560,4567] │\n└─────────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayResize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayResize(arr, size[, extender])",
      "description": "Changes the length of the array.",
      "arguments": "- `arr` — Array to resize. [Array(T)](/sql-reference/data-types/array)\n- `size` — \n-The new length of the array.\nIf `size` is less than the original size of the array, the array is truncated from the right.\nIf `size` is larger than the initial size of the array, the array is extended to the right with `extender` values or default values for the data type of the array items.\n\n- `extender` — Value to use for extending the array. Can be `NULL`.\n",
      "returnedValue": "An array of length `size`. [Array(T)](/sql-reference/data-types/array).",
      "examples": "**Example 1**\n\n```sql title=Query\nSELECT arrayResize([1], 3);\n```\n\n```response title=Response\n[1,0,0]\n```\n\n**Example 2**\n\n```sql title=Query\nSELECT arrayResize([1], 3, NULL);\n```\n\n```response title=Response\n[1,NULL,NULL]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayReverse",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayReverse(arr)",
      "description": "\nReverses the order of elements of a given array.\n\n:::note\nFunction `reverse(arr)` performs the same functionality but works on other data-types\nin addition to Arrays.\n:::\n",
      "arguments": "- `arr` — The array to reverse. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of the same size as the original array containing the elements in reverse order. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayReverse([1, 2, 3])\n```\n\n```response title=Response\n[3,2,1]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayReverseFill",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nThe `arrayReverseFill` function sequentially processes a source array from the last\nelement to the first, evaluating a lambda condition at each position using elements\nfrom the source and condition arrays. When the condition evaluates to false at\nposition i, the function replaces that element with the element at position i+1\nfrom the current state of the array. The last element is always preserved\nregardless of any condition.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array with elements of the source array replaced by the results of the lambda. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Example with a single array**\n\n```sql title=Query\nSELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res\n```\n\n```response title=Response\n[1,2,2,NULL]\n```\n\n**Example with two arrays**\n\n```sql title=Query\nSELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;\n```\n\n```response title=Response\n[5,6,6,2]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayReverseSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayReverseSort([f,] arr [, arr1, ... ,arrN)",
      "description": "\nSorts the elements of an array in descending order.\nIf a function `f` is specified, the provided array is sorted according to the result\nof the function applied to the elements of the array, and then the sorted array is reversed.\nIf `f` accepts multiple arguments, the `arrayReverseSort` function is passed several arrays that\nthe arguments of `func` will correspond to.\n\nIf the array to sort contains `-Inf`, `NULL`, `NaN`, or `Inf` they will be sorted in the following order:\n\n1. `-Inf`\n2. `Inf`\n3. `NaN`\n4. `NULL`\n\n`arrayReverseSort` is a [higher-order function](/sql-reference/functions/overview#higher-order-functions).\n    ",
      "arguments": "- `f(y1[, y2 ... yN])` — The lambda function to apply to elements of array `x`.\n- `arr` — An array to be sorted. [`Array(T)`](/sql-reference/data-types/array)\n- `arr1, ..., yN` — Optional. N additional arrays, in the case when `f` accepts multiple arguments.\n",
      "returnedValue": "Returns the array `x` sorted in descending order if no lambda function is provided, otherwise\nit returns an array sorted according to the logic of the provided lambda function, and then reversed. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Example 1**\n\n```sql title=Query\nSELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;\n```\n\n```response title=Response\n[5,3,4]\n```\n\n**Example 2**\n\n```sql title=Query\nSELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;\n```\n\n```response title=Response\n[4,3,5]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayReverseSplit",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "Split a source array into multiple arrays. When `func(x[, y1, ..., yN])` returns something other than zero, the array will be split to the right of the element. The array will not be split after the last element.",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of arrays. [`Array(Array(T))`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res\n```\n\n```response title=Response\n[[1], [2, 3, 4], [5]]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayRotateLeft",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayRotateLeft(arr, n)",
      "description": "Rotates an array to the left by the specified number of elements. Negative values of `n` are treated as rotating to the right by the absolute value of the rotation.",
      "arguments": "- `arr` — The array for which to rotate the elements.[`Array(T)`](/sql-reference/data-types/array).\n- `n` — Number of elements to rotate. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "An array rotated to the left by the specified number of elements. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;\n```\n\n```response title=Response\n[3,4,5,6,1,2]\n```\n\n**Negative value of n**\n\n```sql title=Query\nSELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;\n```\n\n```response title=Response\n[5,6,1,2,3,4]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayRotateRight",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayRotateRight(arr, n)",
      "description": "Rotates an array to the right by the specified number of elements. Negative values of `n` are treated as rotating to the left by the absolute value of the rotation.",
      "arguments": "- `arr` — The array for which to rotate the elements.[`Array(T)`](/sql-reference/data-types/array).\n- `n` — Number of elements to rotate. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "An array rotated to the right by the specified number of elements. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;\n```\n\n```response title=Response\n[5,6,1,2,3,4]\n```\n\n**Negative value of n**\n\n```sql title=Query\nSELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;\n```\n\n```response title=Response\n[3,4,5,6,1,2]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayShiftLeft",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayShiftLeft(arr, n[, default])",
      "description": "\nShifts an array to the left by the specified number of elements.\nNew elements are filled with the provided argument or the default value of the array element type.\nIf the number of elements is negative, the array is shifted to the right.\n    ",
      "arguments": "- `arr` — The array for which to shift the elements.[`Array(T)`](/sql-reference/data-types/array).\n- `n` — Number of elements to shift.[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n- `default` — Optional. Default value for new elements.\n",
      "returnedValue": "An array shifted to the left by the specified number of elements. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;\n```\n\n```response title=Response\n[3,4,5,6,0,0]\n```\n\n**Negative value of n**\n\n```sql title=Query\nSELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;\n```\n\n```response title=Response\n[0,0,1,2,3,4]\n```\n\n**Using a default value**\n\n```sql title=Query\nSELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;\n```\n\n```response title=Response\n[3,4,5,6,42,42]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayShiftRight",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayShiftRight(arr, n[, default])",
      "description": "\nShifts an array to the right by the specified number of elements.\nNew elements are filled with the provided argument or the default value of the array element type.\nIf the number of elements is negative, the array is shifted to the left.\n    ",
      "arguments": "- `arr` — The array for which to shift the elements. [`Array(T)`](/sql-reference/data-types/array).\n- `n` — Number of elements to shift. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n- `default` — Optional. Default value for new elements.\n",
      "returnedValue": "An array shifted to the right by the specified number of elements. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayShiftRight([1,2,3,4,5,6], 2) as res;\n```\n\n```response title=Response\n[0,0,1,2,3,4]\n```\n\n**Negative value of n**\n\n```sql title=Query\nSELECT arrayShiftRight([1,2,3,4,5,6], -2) as res;\n```\n\n```response title=Response\n[3,4,5,6,0,0]\n```\n\n**Using a default value**\n\n```sql title=Query\nSELECT arrayShiftRight([1,2,3,4,5,6], 2, 42) as res;\n```\n\n```response title=Response\n[42,42,1,2,3,4]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayShingles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayShingles(arr, l)",
      "description": "Generates an array of shingles (similar to ngrams for strings), i.e. consecutive sub-arrays with a specified length of the input array.",
      "arguments": "- `arr` — Array for which to generate an array of shingles. [`Array(T)`](/sql-reference/data-types/array).\n- `l` — The length of each shingle. [`(U)Int*`](/sql-reference/data-types/int-uint)\n",
      "returnedValue": "An array of generated shingles. [`Array(T)`](/sql-reference/data-types/array)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayShingles([1,2,3,4], 3) as res;\n```\n\n```response title=Response\n[[1,2,3],[2,3,4]]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayShuffle",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "arrayShuffle(arr [, seed])",
      "description": "\nReturns an array of the same size as the original array containing the elements in shuffled order.\nElements are reordered in such a way that each possible permutation of those elements has equal probability of appearance.\n\n:::note\nThis function will not materialize constants.\n:::\n    ",
      "arguments": "- `arr` — The array to shuffle. [`Array(T)`](/sql-reference/data-types/array).\n- `seed (optional)` — Optional. The seed to be used with random number generation. If not provided a random one is used. [`(U)Int*`](../data-types/int-uint.md).\n",
      "returnedValue": "Array with elements shuffled. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Example without seed (unstable results)**\n\n```sql title=Query\nSELECT arrayShuffle([1, 2, 3, 4]);\n```\n\n```response title=Response\n[1,4,2,3]\n```\n\n**Example without seed (stable results)**\n\n```sql title=Query\nSELECT arrayShuffle([1, 2, 3, 4], 41);\n```\n\n```response title=Response\n[3,2,1,4]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arraySimilarity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arraySimilarity(from, to, from_weights, to_weights)",
      "description": "\nCalculates the similarity of two arrays from `0` to `1` based on weighted Levenshtein distance.\n",
      "arguments": "- `from` — first array\n- `to` — second array\n- `from_weights` — weights for the first array. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array).\n- `to_weights` — weights for the second array. [`Array((U)Int*|Float*)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the similarity between `0` and `1` of the two arrays based on the weighted Levenshtein distance. [`Float64`](/sql-reference/data-types/float).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);\n```\n\n```response title=Response\n0.2222222222222222\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arraySlice",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arraySlice(arr, offset [, length])",
      "description": "Returns a slice of the array, with `NULL` elements included.",
      "arguments": "- `arr` — Array to slice. [`Array(T)`](/sql-reference/data-types/array).\n- `offset` — Indent from the edge of the array. A positive value indicates an offset on the left, and a negative value is an indent on the right. Numbering of the array items begins with `1`. [`(U)Int*`](/sql-reference/data-types/int-uint).\n- `length` — The length of the required slice. If you specify a negative value, the function returns an open slice `[offset, array_length - length]`. If you omit the value, the function returns the slice `[offset, the_end_of_array]`. [`(U)Int*`](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "Returns a slice of the array with `length` elements from the specified `offset`. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;\n```\n\n```response title=Response\n[2,NULL,4]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arraySort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arraySort([f,] arr [, arr1, ... ,arrN])",
      "description": "\nSorts the elements of the provided array in ascending order.\nIf a lambda function `f` is specified, sorting order is determined by the result of\nthe lambda applied to each element of the array.\nIf the lambda accepts multiple arguments, the `arraySort` function is passed several\narrays that the arguments of `f` will correspond to.\n\nIf the array to sort contains `-Inf`, `NULL`, `NaN`, or `Inf` they will be sorted in the following order:\n\n1. `-Inf`\n2. `Inf`\n3. `NaN`\n4. `NULL`\n\n`arraySort` is a [higher-order function](/sql-reference/functions/overview#higher-order-functions).\n",
      "arguments": "- `f(y1[, y2 ... yN])` — The lambda function to apply to elements of array `x`.\n- `arr` — An array to be sorted. [`Array(T)`](/sql-reference/data-types/array)\n- `arr1, ..., yN` — Optional. N additional arrays, in the case when `f` accepts multiple arguments.\n",
      "returnedValue": "Returns the array `arr` sorted in ascending order if no lambda function is provided, otherwise\nit returns an array sorted according to the logic of the provided lambda function. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Example 1**\n\n```sql title=Query\nSELECT arraySort([1, 3, 3, 0]);\n```\n\n```response title=Response\n[0,1,3,3]\n```\n\n**Example 2**\n\n```sql title=Query\nSELECT arraySort(['hello', 'world', '!']);\n```\n\n```response title=Response\n['!','hello','world']\n```\n\n**Example 3**\n\n```sql title=Query\nSELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);\n```\n\n```response title=Response\n[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arraySplit",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])",
      "description": "Split a source array into multiple arrays. When `func(x [, y1, ..., yN])` returns something other than zero, the array will be split to the left of the element. The array will not be split before the first element.",
      "arguments": "- `func(x[, y1, ..., yN])` — A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`).[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to split [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of arrays. [`Array(Array(T))`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res\n```\n\n```response title=Response\n[[1, 2, 3], [4, 5]]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayStringConcat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayStringConcat(arr[, delimiter])",
      "description": "Concatenates the elements of an array of strings into a single string, using the specified delimiter between elements.",
      "arguments": "- `arr` — The source array of strings. [`Array(String)`](/sql-reference/data-types/array).\n- `delimiter` — Optional. The delimiter to insert between elements. [`String`](/sql-reference/data-types/string). Defaults to empty string if not specified.\n",
      "returnedValue": "A string consisting of the array elements joined by the delimiter. String.",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT arrayStringConcat(['a', 'b', 'c']);\n```\n\n```response title=Response\n'abc'\n```\n\n**With delimiter**\n\n```sql title=Query\nSELECT arrayStringConcat(['a', 'b', 'c'], ',');\n```\n\n```response title=Response\na, b, c\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arraySum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])",
      "description": "\nReturns the sum of elements in the source array.\n\nIf a lambda function `func` is specified, returns the sum of elements of the lambda results.\n    ",
      "arguments": "- `func(x[, y1, ..., yN])` — Optional. A lambda function which operates on elements of the source array (`x`) and condition arrays (`y`). [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).\n- `source_arr` — The source array to process. [`Array(T)`](/sql-reference/data-types/array).\n- `[, cond1_arr, ... , condN_arr]` — Optional. N condition arrays providing additional arguments to the lambda function. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns the sum of elements in the source array, or the sum of elements of the lambda results if provided.",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT arraySum([1, 2, 3, 4]);\n```\n\n```response title=Response\n10\n```\n\n**Usage with lambda function**\n\n```sql title=Query\nSELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);\n```\n\n```response title=Response\n8\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arraySymmetricDifference",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arraySymmetricDifference(arr1, arr2, ... , arrN)",
      "description": "Takes multiple arrays and returns an array with elements that are not present in all source arrays. The result contains only unique values.\n\n:::note\nThe symmetric difference of _more than two sets_ is [mathematically defined](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference)\nas the set of all input elements which occur in an odd number of input sets.\nIn contrast, function `arraySymmetricDifference` simply returns the set of input elements which do not occur in all input sets.\n:::\n",
      "arguments": "- `arrN` — N arrays from which to make the new array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array of distinct elements not present in all source arrays. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT\narraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,\narraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;\n```\n\n```response title=Response\n┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐\n│ []                         │ [3]                            │\n└────────────────────────────┴────────────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayUnion",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayUnion(arr1, arr2, ..., arrN)",
      "description": "Takes multiple arrays and returns an array which contains all elements that are present in one of the source arrays.The result contains only unique values.",
      "arguments": "- `arrN` — N arrays from which to make the new array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array with distinct elements from the source arrays. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT\narrayUnion([-2, 1], [10, 1], [-2], []) as num_example,\narrayUnion(['hi'], [], ['hello', 'hi']) as str_example,\narrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example\n```\n\n```response title=Response\n┌─num_example─┬─str_example────┬─null_example─┐\n│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │\n└─────────────┴────────────────┴──────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayUniq",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayUniq(arr1[, arr2, ..., arrN])",
      "description": "\nFor a single argument passed, counts the number of different elements in the array.\nFor multiple arguments passed, it counts the number of different **tuples** made of elements at matching positions across multiple arrays.\n\nFor example `SELECT arrayUniq([1,2], [3,4], [5,6])` will form the following tuples:\n* Position 1: (1,3,5)\n* Position 2: (2,4,6)\n\nIt will then count the number of unique tuples. In this case `2`.\n\nAll arrays passed must have the same length.\n\n:::tip\nIf you want to get a list of unique items in an array, you can use `arrayReduce('groupUniqArray', arr)`.\n:::\n",
      "arguments": "- `arr1` — Array for which to count the number of unique elements. [`Array(T)`](/sql-reference/data-types/array).\n- `[, arr2, ..., arrN] (optional)` — Optional. Additional arrays used to count the number of unique tuples of elements at corresponding positions in multiple arrays. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "For a single argument returns the number of unique\nelements. For multiple arguments returns the number of unique tuples made from\nelements at corresponding positions across the arrays.\n[`UInt32`](/sql-reference/data-types/int-uint).",
      "examples": "**Single argument**\n\n```sql title=Query\nSELECT arrayUniq([1, 1, 2, 2])\n```\n\n```response title=Response\n2\n```\n\n**Multiple argument**\n\n```sql title=Query\nSELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])\n```\n\n```response title=Response\n3\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayWithConstant",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayWithConstant(N, x)",
      "description": "\nCreates an array of length `length` filled with the constant `x`.\n    ",
      "arguments": "- `length` — Number of elements in the array. [`(U)Int*`](/sql-reference/data-types/int-uint).\n- `x` — The value of the `N` elements in the array, of any type.\n",
      "returnedValue": "Returns an Array with `N` elements of value `x`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayWithConstant(3, 1)\n```\n\n```response title=Response\n[1,1,1]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayZip",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayZip(arr1, arr2, ... , arrN)",
      "description": "Combines multiple arrays into a single array. The resulting array contains the corresponding elements of the source arrays grouped into tuples in the listed order of arguments.",
      "arguments": "- `arr1, arr2, ... , arrN` — N arrays to combine into a single array. [`Array(T)`](/sql-reference/data-types/array)\n",
      "returnedValue": "Returns an array with elements from the source arrays grouped in tuples. Data types in the tuple are the same as types of the input arrays and in the same order as arrays are passed. [`Array(T)`](/sql-reference/data-types/array)([`Tuple`](/sql-reference/data-types/tuple)).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);\n```\n\n```response title=Response\n[('a', 5), ('b', 2), ('c', 1)]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "arrayZipUnaligned",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "arrayZipUnaligned(arr1, arr2, ..., arrN)",
      "description": "Combines multiple arrays into a single array, allowing for unaligned arrays (arrays of differing lengths). The resulting array contains the corresponding elements of the source arrays grouped into tuples in the listed order of arguments.",
      "arguments": "- `arr1, arr2, ..., arrN` — N arrays to combine into a single array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns an array with elements from the source arrays grouped in tuples. Data types in the tuple are the same as types of the input arrays and in the same order as arrays are passed. [`Array(T)`](/sql-reference/data-types/array)([`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT arrayZipUnaligned(['a'], [1, 2, 3]);\n```\n\n```response title=Response\n[('a', 1),(NULL, 2),(NULL, 3)]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "array_agg",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "groupArray",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "array_concat_agg",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "groupArrayArray",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ascii",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the ASCII code point of the first character of str.  The result type is Int32.\n\nIf s is empty, the result is 0. If the first character is not an ASCII character or not part of the Latin-1 Supplement range of UTF-16, the result is undefined)\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**ascii**\n\n```sql title=Query\nSELECT ascii('234')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "String"
    },
    {
      "name": "asin",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nCalculates the arcsine of the argument.\n\nTakes arbitrary numeric type, which includes floating point and integer numbers, as well as big integers and decimals and returns Float64.\n\nFor arguments in range [-1, 1] it returns the value in range of [-pi() / 2, pi() / 2].\n\nIt represents an inverse function to function 'sin' on this range:\n[example:inverse]\n\nIt always returns Float64, even if the argument has Float32 type:\n[example:float32]\n\nFor arguments outside of this range, it returns nan:\n[example:nan]\n\nEvery self-respectful data scientist knows how to apply arcsine to improve ads click-through rate with ClickHouse.\nFor more details, see [https://en.wikipedia.org/wiki/Inverse_trigonometric_functions].\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**inverse**\n\n```sql title=Query\nSELECT asin(1.0) = pi() / 2, sin(asin(1)), asin(sin(1))\n```\n\n```response title=Response\n\n```\n\n**float32**\n\n```sql title=Query\nSELECT toTypeName(asin(1.0::Float32))\n```\n\n```response title=Response\n\n```\n\n**nan**\n\n```sql title=Query\nSELECT asin(1.1), asin(-2), asin(inf), asin(nan)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Mathematical"
    },
    {
      "name": "asinh",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "assumeNotNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "atan",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "atan2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "atanh",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avg",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bar",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "base32Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nDecode a [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoded string. The input string must be a valid Base32 encoded string, otherwise an exception will be thrown.",
      "arguments": "- `arg` — A Base32 (rfc4648) encoded string\n",
      "returnedValue": "",
      "examples": "**simple_decoding1**\n\n```sql title=Query\nSELECT base32Decode('ME======')\n```\n\n```response title=Response\na\n```\n\n**simple_decoding2**\n\n```sql title=Query\nSELECT base32Decode('JBSWY3DP')\n```\n\n```response title=Response\nHello\n```\n\n**empty_string**\n\n```sql title=Query\nSELECT base32Decode('')\n```\n\n```response title=Response\n\n```\n\n**non_ascii**\n\n```sql title=Query\nSELECT hex(base32Decode('4W2HIXV4'))\n```\n\n```response title=Response\nE5B4745EBC\n```\n\n",
      "categories": "String"
    },
    {
      "name": "base32Encode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nEncode a string with [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoding.",
      "arguments": "- `arg` — A string to be encoded\n",
      "returnedValue": "",
      "examples": "**simple_encoding1**\n\n```sql title=Query\nSELECT base32Encode('a')\n```\n\n```response title=Response\nME======\n```\n\n**simple_encoding2**\n\n```sql title=Query\nSELECT base32Encode('Hello')\n```\n\n```response title=Response\nJBSWY3DP\n```\n\n",
      "categories": "String"
    },
    {
      "name": "base58Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "base58Encode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "base64Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "base64Decode(encoded)",
      "description": "Accepts a String and decodes it from base64, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-4). Throws an exception in case of an error. Alias: FROM_BASE64.",
      "arguments": "- `encoded` — String column or constant. If the string is not a valid Base64-encoded value, an exception is thrown.\n",
      "returnedValue": "A string containing the decoded value of the argument.",
      "examples": "**Example**\n\n```sql title=Query\nSELECT base64Decode('Y2xpY2tob3VzZQ==')\n```\n\n```response title=Response\nclickhouse\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "base64Encode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "base64Encode(plaintext)",
      "description": "Encodes a String as base64, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-4). Alias: TO_BASE64.",
      "arguments": "- `plaintext` — String column or constant.\n",
      "returnedValue": "A string containing the encoded value of the argument.",
      "examples": "**Example**\n\n```sql title=Query\nSELECT base64Encode('clickhouse')\n```\n\n```response title=Response\nY2xpY2tob3VzZQ==\n```\n\n",
      "categories": "String"
    },
    {
      "name": "base64URLDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "base64URLDecode(encodedURL)",
      "description": "Accepts a base64-encoded URL and decodes it from base64 with URL-specific modifications, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-5).",
      "arguments": "- `encodedURL` — String column or constant. If the string is not a valid Base64-encoded value, an exception is thrown.\n",
      "returnedValue": "A string containing the decoded value of the argument.",
      "examples": "**Example**\n\n```sql title=Query\nSELECT base64URLDecode('aHR0cDovL2NsaWNraG91c2UuY29t')\n```\n\n```response title=Response\nhttps://clickhouse.com\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "base64URLEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "base64URLEncode(url)",
      "description": "Encodes an URL (String or FixedString) as base64 with URL-specific modifications, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-5).",
      "arguments": "- `url` — String column or constant.\n",
      "returnedValue": "A string containing the encoded value of the argument.",
      "examples": "**Example**\n\n```sql title=Query\nSELECT base64URLEncode('https://clickhouse.com')\n```\n\n```response title=Response\naHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "basename",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bech32Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bech32Encode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bin",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bitAnd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitAnd(a, b)",
      "description": "Performs bitwise AND operation between two values.",
      "arguments": "- `a` — First value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `b` — Second value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the result of bitwise operation `a AND b`",
      "examples": "**Usage example**\n\n```sql title=Query\nCREATE TABLE bits\n(\n    `a` UInt8,\n    `b` UInt8\n)\nENGINE = Memory;\n\nINSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);\n\nSELECT\n    a,\n    b,\n    bitAnd(a, b)\nFROM bits\n```\n\n```response title=Response\n┌─a─┬─b─┬─bitAnd(a, b)─┐\n│ 0 │ 0 │            0 │\n│ 0 │ 1 │            0 │\n│ 1 │ 0 │            0 │\n│ 1 │ 1 │            1 │\n└───┴───┴──────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitCount",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitCount(x)",
      "description": "Calculates the number of bits set to one in the binary representation of a number.",
      "arguments": "- `x` — An integer or float value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the number of bits set to one in `x`. [`UInt8`](../data-types/int-uint.md).\n\n:::note\nThe function does not convert the input value to a larger type ([sign extension](https://en.wikipedia.org/wiki/Sign_extension)).\nFor example: `bitCount(toUInt8(-1)) = 8`.\n:::",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bin(333), bitCount(333);\n```\n\n```response title=Response\n┌─bin(333)─────────┬─bitCount(333)─┐\n│ 0000000101001101 │             5 │\n└──────────────────┴───────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitHammingDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitHammingDistance(x, y)",
      "description": "\nReturns the [Hamming Distance](https://en.wikipedia.org/wiki/Hamming_distance) between the bit representations of two numbers.\nCan be used with [`SimHash`](../../sql-reference/functions/hash-functions.md#ngramsimhash) functions for detection of semi-duplicate strings.\nThe smaller the distance, the more similar the strings are.\n",
      "arguments": "- `x` — First number for Hamming distance calculation. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `y` — Second number for Hamming distance calculation. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the hamming distance between `x` and `y`. [`UInt8`](../data-types/int-uint.md).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitHammingDistance(111, 121);\n```\n\n```response title=Response\n┌─bitHammingDistance(111, 121)─┐\n│                            3 │\n└──────────────────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitNot",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitNot(a)",
      "description": "Performs the bitwise NOT operation.",
      "arguments": "- `a` — Value for which to apply bitwise NOT operation. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float)/[String](/sql-reference/data-types/string).\n",
      "returnedValue": "Returns the result of `~a` i.e `a` with bits flipped.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT\n    CAST('5', 'UInt8') AS original,\n    bin(original) AS original_binary,\n    bitNot(original) AS result,\n    bin(bitNot(original)) AS result_binary;\n```\n\n```response title=Response\n┌─original─┬─original_binary─┬─result─┬─result_binary─┐\n│        5 │ 00000101        │    250 │ 11111010      │\n└──────────┴─────────────────┴────────┴───────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitOr",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitOr(a, b)",
      "description": "Performs bitwise OR operation between two values.",
      "arguments": "- `a` — First value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `b` — Second value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the result of bitwise operation `a OR b`",
      "examples": "**Usage example**\n\n```sql title=Query\nCREATE TABLE bits\n(\n    `a` UInt8,\n    `b` UInt8\n)\nENGINE = Memory;\n\nINSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);\n\nSELECT\n    a,\n    b,\n    bitOr(a, b)\nFROM bits;\n```\n\n```response title=Response\n┌─a─┬─b─┬─bitOr(a, b)─┐\n│ 0 │ 0 │           0 │\n│ 0 │ 1 │           1 │\n│ 1 │ 0 │           1 │\n│ 1 │ 1 │           1 │\n└───┴───┴─────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitPositionsToArray",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bitRotateLeft",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitRotateLeft(a, N)",
      "description": "Rotate bits left by a certain number of positions. Bits that fall off wrap around to the right.",
      "arguments": "- `a` — A value to rotate. [`(U)Int8/16/32/64`](../data-types/int-uint.md).\n- `N` — The number of positions to rotate left. [`UInt8/16/32/64`](../data-types/int-uint.md).\n",
      "returnedValue": "Returns the rotated value with type equal to that of `a`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 99 AS a, bin(a), bitRotateLeft(a, 2) AS a_rotated, bin(a_rotated);\n```\n\n```response title=Response\n┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐\n│ 99 │ 01100011 │       141 │ 10001101       │\n└────┴──────────┴───────────┴────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitRotateRight",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitRotateRight(a, N)",
      "description": "Rotate bits right by a certain number of positions. Bits that fall off wrap around to the left.",
      "arguments": "- `a` — A value to rotate. [`(U)Int8/16/32/64`](../data-types/int-uint.md).\n- `N` — The number of positions to rotate right. [`UInt8/16/32/64`](../data-types/int-uint.md).\n",
      "returnedValue": "Returns the rotated value with type equal to that of `a`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 99 AS a, bin(a), bitRotateRight(a, 2) AS a_rotated, bin(a_rotated);\n```\n\n```response title=Response\n┌──a─┬─bin(a)───┬─a_rotated─┬─bin(a_rotated)─┐\n│ 99 │ 01100011 │       216 │ 11011000       │\n└────┴──────────┴───────────┴────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitShiftLeft",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitShiftLeft(a, N)",
      "description": "\nShifts the binary representation of a value to the left by a specified number of bit positions.\n\nA `FixedString` or a `String` is treated as a single multibyte value.\n\nBits of a `FixedString` value are lost as they are shifted out.\nOn the contrary, a `String` value is extended with additional bytes, so no bits are lost.\n",
      "arguments": "- `a` — A value to shift. [`(U)Int*`](../data-types/int-uint.md)/[`String`](../data-types/string.md)/[`FixedString`](../data-types/fixedstring.md).\n- `N` — The number of positions to shift. [`UInt8/16/32/64`](../data-types/int-uint.md).\n",
      "returnedValue": "Returns the shifted value with type equal to that of `a`.",
      "examples": "**Usage example with binary encoding**\n\n```sql title=Query\nSELECT 99 AS a, bin(a), bitShiftLeft(a, 2) AS a_shifted, bin(a_shifted);\n```\n\n```response title=Response\n┌──a─┬─bin(99)──┬─a_shifted─┬─bin(bitShiftLeft(99, 2))─┐\n│ 99 │ 01100011 │       140 │ 10001100                 │\n└────┴──────────┴───────────┴──────────────────────────┘\n```\n\n**Usage example with hexadecimal encoding**\n\n```sql title=Query\nSELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);\n```\n\n```response title=Response\n┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftLeft('abc', 4))─┐\n│ abc │ 616263     │ &0        │ 06162630                    │\n└─────┴────────────┴───────────┴─────────────────────────────┘\n```\n\n**Usage example with Fixed String encoding**\n\n```sql title=Query\nSELECT toFixedString('abc', 3) AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);\n```\n\n```response title=Response\n┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftLeft(toFixedString('abc', 3), 4))─┐\n│ abc │ 616263                       │ &0        │ 162630                                        │\n└─────┴──────────────────────────────┴───────────┴───────────────────────────────────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitShiftRight",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitShiftRight(a, N)",
      "description": "\nShifts the binary representation of a value to the right by a specified number of bit positions.\n\nA `FixedString` or a `String` is treated as a single multibyte value.\n\nBits of a `FixedString` value are lost as they are shifted out.\nOn the contrary, a `String` value is extended with additional bytes, so no bits are lost.\n",
      "arguments": "- `a` — A value to shift. [`(U)Int*`](../data-types/int-uint.md)/[`String`](../data-types/string.md)/[`FixedString`](../data-types/fixedstring.md).\n- `N` — The number of positions to shift. [`UInt8/16/32/64`](../data-types/int-uint.md).\n",
      "returnedValue": "Returns the shifted value with type equal to that of `a`.",
      "examples": "**Usage example with binary encoding**\n\n```sql title=Query\nSELECT 101 AS a, bin(a), bitShiftRight(a, 2) AS a_shifted, bin(a_shifted);\n```\n\n```response title=Response\n┌───a─┬─bin(101)─┬─a_shifted─┬─bin(bitShiftRight(101, 2))─┐\n│ 101 │ 01100101 │        25 │ 00011001                   │\n└─────┴──────────┴───────────┴────────────────────────────┘\n```\n\n**Usage example with hexadecimal encoding**\n\n```sql title=Query\nSELECT 'abc' AS a, hex(a), bitShiftLeft(a, 4) AS a_shifted, hex(a_shifted);\n```\n\n```response title=Response\n┌─a───┬─hex('abc')─┬─a_shifted─┬─hex(bitShiftRight('abc', 12))─┐\n│ abc │ 616263     │           │ 0616                          │\n└─────┴────────────┴───────────┴───────────────────────────────┘\n```\n\n**Usage example with Fixed String encoding**\n\n```sql title=Query\nSELECT toFixedString('abc', 3) AS a, hex(a), bitShiftRight(a, 12) AS a_shifted, hex(a_shifted);\n```\n\n```response title=Response\n┌─a───┬─hex(toFixedString('abc', 3))─┬─a_shifted─┬─hex(bitShiftRight(toFixedString('abc', 3), 12))─┐\n│ abc │ 616263                       │           │ 000616                                          │\n└─────┴──────────────────────────────┴───────────┴─────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitSlice",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitSlice(s, offset[, length])",
      "description": "Returns a substring starting with the bit from the 'offset' index that is 'length' bits long.",
      "arguments": "- `s` — The String or Fixed String to slice. [`String`](../data-types/string.md)/[`FixedString(N)`](../data-types/fixedstring.md).\n- `offset` — \nThe starting bit position (1-based indexing). [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n  - Positive values: count from the beginning of the string.\n  - Negative values: count from the end of the string.\n        \n- `length` — \nOptional. The number of bits to extract. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n  - Positive values: extract `length` bits.\n  - Negative values: extract from the offset to `(string_length - |length|)`.\n  - Omitted: extract from offset to end of string.\n  - If length is not a multiple of 8, the result is padded with zeros on the right.\n    \n",
      "returnedValue": "Returns a string containing the extracted bits, represented as a binary sequence. The result is always padded to byte boundaries (multiples of 8 bits). [`String`](../data-types/string.md)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bin('Hello'), bin(bitSlice('Hello', 1, 8));\nSELECT bin('Hello'), bin(bitSlice('Hello', 1, 2));\nSELECT bin('Hello'), bin(bitSlice('Hello', 1, 9));\nSELECT bin('Hello'), bin(bitSlice('Hello', -4, 8));\n```\n\n```response title=Response\n┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 8))─┐\n│ 0100100001100101011011000110110001101111 │ 01001000                     │\n└──────────────────────────────────────────┴──────────────────────────────┘\n┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 2))─┐\n│ 0100100001100101011011000110110001101111 │ 01000000                     │\n└──────────────────────────────────────────┴──────────────────────────────┘\n┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', 1, 9))─┐\n│ 0100100001100101011011000110110001101111 │ 0100100000000000             │\n└──────────────────────────────────────────┴──────────────────────────────┘\n┌─bin('Hello')─────────────────────────────┬─bin(bitSlice('Hello', -4, 8))─┐\n│ 0100100001100101011011000110110001101111 │ 11110000                      │\n└──────────────────────────────────────────┴───────────────────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitTest",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitTest(a, i)",
      "description": "Takes any number and converts it into [binary form](https://en.wikipedia.org/wiki/Binary_number), then returns the value of the bit at a specified position. Counting is done right-to-left, starting at 0.",
      "arguments": "- `a` — Number to convert. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `i` — Position of the bit to return. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the value of the bit at position `i` in the binary representation of `a`. [`UInt8`](../data-types/int-uint.md).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bin(2), bitTest(2, 1);\n```\n\n```response title=Response\n┌─bin(2)───┬─bitTest(2, 1)─┐\n│ 00000010 │             1 │\n└──────────┴───────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitTestAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitTestAll(a, index1[, index2, ... , indexN])",
      "description": "\nReturns result of the [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction) (AND operator) of all bits at the given positions.\nCounts right-to-left, starting at 0.\n\nThe logical AND between two bits is true if and only if both input bits are true.\n    ",
      "arguments": "- `a` — An integer value. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n- `index1[, index2, ... , indexN]` — One or multiple positions of bits. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "Returns the result of the logical conjunction. [`UInt8`](../data-types/int-uint.md).",
      "examples": "**Usage example 1**\n\n```sql title=Query\nSELECT bitTestAll(43, 0, 1, 3, 5);\n```\n\n```response title=Response\n┌─bin(43)──┬─bitTestAll(43, 0, 1, 3, 5)─┐\n│ 00101011 │                          1 │\n└──────────┴────────────────────────────┘\n```\n\n**Usage example 2**\n\n```sql title=Query\nSELECT bitTestAll(43, 0, 1, 3, 5, 2);\n```\n\n```response title=Response\n┌─bin(43)──┬─bitTestAll(4⋯1, 3, 5, 2)─┐\n│ 00101011 │                        0 │\n└──────────┴──────────────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitTestAny",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitTestAny(a, index1[, index2, ... , indexN])",
      "description": "\nReturns result of the [logical disjunction](https://en.wikipedia.org/wiki/Logical_disjunction) (OR operator) of all bits at the given positions in a number.\nCounts right-to-left, starting at 0.\n\nThe logical OR between two bits is true if at least one of the input bits is true.\n    ",
      "arguments": "- `a` — An integer value. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n- `index1[, index2, ... , indexN]` — One or multiple positions of bits. [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "Returns the result of the logical disjunction. [`UInt8`](../data-types/int-uint.md).",
      "examples": "**Usage example 1**\n\n```sql title=Query\nSELECT bitTestAny(43, 0, 2);\n```\n\n```response title=Response\n┌─bin(43)──┬─bitTestAny(43, 0, 2)─┐\n│ 00101011 │                    1 │\n└──────────┴──────────────────────┘\n```\n\n**Usage example 2**\n\n```sql title=Query\nSELECT bitTestAny(43, 4, 2);\n```\n\n```response title=Response\n┌─bin(43)──┬─bitTestAny(43, 4, 2)─┐\n│ 00101011 │                    0 │\n└──────────┴──────────────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitXor",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitXor(a, b)",
      "description": "Performs bitwise exclusive or (XOR) operation between two values.",
      "arguments": "- `a` — First value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `b` — Second value. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the result of bitwise operation `a XOR b`",
      "examples": "**Usage example**\n\n```sql title=Query\nCREATE TABLE bits\n(\n    `a` UInt8,\n    `b` UInt8\n)\nENGINE = Memory;\n\nINSERT INTO bits VALUES (0, 0), (0, 1), (1, 0), (1, 1);\n\nSELECT\n    a,\n    b,\n    bitXor(a, b)\nFROM bits;\n```\n\n```response title=Response\n┌─a─┬─b─┬─bitXor(a, b)─┐\n│ 0 │ 0 │            0 │\n│ 0 │ 1 │            1 │\n│ 1 │ 0 │            1 │\n│ 1 │ 1 │            0 │\n└───┴───┴──────────────┘\n```\n\n",
      "categories": "Bit"
    },
    {
      "name": "bitmapAnd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapAnd(bitmap1, bitmap2)",
      "description": "Computes the logical conjunction (AND) of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns a bitmap containing bits present in both input bitmaps. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapAnd(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│ [3] │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapAndCardinality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapAndCardinality(bitmap1, bitmap2)",
      "description": "Returns the cardinality of the logical conjunction (AND) of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the number of set bits in the intersection of the two bitmaps. [`UInt64`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapAndCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   1 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapAndnot",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapAndnot(bitmap1, bitmap2)",
      "description": "Computes the logical conjunction of two bitmaps and negates the result (AND-NOT).",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns a bitmap containing set bits present in the first bitmap but not in the second. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapAndnot(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;\n```\n\n```response title=Response\n┌─res────┐\n│ [1, 2] │\n└────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapAndnotCardinality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapAndnotCardinality(bitmap1, bitmap2)",
      "description": "Returns the cardinality of the AND-NOT operation of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the number of set bits in the result of `bitmap1 AND-NOT bitmap2`. [`UInt64`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapAndnotCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   2 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapBuild",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapBuild(array)",
      "description": "Builds a bitmap from an unsigned integer array. It is the opposite of function [`bitmapToArray`](/sql-reference/functions/bitmap-functions#bitmapToArray).",
      "arguments": "- `array` — Unsigned integer array. [`Array(UInt*)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns a bitmap from the provided array. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapBuild([1, 2, 3, 4, 5]) AS res, toTypeName(res);\n```\n\n```response title=Response\n┌─res─┬─toTypeName(bitmapBuild([1, 2, 3, 4, 5]))─────┐\n│     │ AggregateFunction(groupBitmap, UInt8)        │\n└─────┴──────────────────────────────────────────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapCardinality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapCardinality(bitmap)",
      "description": "Returns the number of bits set (the cardinality) in the bitmap.",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the number of bits set in the bitmap. [`UInt64`](/sql-reference/data-types/int-uint)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapCardinality(bitmapBuild([1, 3, 3, 5, 7, 7])) AS res\n```\n\n```response title=Response\n┌─res─┐\n│   4 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapContains",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapContains(bitmap, value)",
      "description": "Checks if the bitmap contains a specific element.",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `value` — Element to check for. [(U)Int8/16/32/64](/sql-reference/data-types/int-uint/)\n",
      "returnedValue": "Returns `1` if the bitmap contains the specified value, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapContains(bitmapBuild([1, 2, 3]), 2) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│  1  │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapHasAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapHasAll(bitmap1, bitmap2)",
      "description": "Checks if the first bitmap contains all set bits of the second bitmap.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns `1` if all set bits of the second bitmap are present in the first bitmap, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapHasAll(bitmapBuild([1, 2, 3]), bitmapBuild([2, 3])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│  1  │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapHasAny",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapHasAny(bitmap1, bitmap2)",
      "description": "Checks if the first bitmap contains any set bits of the second bitmap.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns `1` if any bits of the second bitmap are present in the first bitmap, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapHasAny(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│  1  │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapMax",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapMax(bitmap)",
      "description": "Returns the position of the greatest bit set in a bitmap, or `0` if the bitmap is empty.",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the position of the greatest bit set in the bitmap, otherwise `0`. [`UInt64`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapMax(bitmapBuild([1, 2, 3, 4, 5])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   5 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapMin",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapMin(bitmap)",
      "description": "Returns the position of the smallest bit set in a bitmap. If all bits are unset, or `UINT32_MAX` (`UINT64_MAX` if the bitmap contains more than `2^64` bits).",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the position of the smallest bit set in the bitmap, or `UINT32_MAX`/`UINT64_MAX`. [`UInt64`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapMin(bitmapBuild([3, 5, 2, 6])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   2 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapOr",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapOr(bitmap1, bitmap2)",
      "description": "Computes the logical disjunction (OR) of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns a bitmap containing set bits present in either input bitmap. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapOr(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;\n```\n\n```response title=Response\n┌─res─────────────┐\n│ [1, 2, 3, 4, 5] │\n└─────────────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapOrCardinality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapOrCardinality(bitmap1, bitmap2)",
      "description": "Returns the cardinality of the logical disjunction (OR) of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the number of set bits in the union of the two bitmaps. [`UInt64`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapOrCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   5 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapSubsetInRange",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapSubsetInRange(bitmap, start, end)",
      "description": "Returns a subset of the bitmap, containing only the set bits in the specified range [start, end). Uses 1-based indexing.",
      "arguments": "- `bitmap` — Bitmap to extract the subset from. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `start` — Start of the range (inclusive). [`UInt*`](/sql-reference/data-types/int-uint)\n- `end` — End of the range (exclusive). [`UInt*`](/sql-reference/data-types/int-uint)\n",
      "returnedValue": "Returns a bitmap containing only the set bits in the specified range. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild([1, 2, 3, 4, 5]), 2, 5)) AS res;\n```\n\n```response title=Response\n┌─res───────┐\n│ [2, 3, 4] │\n└───────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapSubsetLimit",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapSubsetLimit(bitmap, range_start, cardinality_limit)",
      "description": "Returns a subset of a bitmap from position `range_start` with at most `cardinality_limit` set bits. Uses 1-based indexing.",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `range_start` — Start of the range (inclusive). [`UInt32`](/sql-reference/data-types/int-uint)\n- `cardinality_limit` — Maximum cardinality of the subset. [`UInt32`](/sql-reference/data-types/int-uint)\n",
      "returnedValue": "Returns a bitmap containing at most `cardinality_limit` set bits, starting from `range_start`. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild([1, 5, 3, 2, 8]), 3, 2)) AS res;\n```\n\n```response title=Response\n┌─res────┐\n│ [5, 3] │\n└────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapToArray",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapToArray(bitmap)",
      "description": "Converts a bitmap to an array of unsigned integers. It is the opposite of function [`bitmapBuild`](/sql-reference/functions/bitmap-functions#bitmapbuild).",
      "arguments": "- `bitmap` — Bitmap to convert. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns an array of unsigned integers contained in the bitmap. [`Array(UInt*)`](/sql-reference/data-types/array)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapBuild([1, 2, 3, 4, 5])) AS res;\n```\n\n```response title=Response\n┌─res─────────────┐\n│ [1, 2, 3, 4, 5] │\n└─────────────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapTransform",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapTransform(bitmap, from_array, to_array)",
      "description": "\nChanges up to N bits in a bitmap by swapping specific bit values in `from_array` with corresponding ones in `to_array`.\n    ",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `from_array` — Array of original set bits to be replaced. [`Array(T)`](/sql-reference/data-types/array).\n- `to_array` — Array of new set bits to replace with. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns a bitmap with elements transformed according to the given mapping. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapTransform(bitmapBuild([1, 2, 3, 4, 5]), [2, 4], [20, 40])) AS res;\n```\n\n```response title=Response\n┌─res───────────────┐\n│ [1, 3, 5, 20, 40] │\n└───────────────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapXor",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapXor(bitmap1, bitmap2)",
      "description": "Computes the symmetric difference (XOR) of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns a bitmap containing set bits present in either input bitmap, but not in both. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(bitmapXor(bitmapBuild([1, 2, 3]), bitmapBuild([3, 4, 5]))) AS res;\n```\n\n```response title=Response\n┌─res──────────┐\n│ [1, 2, 4, 5] │\n└──────────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmapXorCardinality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "bitmapXorCardinality(bitmap1, bitmap2)",
      "description": "Returns the cardinality of the XOR (symmetric difference) of two bitmaps.",
      "arguments": "- `bitmap1` — First bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `bitmap2` — Second bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n",
      "returnedValue": "Returns the number of set bits in the symmetric difference of the two bitmaps. [`UInt64`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapXorCardinality(bitmapBuild([1,2,3]), bitmapBuild([3,4,5])) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   4 │\n└─────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "bitmaskToArray",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "bitmaskToList",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "blockNumber",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "blockSerializedSize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "blockSize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatio",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "buildId",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "byteHammingDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates Hamming distance between two byte-strings.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "byteSize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "byteSlice",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "substring",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "byteSwap",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "byteSwap(x)",
      "description": "\nReverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness).\n\nThe below example can be worked out in the following manner:\n\n1. Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)\n2. Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7\n3. Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7 -> 3455829959\nOne use case of this function is reversing IPv4s:\n\n```result\n┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐\n│ 199.199.251.205                                       │\n└───────────────────────────────────────────────────────┘\n```\n    ",
      "arguments": "- `x` — An integer value.\n",
      "returnedValue": "x with bytes reversed",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT byteSwap(3351772109)\n```\n\n```response title=Response\n3455829959\n```\n\n**8-bit**\n\n```sql title=Query\nSELECT byteSwap(54)\n```\n\n```response title=Response\n54\n```\n\n**16-bit**\n\n```sql title=Query\nSELECT byteSwap(4135)\n```\n\n```response title=Response\n10000\n```\n\n**32-bit**\n\n```sql title=Query\nSELECT byteSwap(3351772109)\n```\n\n```response title=Response\n3455829959\n```\n\n**64-bit**\n\n```sql title=Query\nSELECT byteSwap(123294967295)\n```\n\n```response title=Response\n18439412204227788800\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "caseWithExpr",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "caseWithExpression",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "caseWithExpression",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "caseWithoutExpr",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "multiIf",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "caseWithoutExpression",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "multiIf",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "catboostEvaluate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValue",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cbrt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ceil",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ceiling",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "ceil",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "changeDay",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "changeDay(date_or_datetime, value);",
      "description": "Changes the day component of a date or date time.",
      "arguments": "- `date_or_datetime` — The value to change. Type: Date, Date32, DateTime, or DateTime64\n- `value` — The new value. Type: [U]Int*\n",
      "returnedValue": "The same type as date_or_datetime.",
      "examples": "",
      "categories": "Dates and Times"
    },
    {
      "name": "changeHour",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "changeHour(date_or_datetime, value);",
      "description": "Changes the hour component of a date or date time.",
      "arguments": "- `date_or_datetime` — The value to change. Type: Date, Date32, DateTime, or DateTime64\n- `value` — The new value. Type: [U]Int*\n",
      "returnedValue": "The same type as date_or_datetime. If the input is a Date, return DateTime. If the input is a Date32, return DateTime64.",
      "examples": "",
      "categories": "Dates and Times"
    },
    {
      "name": "changeMinute",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "changeMinute(date_or_datetime, value);",
      "description": "Changes the minute component of a date or date time.",
      "arguments": "- `date_or_datetime` — The value to change. Type: Date, Date32, DateTime, or DateTime64\n- `value` — The new value. Type: [U]Int*\n",
      "returnedValue": "The same type as date_or_datetime. If the input is a Date, return DateTime. If the input is a Date32, return DateTime64.",
      "examples": "",
      "categories": "Dates and Times"
    },
    {
      "name": "changeMonth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "changeMonth(date_or_datetime, value);",
      "description": "Changes the month component of a date or date time.",
      "arguments": "- `date_or_datetime` — The value to change. Type: Date, Date32, DateTime, or DateTime64\n- `value` — The new value. Type: [U]Int*\n",
      "returnedValue": "The same type as date_or_datetime.",
      "examples": "",
      "categories": "Dates and Times"
    },
    {
      "name": "changeSecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "changeSecond(date_or_datetime, value);",
      "description": "Changes the second component of a date or date time.",
      "arguments": "- `date_or_datetime` — The value to change. Type: Date, Date32, DateTime, or DateTime64\n- `value` — The new value. Type: [U]Int*\n",
      "returnedValue": "The same type as date_or_datetime. If the input is a Date, return DateTime. If the input is a Date32, return DateTime64.",
      "examples": "",
      "categories": "Dates and Times"
    },
    {
      "name": "changeYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "changeYear(date_or_datetime, value);",
      "description": "Changes the year component of a date or date time.",
      "arguments": "- `date_or_datetime` — The value to change. Type: Date, Date32, DateTime, or DateTime64\n- `value` — The new value. Type: [U]Int*\n",
      "returnedValue": "The same type as date_or_datetime.",
      "examples": "",
      "categories": "Dates and Times"
    },
    {
      "name": "char",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cityHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "clamp",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "clamp(value, min, max)",
      "description": "\nRestricts a value to be within the specified minimum and maximum bounds.\n\nIf the value is less than the minimum, returns the minimum. If the value is greater than the maximum, returns the maximum. Otherwise, returns the value itself.\n\nAll arguments must be of comparable types. The result type is the largest compatible type among all arguments.\n    ",
      "arguments": "- `value` — The value to clamp.\n- `min` — The minimum bound.\n- `max` — The maximum bound.\n",
      "returnedValue": "Returns the value, restricted to the [min, max] range.",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT clamp(5, 1, 10) AS result;\n```\n\n```response title=Response\n┌─result─┐\n│      5 │\n└────────┘\n```\n\n**Value below minimum**\n\n```sql title=Query\nSELECT clamp(-3, 0, 7) AS result;\n```\n\n```response title=Response\n┌─result─┐\n│      0 │\n└────────┘\n```\n\n**Value above maximum**\n\n```sql title=Query\nSELECT clamp(15, 0, 7) AS result;\n```\n\n```response title=Response\n┌─result─┐\n│      7 │\n└────────┘\n```\n\n",
      "categories": "Conditional"
    },
    {
      "name": "coalesce",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "compareSubstrings",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "compareSubstrings(str1, str2, str1_off, str2_off, num_bytes)",
      "description": "\n                This function compares parts of two strings directly, without the need to copy the parts of the string into new columns.\n                ",
      "arguments": "- `string1` — Required. The string to compare.\n- `string2` — Required. The string to compare.\n- `string1_offset` — Positive number. The starting position (zero-based index) in `str1` from which the comparison begins.\n- `string2_offset` — Positive number. The starting position (zero-based index) in `str2` from which the comparison begins.\n- `num_bytes` — The number of bytes to compare in both strings, starting from their respective offsets.\n",
      "returnedValue": "-1 if the substring from str1 is lexicographically smaller than the substring from str2, 0 if the substrings are equal, 1 if the substring from str1 is lexicographically greater than the substring from str2.",
      "examples": "**typical**\n\n```sql title=Query\nSELECT compareSubstrings('123', '123', 0, 0, 3)\n```\n\n```response title=Response\n┌─compareSubtr⋯', 0, 0, 3)─┐\n             1. │                        0 │\n                └──────────────────────────┘\n```\n\n",
      "categories": "String"
    },
    {
      "name": "concat",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "concatAssumeInjective",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "concatWithSeparator",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the concatenation strings separated by string separator. Syntax: concatWithSeparator(sep, expr1, expr2, expr3...)\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**concatWithSeparator**\n\n```sql title=Query\nSELECT concatWithSeparator('a', '1', '2', '3')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "String"
    },
    {
      "name": "concatWithSeparatorAssumeInjective",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nSame as concatWithSeparator, the difference is that you need to ensure that concatWithSeparator(sep, expr1, expr2, expr3...) → result is injective, it will be used for optimization of GROUP BY.\n\nThe function is named \"injective\" if it always returns different result for different values of arguments. In other words: different arguments never yield identical result.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**concatWithSeparatorAssumeInjective**\n\n```sql title=Query\nSELECT concatWithSeparatorAssumeInjective('a', '1', '2', '3')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "String"
    },
    {
      "name": "concat_ws",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "concatWithSeparator",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "connectionId",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "connection_id",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "connectionID",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingency",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "convertCharset",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corr",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrix",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cos",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cosh",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cosineDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "count",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countDigits",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countEqual",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "countEqual(arr, x)",
      "description": "\nReturns the number of elements in the array equal to `x`. Equivalent to `arrayCount(elem -> elem = x, arr)`.\n\n`NULL` elements are handled as separate values.\n",
      "arguments": "- `arr` — Array to search. [`Array(T)`](/sql-reference/data-types/array).\n- `x` — Value in the array to count. Any type.\n",
      "returnedValue": "Returns the number of elements in the array equal to `x`. [UInt64](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT countEqual([1, 2, NULL, NULL], NULL)\n```\n\n```response title=Response\n2\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "countMatches",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countMatchesCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countSubstrings",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countSubstringsCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countSubstringsCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPop",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrix",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSamp",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrix",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersV",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrected",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "curdate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "today",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "currentDatabase",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "currentProfiles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "currentQueryID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "currentQueryID()",
      "description": "\nReturns current Query id.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nSELECT currentQueryID();\n```\n\n```response title=Response\n┌─currentQueryID()─────────────────────┐\n│ 1280d0e8-1a08-4524-be6e-77975bb68e7d │\n└──────────────────────────────────────┘\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "currentRoles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "currentSchemas",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a single-element array with the name of the current database\n\nRequires a boolean parameter, but it is ignored actually. It is required just for compatibility with the implementation of this function in other DB engines.\n\n[example:common]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**common**\n\n```sql title=Query\nSELECT current_schemas(true);\n```\n\n```response title=Response\n['default']\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "currentUser",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "current_database",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentDatabase",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "current_date",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "today",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "current_query_id",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentQueryID",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "current_schemas",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentSchemas",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "current_timestamp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "now",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "current_user",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentUser",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cutFragment",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cutIPv6",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cutQueryString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cutQueryStringAndFragment",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cutToFirstSignificantSubdomain",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns the part of the domain that includes top-level subdomains up to the \"first significant subdomain\" (see documentation of the `firstSignificantSubdomain`).",
      "arguments": "",
      "returnedValue": "",
      "examples": "**cutToFirstSignificantSubdomain1**\n\n```sql title=Query\nSELECT cutToFirstSignificantSubdomain('https://news.clickhouse.com.tr/')\n```\n\n```response title=Response\n\n```\n\n**cutToFirstSignificantSubdomain2**\n\n```sql title=Query\nSELECT cutToFirstSignificantSubdomain('www.tr')\n```\n\n```response title=Response\n\n```\n\n**cutToFirstSignificantSubdomain3**\n\n```sql title=Query\nSELECT cutToFirstSignificantSubdomain('tr')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainCustom",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the part of the domain that includes top-level subdomains up to the first significant subdomain. Accepts custom TLD list name.\n\nCan be useful if you need fresh TLD list or you have custom.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**cutToFirstSignificantSubdomainCustom**\n\n```sql title=Query\nSELECT cutToFirstSignificantSubdomainCustom('bar.foo.there-is-no-such-domain', 'public_suffix_list');\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainCustomRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `cutToFirstSignificantSubdomainCustom` but follows stricter rules according to RFC 3986.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainCustomWithWWW",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the part of the domain that includes top-level subdomains up to the first significant subdomain without stripping `www`.\nAccepts custom TLD list name from config.\n\nCan be useful if you need fresh TLD list or you have custom.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**cutToFirstSignificantSubdomainCustomWithWWW**\n\n```sql title=Query\nSELECT cutToFirstSignificantSubdomainCustomWithWWW('www.foo', 'public_suffix_list')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainCustomWithWWWRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `cutToFirstSignificantSubdomainCustomWithWWW` but follows stricter rules according to RFC 3986.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `cutToFirstSignificantSubdomain` but follows stricter rules to be compatible with RFC 3986 and less performant.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainWithWWW",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns the part of the domain that includes top-level subdomains up to the \"first significant subdomain\", without stripping \"www\".",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "cutToFirstSignificantSubdomainWithWWWRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `cutToFirstSignificantSubdomainWithWWW` but follows stricter rules to be compatible with RFC 3986 and less performant.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "cutURLParameter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cutWWW",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "damerauLevenshteinDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the Damerau-Levenshtein distance two between two byte-string.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "dateDiff",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dateName",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dateTime64ToSnowflake",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dateTime64ToSnowflakeID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "dateTime64ToSnowflakeID(value[, epoch])",
      "description": "Converts a [DateTime64](../data-types/datetime64.md) value to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.",
      "arguments": "- `value` — Date with time. [DateTime64](../data-types/datetime.md).\n- `epoch` — Epoch of the Snowflake ID in milliseconds since 1970-01-01. Defaults to 0 (1970-01-01). For the Twitter/X epoch (2015-01-01), provide 1288834974657. Optional. [UInt*](../data-types/int-uint.md)\n",
      "returnedValue": "Input value converted to [UInt64](../data-types/int-uint.md) as the first Snowflake ID at that time.",
      "examples": "**simple**\n\n```sql title=Query\nSELECT dateTime64ToSnowflakeID(toDateTime64('2021-08-15 18:57:56', 3, 'Asia/Shanghai'))\n```\n\n```response title=Response\n6832626394434895872\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "dateTimeToSnowflake",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dateTimeToSnowflakeID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "dateTimeToSnowflakeID(value[, epoch])",
      "description": "Converts a [DateTime](../data-types/datetime.md) value to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.",
      "arguments": "- `value` — Date with time. [DateTime](../data-types/datetime.md).\n- `epoch` — Epoch of the Snowflake ID in milliseconds since 1970-01-01. Defaults to 0 (1970-01-01). For the Twitter/X epoch (2015-01-01), provide 1288834974657. Optional. [UInt*](../data-types/int-uint.md)\n",
      "returnedValue": "Input value converted to [UInt64](../data-types/int-uint.md) as the first Snowflake ID at that time.",
      "examples": "**simple**\n\n```sql title=Query\nSELECT dateTimeToSnowflakeID(toDateTime('2021-08-15 18:57:56', 'Asia/Shanghai'))\n```\n\n```response title=Response\n6832626392367104000\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "dateTrunc",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "date_bin",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toStartOfInterval",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "date_diff",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "dateDiff",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "decodeHTMLComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "decodeURLComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "decodeURLFormComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "decodeXMLComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "decrypt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "defaultProfiles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "defaultRoles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "defaultValueOfArgumentType",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "defaultValueOfTypeName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "degrees",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSum",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestamp",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "demangle",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRank",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dense_rank",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "denseRank",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "detectCharset",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "detectLanguage",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "detectLanguageMixed",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "detectLanguageUnknown",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "detectProgrammingLanguage",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "detectTonality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dictGet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the attribute's data type if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves all values from a dictionary corresponding to the given key values.\n\nAccepts 3 or 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- [optional] maximum number of values to return for each attribute;\n\nReturned value: array of dictionary attribute values parsed in the attribute's data type if key is found, otherwise empty array.\n\nThrows an exception if cannot parse the value of the attribute, the value does not match the attribute data type, or the dictionary doesn't support this function.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetChildren",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns first-level children as an array of indexes. It is the inverse transformation for dictGetHierarchy.\nAccepts 2 parameters: name of the dictionary, key value - expression returning a UInt64-type value.\nReturned value: first-level descendants for the key, type of Array(UInt64)\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetDate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Date if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetDateOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Date if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the DateTime if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetDateTimeOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the DateTime if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetDescendants",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns all descendants as if dictGetChildren function was applied level times recursively.\nAccepts 3 parameters: name of the dictionary, key value - expression returning a UInt64-type value, level — hierarchy level - If level = 0 returns all descendants to the end - UInt8\nReturned value: descendants for the key, type of Array(UInt64)\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetFloat32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Float32 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetFloat32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Float32 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetFloat64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Float64 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetFloat64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Float64 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetHierarchy",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nCreates an array, containing all the parents of a key in the hierarchical dictionary.\nAccepts 2 parameters: name of the dictionary, key value - expression returning a UInt64-type value.\nReturned value: parents for the key, type of Array(UInt64)\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetIPv4",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the IPv4 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetIPv4OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the IPv4 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetIPv6",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the IPv6 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetIPv6OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the IPv6 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Int16 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt16OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Int16 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Int32 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Int32 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Int64 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Int64 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the Int8 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetInt8OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the Int8 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the attribute's data type if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the attribute's data type if key is found, otherwise NULL.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the String if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetStringOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the String if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the UInt16 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt16OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the UInt16 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the UInt32 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the UInt32 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the UInt64 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the UInt64 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the UInt8 if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUInt8OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the UInt8 if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUUID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 3 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n\nReturned value: value of the dictionary attribute parsed in the UUID if key is found, otherwise <null_value> element specified in the dictionary configuration.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictGetUUIDOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nRetrieves values from a dictionary.\n\nAccepts 4 parameters:\n-- name of the dictionary;\n-- name of the column of the dictionary or tuple of column names;\n-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n-- default values returned if the dictionary does not contain a row with the key value;\n\nReturned value: value of the dictionary attribute parsed in the UUID if key is found, otherwise default value.\n\nThrows an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictHas",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nChecks whether a key is present in a dictionary.\nAccepts 2 parameters: name of the dictionary, key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration.\nReturned value: 0 if there is no key, 1 if there is a key, type of UInt8\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "dictIsIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nChecks the ancestor of a key through the whole hierarchical chain in the dictionary.\nAccepts 3 parameters: name of the dictionary, key to be checked - expression returning a UInt64-type value, alleged ancestor of the key - expression returning a UInt64-type.\nReturned value: 0 if key is not a child of the ancestor, 1 if key is a child of the ancestor or if key is the ancestor, type of UInt8\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Dictionary"
    },
    {
      "name": "displayName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the value of `display_name` from config or server FQDN if not set.\n\n[example:displayName]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**displayName**\n\n```sql title=Query\nSELECT displayName();\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "distanceL1",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L1Distance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distanceL2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L2Distance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distanceL2Squared",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L2SquaredDistance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distanceLinf",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "LinfDistance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distanceLp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "LpDistance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypes",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPaths",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypes",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "divide",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "divide(x, y)",
      "description": "\n    Calculates the quotient of two values `a` and `b`. The result type is always [Float64](/sql-reference/data-types/float).\n    Integer division is provided by the `intDiv` function.\n\n    :::note\n    Division by `0` returns `inf`, `-inf`, or `nan`.\n    :::\n    ",
      "arguments": "- `x` — Dividend\n- `y` — Divisor\n",
      "returnedValue": "The quotient of x and y",
      "examples": "**Dividing two numbers**\n\n```sql title=Query\nSELECT divide(25,5) AS quotient, toTypeName(quotient)\n```\n\n```response title=Response\n5 Float64\n```\n\n**Dividing by zero**\n\n```sql title=Query\nSELECT divide(25,0)\n```\n\n```response title=Response\ninf\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "divideDecimal",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "divideDecimal(x, y[, result_scale])",
      "description": "\nPerforms division on two decimals. Result value will be of type [Decimal256](/sql-reference/data-types/decimal).\nResult scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.\n\n:::note\nThese function work significantly slower than usual `divide`.\nIn case you don't really need controlled precision and/or need fast computation, consider using [divide](#divide).\n:::\n    ",
      "arguments": "- `x` — First value: [Decimal](/sql-reference/data-types/decimal).\n- `y` — Second value: [Decimal](/sql-reference/data-types/decimal).\n- `result_scale` — Scale of result. Type [Int/UInt](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "The result of division with given scale. Type: [Decimal256](/sql-reference/data-types/decimal.md).",
      "examples": "**Example 1**\n\n```sql title=Query\ndivideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)\n```\n\n```response title=Response\n┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐\n│                                                -5.7142857142 │\n└──────────────────────────────────────────────────────────────┘\n```\n\n**Example 2**\n\n```sql title=Query\nSELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);\nSELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);\n```\n\n```response title=Response\n┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐\n│                                             -5.7 │\n└──────────────────────────────────────────────────┘\n┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐\n│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │\n└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "divideOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "divideOrNull(x, y)",
      "description": "\nSame as `divide` but returns NULL when dividing by zero.\n    ",
      "arguments": "- `x` — Dividend\n- `y` — Divisor\n",
      "returnedValue": "The quotient of x and y, or NULL.",
      "examples": "**Dividing by zero**\n\n```sql title=Query\nSELECT divideOrNull(25, 0)\n```\n\n```response title=Response\n\\N\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "domain",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nExtracts the hostname from a URL.\n\nThe URL can be specified with or without a scheme.\nIf the argument can't be parsed as URL, the function returns an empty string.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**domain**\n\n```sql title=Query\nSELECT domain('svn+ssh://some.svn-hosting.com:80/repo/trunk')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "domainRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `domain` but follows stricter rules to be compatible with RFC 3986 and less performant.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "domainWithoutWWW",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nExtracts the hostname from a URL, removing the leading \"www.\" if present.\n\nThe URL can be specified with or without a scheme.\nIf the argument can't be parsed as URL, the function returns an empty string.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**domainWithoutWWW**\n\n```sql title=Query\nSELECT domainWithoutWWW('https://www.clickhouse.com')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "domainWithoutWWWRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `domainWithoutWWW` but follows stricter rules to be compatible with RFC 3986 and less performant.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "dotProduct",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dumpColumnStructure",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "dynamicElement",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "dynamicElement(dynamic, type_name)",
      "description": "\nExtracts a column with specified type from a `Dynamic` column.\n",
      "arguments": "- `dynamic` — Dynamic column\n- `type_name` — The name of the variant type to extract\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (d Dynamic) ENGINE = Memory;\nINSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);\nSELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test;\n```\n\n```response title=Response\n┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐\n│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │\n│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │\n│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │\n│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │\n└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "dynamicType",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "dynamicType(dynamic)",
      "description": "\nReturns the variant type name for each row of `Dynamic` column. If row contains NULL, it returns 'None' for it.\n",
      "arguments": "- `dynamic` — Dynamic column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (d Dynamic) ENGINE = Memory;\nINSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);\nSELECT d, dynamicType(d) FROM test;\n```\n\n```response title=Response\n┌─d─────────────┬─dynamicType(d)─┐\n│ ᴺᵁᴸᴸ          │ None           │\n│ 42            │ Int64          │\n│ Hello, World! │ String         │\n│ [1,2,3]       │ Array(Int64)   │\n└───────────────┴────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "e",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "editDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the edit distance between two byte-strings.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "editDistanceUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the edit distance between two UTF8 strings.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "empty",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "empty(arr)",
      "description": "\nChecks whether the input array is empty.\n\nAn array is considered empty if it does not contain any elements.\n\n:::note\nCan be optimized by enabling the [`optimize_functions_to_subcolumns` setting](/operations/settings/settings#optimize_functions_to_subcolumns). With `optimize_functions_to_subcolumns = 1` the function reads only [size0](/sql-reference/data-types/array#array-size) subcolumn instead of reading and processing the whole array column. The query `SELECT empty(arr) FROM TABLE;` transforms to `SELECT arr.size0 = 0 FROM TABLE;`.\n:::\n\nThe function also works for [strings](string-functions.md#empty) or [UUID](uuid-functions.md#empty).\n    ",
      "arguments": "- `arr` — Input array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns `1` for an empty array or `0` for a non-empty array. [`UInt8`](../data-types/int-uint.md).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT empty([]);\n```\n\n```response title=Response\n1\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayDate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayDate()",
      "description": "Returns an empty Date array",
      "arguments": "",
      "returnedValue": "An empty Date array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayDate\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayDateTime()",
      "description": "Returns an empty DateTime array",
      "arguments": "",
      "returnedValue": "An empty DateTime array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayDateTime\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayFloat32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayFloat32()",
      "description": "Returns an empty Float32 array",
      "arguments": "",
      "returnedValue": "An empty Float32 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayFloat32\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayFloat64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayFloat64()",
      "description": "Returns an empty Float64 array",
      "arguments": "",
      "returnedValue": "An empty Float64 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayFloat64\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayInt16()",
      "description": "Returns an empty Int16 array",
      "arguments": "",
      "returnedValue": "An empty Int16 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayInt16\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayInt32()",
      "description": "Returns an empty Int32 array",
      "arguments": "",
      "returnedValue": "An empty Int32 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayInt32\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayInt64()",
      "description": "Returns an empty Int64 array",
      "arguments": "",
      "returnedValue": "An empty Int64 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayInt64\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayInt8()",
      "description": "Returns an empty Int8 array",
      "arguments": "",
      "returnedValue": "An empty Int8 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayInt8\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayString()",
      "description": "Returns an empty String array",
      "arguments": "",
      "returnedValue": "An empty String array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayString\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayToSingle",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayToSingle(arr)",
      "description": "\nAccepts an empty array and returns a one-element array that is equal to the default value.\n    ",
      "arguments": "- `arr` — An empty array. [`Array(T)`](/sql-reference/data-types/array)\n",
      "returnedValue": "An array with a single value of the Array's default type.",
      "examples": "**Basic example**\n\n```sql title=Query\nCREATE TABLE test (\n  a Array(Int32),\n  b Array(String),\n  c Array(DateTime)\n)\nENGINE = MergeTree\nORDER BY tuple();\n\nINSERT INTO test VALUES ([], [], []);\n\nSELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;\n```\n\n```response title=Response\n┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐\n│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │\n└───────────────────────┴───────────────────────┴─────────────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayUInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayUInt16()",
      "description": "Returns an empty UInt16 array",
      "arguments": "",
      "returnedValue": "An empty UInt16 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayUInt16\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayUInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayUInt32()",
      "description": "Returns an empty UInt32 array",
      "arguments": "",
      "returnedValue": "An empty UInt32 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayUInt32\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayUInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayUInt64()",
      "description": "Returns an empty UInt64 array",
      "arguments": "",
      "returnedValue": "An empty UInt64 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayUInt64\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "emptyArrayUInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "emptyArrayUInt8()",
      "description": "Returns an empty UInt8 array",
      "arguments": "",
      "returnedValue": "An empty UInt8 array. [`Array(T)`](/sql-reference/data-types/array).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT emptyArrayUInt8\n```\n\n```response title=Response\n[]\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "enabledProfiles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "enabledRoles",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "encodeURLComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "encodeURLFormComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "encodeXMLComponent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "encrypt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "endsWith",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "endsWithUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns whether string `str` ends with `suffix`, the difference between `endsWithUTF8` and `endsWith` is that `endsWithUTF8` match `str` and `suffix` by UTF-8 characters.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**endsWithUTF8**\n\n```sql title=Query\nselect endsWithUTF8('富强民主文明和谐', '富强');\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "String"
    },
    {
      "name": "entropy",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "equals",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "equals(a, b)\n        -- a = b\n        -- a == b",
      "description": "Compares two values for equality.",
      "arguments": "- `a` — First value.<sup>[*](#comparison-rules)</sup>\n- `b` — Second value.<sup>[*](#comparison-rules)</sup>\n",
      "returnedValue": "Returns `1` if `a` is equal to `b`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 1 = 1, 1 = 2;\n```\n\n```response title=Response\n┌─equals(1, 1)─┬─equals(1, 2)─┐\n│            1 │            0 │\n└──────────────┴──────────────┘\n```\n\n",
      "categories": "Comparison"
    },
    {
      "name": "erf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "erfc",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "errorCodeToName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatio",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "evalMLMethod",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exp10",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exp2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverage",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvg",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCount",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSum",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extract",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractAllGroups",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "extractAllGroupsVertical",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractAllGroupsHorizontal",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractAllGroupsVertical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractGroups",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractKeyValuePairs",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Extracts key-value pairs from any string. The string does not need to be 100% structured in a key value pair format;\n\n            It can contain noise (e.g. log files). The key-value pair format to be interpreted should be specified via function arguments.\n\n            A key-value pair consists of a key followed by a `key_value_delimiter` and a value. Quoted keys and values are also supported. Key value pairs must be separated by pair delimiters.\n\n            **Syntax**\n            ```sql\n            extractKeyValuePairs(data, [key_value_delimiter], [pair_delimiter], [quoting_character])\n            ```\n\n            **Arguments**\n            - `data` - String to extract key-value pairs from. [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md).\n            - `key_value_delimiter` - Character to be used as delimiter between the key and the value. Defaults to `:`. [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md).\n            - `pair_delimiters` - Set of character to be used as delimiters between pairs. Defaults to `\\space`, `,` and `;`. [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md).\n            - `quoting_character` - Character to be used as quoting character. Defaults to `\"`. [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md).\n\n            **Returned values**\n            - The extracted key-value pairs in a Map(String, String).\n\n            **Examples**\n\n            Query:\n\n            **Simple case**\n            ```sql\n            arthur :) select extractKeyValuePairs('name:neymar, age:31 team:psg,nationality:brazil') as kv\n\n            SELECT extractKeyValuePairs('name:neymar, age:31 team:psg,nationality:brazil') as kv\n\n            Query id: f9e0ca6f-3178-4ee2-aa2c-a5517abb9cee\n\n            ┌─kv──────────────────────────────────────────────────────────────────────┐\n            │ {'name':'neymar','age':'31','team':'psg','nationality':'brazil'}        │\n            └─────────────────────────────────────────────────────────────────────────┘\n            ```\n\n            **Single quote as quoting character**\n            ```sql\n            arthur :) select extractKeyValuePairs('name:\\'neymar\\';\\'age\\':31;team:psg;nationality:brazil,last_key:last_value', ':', ';,', '\\'') as kv\n\n            SELECT extractKeyValuePairs('name:\\'neymar\\';\\'age\\':31;team:psg;nationality:brazil,last_key:last_value', ':', ';,', '\\'') as kv\n\n            Query id: 0e22bf6b-9844-414a-99dc-32bf647abd5e\n\n            ┌─kv───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n            │ {'name':'neymar','age':'31','team':'psg','nationality':'brazil','last_key':'last_value'}                                 │\n            └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n            ```\n\n            **Escape sequences without escape sequences support**\n            ```sql\n            arthur :) select extractKeyValuePairs('age:a\\\\x0A\\\\n\\\\0') as kv\n\n            SELECT extractKeyValuePairs('age:a\\\\x0A\\\\n\\\\0') AS kv\n\n            Query id: e9fd26ee-b41f-4a11-b17f-25af6fd5d356\n\n            ┌─kv────────────────────┐\n            │ {'age':'a\\\\x0A\\\\n\\\\0'} │\n            └───────────────────────┘\n            ```",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Map"
    },
    {
      "name": "extractKeyValuePairsWithEscaping",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Same as `extractKeyValuePairs` but with escaping support.\n\n            Escape sequences supported: `\\x`, `\\N`, `\\a`, `\\b`, `\\e`, `\\f`, `\\n`, `\\r`, `\\t`, `\\v` and `\\0`.\n            Non standard escape sequences are returned as it is (including the backslash) unless they are one of the following:\n            `\\\\`, `'`, `\"`, `backtick`, `/`, `=` or ASCII control characters (c <= 31).\n\n            This function will satisfy the use case where pre-escaping and post-escaping are not suitable. For instance, consider the following\n            input string: `a: \"aaaa\\\"bbb\"`. The expected output is: `a: aaaa\\\"bbbb`.\n            - Pre-escaping: Pre-escaping it will output: `a: \"aaaa\"bbb\"` and `extractKeyValuePairs` will then output: `a: aaaa`\n            - Post-escaping: `extractKeyValuePairs` will output `a: aaaa\\` and post-escaping will keep it as it is.\n\n            Leading escape sequences will be skipped in keys and will be considered invalid for values.\n\n            **Escape sequences with escape sequence support turned on**\n            ```sql\n            arthur :) select extractKeyValuePairsWithEscaping('age:a\\\\x0A\\\\n\\\\0') as kv\n\n            SELECT extractKeyValuePairsWithEscaping('age:a\\\\x0A\\\\n\\\\0') AS kv\n\n            Query id: 44c114f0-5658-4c75-ab87-4574de3a1645\n\n            ┌─kv───────────────┐\n            │ {'age':'a\\n\\n\\0'} │\n            └──────────────────┘\n            ```",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Map"
    },
    {
      "name": "extractTextFromHTML",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractURLParameter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractURLParameterNames",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "extractURLParameters",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "factorial",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nComputes the factorial of an integer value. It works with any native integer type including UInt(8|16|32|64) and Int(8|16|32|64). The return type is UInt64.\n\nThe factorial of 0 is 1. Likewise, the factorial() function returns 1 for any negative value. The maximum positive value for the input argument is 20, a value of 21 or greater will cause exception throw.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**factorial**\n\n```sql title=Query\nSELECT factorial(10)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Mathematical"
    },
    {
      "name": "farmFingerprint64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "farmHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "file",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "filesystemAvailable",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "filesystemCapacity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "filesystemUnreserved",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "finalizeAggregation",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "firstLine",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "firstLine(string)",
      "description": "Returns first line of a multi-line string.",
      "arguments": "- `string` — The string to process.\n",
      "returnedValue": "The first line of the string or the whole string if there is no line separators.",
      "examples": "**Return first line**\n\n```sql title=Query\nfirstLine('Hello\\nWorld')\n```\n\n```response title=Response\n'Hello'\n```\n\n**Return whole string**\n\n```sql title=Query\nfirstLine('Hello World')\n```\n\n```response title=Response\n'Hello World'\n```\n\n",
      "categories": "String"
    },
    {
      "name": "firstSignificantSubdomain",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the \"first significant subdomain\".\n\nThe first significant subdomain is a second-level domain if it is 'com', 'net', 'org', or 'co'.\nOtherwise, it is a third-level domain.\n\nFor example, firstSignificantSubdomain('https://news.clickhouse.com/') = 'clickhouse', firstSignificantSubdomain ('https://news.clickhouse.com.tr/') = 'clickhouse'.\n\nThe list of \"insignificant\" second-level domains and other implementation details may change in the future.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**firstSignificantSubdomain**\n\n```sql title=Query\nSELECT firstSignificantSubdomain('https://news.clickhouse.com/')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "firstSignificantSubdomainCustom",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "firstSignificantSubdomainCustomRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "firstSignificantSubdomainRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns the \"first significant subdomain\" according to RFC 1034.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "firstValueRespectNulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "any_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "first_value",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "any",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "first_value_respect_nulls",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "any_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraph",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flatten",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "arrayFlatten",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flattenTuple",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "floor",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "format",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatDateTimeInJodaSyntax",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatQuery",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "formatQuery(query)",
      "description": "Returns a formatted, possibly multi-line, version of the given SQL query. Throws in case of a parsing error.\n[example:multiline]",
      "arguments": "- `query` — The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\n",
      "returnedValue": "The formatted query. [String](../../sql-reference/data-types/string.md).",
      "examples": "**multiline**\n\n```sql title=Query\nSELECT formatQuery('select a,    b FRom tab WHERE a > 3 and  b < 3');\n```\n\n```response title=Response\nSELECT\n    a,\n    b\nFROM tab\nWHERE (a > 3) AND (b < 3)\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "formatQueryOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "formatQueryOrNull(query)",
      "description": "Returns a formatted, possibly multi-line, version of the given SQL query. Returns NULL in case of a parsing error.\n[example:multiline]",
      "arguments": "- `query` — The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\n",
      "returnedValue": "The formatted query. [String](../../sql-reference/data-types/string.md).",
      "examples": "**multiline**\n\n```sql title=Query\nSELECT formatQuery('select a,    b FRom tab WHERE a > 3 and  b < 3');\n```\n\n```response title=Response\nSELECT\n    a,\n    b\nFROM tab\nWHERE (a > 3) AND (b < 3)\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "formatQuerySingleLine",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "formatQuerySingleLine(query)",
      "description": "Like formatQuery() but the returned formatted string contains no line breaks. Throws in case of a parsing error.\n[example:multiline]",
      "arguments": "- `query` — The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\n",
      "returnedValue": "The formatted query. [String](../../sql-reference/data-types/string.md).",
      "examples": "**multiline**\n\n```sql title=Query\nSELECT formatQuerySingleLine('select a,    b FRom tab WHERE a > 3 and  b < 3');\n```\n\n```response title=Response\nSELECT a, b FROM tab WHERE (a > 3) AND (b < 3)\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "formatQuerySingleLineOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "formatQuerySingleLineOrNull(query)",
      "description": "Like formatQuery() but the returned formatted string contains no line breaks. Returns NULL in case of a parsing error.\n[example:multiline]",
      "arguments": "- `query` — The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\n",
      "returnedValue": "The formatted query. [String](../../sql-reference/data-types/string.md).",
      "examples": "**multiline**\n\n```sql title=Query\nSELECT formatQuerySingleLine('select a,    b FRom tab WHERE a > 3 and  b < 3');\n```\n\n```response title=Response\nSELECT a, b FROM tab WHERE (a > 3) AND (b < 3)\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "formatReadableDecimalSize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nAccepts the size (number of bytes). Returns a rounded size with a suffix (KB, MB, etc.) as a string.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**formatReadableDecimalSize**\n\n```sql title=Query\nSELECT formatReadableDecimalSize(1000)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "formatReadableQuantity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatReadableSize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatReadableTimeDelta",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatRow",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "formatRowNoNewline",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fragment",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromDaysSinceYearZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nGiven the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601 return a corresponding date.\nThe calculation is the same as in MySQL's FROM_DAYS() function.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT fromDaysSinceYearZero(713569)\n```\n\n```response title=Response\n2023-09-08\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "fromDaysSinceYearZero32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nGiven the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601 return a corresponding date.\nThe calculation is the same as in MySQL's FROM_DAYS() function.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT fromDaysSinceYearZero32(713569)\n```\n\n```response title=Response\n2023-09-08\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "fromModifiedJulianDay",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromModifiedJulianDayOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUTCTimestamp",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUnixTimestamp",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUnixTimestamp64Micro",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUnixTimestamp64Milli",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUnixTimestamp64Nano",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUnixTimestamp64Second",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fromUnixTimestampInJodaSyntax",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "from_utc_timestamp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "fromUTCTimestamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fullHostName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "FQDN",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "fuzzBits",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "gccMurmurHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "gcd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "gcd(x, y)",
      "description": "\n    Returns the greatest common divisor of two values a and b.\n\n    An exception is thrown when dividing by zero or when dividing a minimal\n    negative number by minus one.\n    ",
      "arguments": "- `x` — First integer\n- `y` — Second integer\n",
      "returnedValue": "The greatest common divisor of `x` and `y`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT gcd(12, 18)\n```\n\n```response title=Response\n6\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "generateRandomStructure",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nGenerates a random table structure.\nThis function takes 2 optional constant arguments:\nthe number of columns in the result structure (random by default) and random seed (random by default)\nThe maximum number of columns is 128.\nThe function returns a value of type String.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**random**\n\n```sql title=Query\nSELECT generateRandomStructure()\n```\n\n```response title=Response\nc1 UInt32, c2 FixedString(25)\n```\n\n**with specified number of columns**\n\n```sql title=Query\nSELECT generateRandomStructure(3)\n```\n\n```response title=Response\nc1 String, c2 Array(Int32), c3 LowCardinality(String)\n```\n\n**with specified seed**\n\n```sql title=Query\nSELECT generateRandomStructure(1, 42)\n```\n\n```response title=Response\nc1 UInt128\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "generateSerialID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "generateSerialID('series_identifier')",
      "description": "\nGenerates and returns sequential numbers starting from the previous counter value.\nThis function takes a constant string argument - a series identifier.\n\nThe server should be configured with Keeper.\nThe series are stored in Keeper nodes under the path, which can be configured in `series_keeper_path` in the server configuration.\n",
      "arguments": "- `series_identifier` — Series identifier, (a short constant String)\n",
      "returnedValue": "Sequential numbers starting from the previous counter value",
      "examples": "**first call**\n\n```sql title=Query\nSELECT generateSerialID('id1')\n```\n\n```response title=Response\n┌─generateSerialID('id1')──┐\n│                        1 │\n└──────────────────────────┘\n```\n\n**second call**\n\n```sql title=Query\nSELECT generateSerialID('id1')\n```\n\n```response title=Response\n┌─generateSerialID('id1')──┐\n│                        2 │\n└──────────────────────────┘\n```\n\n**column call**\n\n```sql title=Query\nSELECT *, generateSerialID('id1') FROM test_table\n```\n\n```response title=Response\n┌─CounterID─┬─UserID─┬─ver─┬─generateSerialID('id1')──┐\n│         1 │      3 │   3 │                        3 │\n│         1 │      1 │   1 │                        4 │\n│         1 │      2 │   2 │                        5 │\n│         1 │      5 │   5 │                        6 │\n│         1 │      4 │   4 │                        7 │\n└───────────┴────────┴─────┴──────────────────────────┘\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "generateSnowflakeID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "generateSnowflakeID([expression, [machine_id]])",
      "description": "Generates a Snowflake ID. The generated Snowflake ID contains the current Unix timestamp in milliseconds (41 + 1 top zero bits), followed by a machine id (10 bits), and a counter (12 bits) to distinguish IDs within a millisecond. For any given timestamp (unix_ts_ms), the counter starts at 0 and is incremented by 1 for each new Snowflake ID until the timestamp changes. In case the counter overflows, the timestamp field is incremented by 1 and the counter is reset to 0. Function generateSnowflakeID guarantees that the counter field within a timestamp increments monotonically across all function invocations in concurrently running threads and queries.",
      "arguments": "- `expression` — The expression is used to bypass common subexpression elimination if the function is called multiple times in a query but otherwise ignored. Optional.\n- `machine_id` — A machine ID, the lowest 10 bits are used. Optional.\n",
      "returnedValue": "A value of type UInt64",
      "examples": "**no_arguments**\n\n```sql title=Query\nSELECT generateSnowflakeID()\n```\n\n```response title=Response\n7201148511606784000\n```\n\n**with_machine_id**\n\n```sql title=Query\nSELECT generateSnowflakeID(1)\n```\n\n```response title=Response\n7201148511606784001\n```\n\n**with_expression_and_machine_id**\n\n```sql title=Query\nSELECT generateSnowflakeID('some_expression', 1)\n```\n\n```response title=Response\n7201148511606784002\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "generateULID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nGenerates a Universally Unique Lexicographically Sortable Identifier (ULID).\nThis function takes an optional argument, the value of which is discarded to generate different values in case the function is called multiple times.\nThe function returns a value of type FixedString(26).\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**ulid**\n\n```sql title=Query\nSELECT generateULID()\n```\n\n```response title=Response\n\n```\n\n**multiple**\n\n```sql title=Query\nSELECT generateULID(1), generateULID(2)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "ULID"
    },
    {
      "name": "generateUUIDv4",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "generateUUIDv7",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT generateUUIDv7()",
      "description": "Generates a UUID of version 7. The generated UUID contains the current Unix timestamp in milliseconds (48 bits), followed by version \"7\" (4 bits), a counter (42 bit, including a variant field \"2\", 2 bit) to distinguish UUIDs within a millisecond, and a random field (32 bits). For any given timestamp (unix_ts_ms), the counter starts at a random value and is incremented by 1 for each new UUID until the timestamp changes. In case the counter overflows, the timestamp field is incremented by 1 and the counter is reset to a random new start value. Function generateUUIDv7 guarantees that the counter field within a timestamp increments monotonically across all function invocations in concurrently running threads and queries.",
      "arguments": "- `expression` — The expression is used to bypass common subexpression elimination if the function is called multiple times in a query but otherwise ignored. Optional.\n",
      "returnedValue": "A value of type UUID version 7.",
      "examples": "**single**\n\n```sql title=Query\nSELECT generateUUIDv7()\n```\n\n```response title=Response\n\n```\n\n**multiple**\n\n```sql title=Query\nSELECT generateUUIDv7(1), generateUUIDv7(2)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "geoDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "geoToH3",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "geoToS2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "geohashDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "geohashEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "geohashesInBox",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "getClientHTTPHeader",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nGet the value of an HTTP header.\n\nIf there is no such header or the current request is not performed via the HTTP interface, the function returns an empty string.\nCertain HTTP headers (e.g., `Authentication` and `X-ClickHouse-*`) are restricted.\n\nThe function requires the setting `allow_get_client_http_header` to be enabled.\nThe setting is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info.\n\nHTTP headers are case sensitive for this function.\n\nIf the function is used in the context of a distributed query, it returns non-empty result only on the initiator node.\n\",\n            .syntax = \"getClientHTTPHeader(name",
      "arguments": "- `name` — The HTTP header name (String)\n",
      "returnedValue": "The value of the header (String).",
      "examples": "",
      "categories": "Other"
    },
    {
      "name": "getMacro",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "getMaxTableNameLengthForDatabase",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "getMaxTableNameLengthForDatabase(database_name)",
      "description": "Returns the maximum table name length in a specified database.",
      "arguments": "- `database_name` — The name of the specified database. String.\n",
      "returnedValue": "Returns the length of the maximum table name, an Integer",
      "examples": "**typical**\n\n```sql title=Query\nSELECT getMaxTableNameLengthForDatabase('default');\n```\n\n```response title=Response\n┌─getMaxTableNameLengthForDatabase('default')─┐\n            │                                         206 │\n            └─────────────────────────────────────────────┘\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "getMergeTreeSetting",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "getMergeTreeSetting('custom_setting')",
      "description": "\nReturns the current value of merge tree setting.\n",
      "arguments": "- `custom_setting` — The setting name. Type: String.\n",
      "returnedValue": "The setting's current value.",
      "examples": "**getMergeTreeSetting**\n\n```sql title=Query\nSELECT getMergeTreeSetting('index_granularity');\n```\n\n```response title=Response\n8192\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "getOSKernelVersion",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "getServerPort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "getServerSetting",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "getServerSetting('custom_setting')",
      "description": "\nReturns the current value of server setting.\n",
      "arguments": "- `custom_setting` — The setting name. Type: String.\n",
      "returnedValue": "The setting's current value.",
      "examples": "**getServerSetting**\n\n```sql title=Query\nSELECT getSetting('page_cache_size_ratio');\n```\n\n```response title=Response\nSRLU\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "getSetting",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "getSetting('custom_setting')",
      "description": "\nReturns the current value of a custom setting.\n",
      "arguments": "- `custom_setting` — The setting name. Type: String.\n",
      "returnedValue": "The setting's current value.",
      "examples": "**getSetting**\n\n```sql title=Query\nSET custom_a = 123; SELECT getSetting('custom_a');\n```\n\n```response title=Response\n123\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "getSettingOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "getSettingOrDefault('custom_setting', default_value)",
      "description": "\nReturns the current value of a custom setting or returns the default value specified in the 2nd argument if the custom setting is not set in the current profile.\n",
      "arguments": "- `custom_setting` — The setting name. Type: String.\n- `default_value` — Value to return if custom_setting is not set. Value may be of any data type or Null.\n",
      "returnedValue": "The setting's current value or the default_value if setting is not set.",
      "examples": "**getSettingOrDefault**\n\n```sql title=Query\nSELECT getSettingOrDefault('custom_undef1', 'my_value');\n```\n\n```response title=Response\nmy_value\n```\n\n**getSettingOrDefault**\n\n```sql title=Query\nSELECT getSettingOrDefault('custom_undef1', 100);\n```\n\n```response title=Response\n100\n```\n\n**getSettingOrDefault**\n\n```sql title=Query\nSELECT getSettingOrDefault('custom_undef1', NULL);\n```\n\n```response title=Response\nNULL\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "getSizeOfEnumType",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "getSubcolumn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReceives the expression or identifier and constant string with the name of subcolumn.\n\nReturns requested subcolumn extracted from the expression.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**getSubcolumn**\n\n```sql title=Query\nSELECT getSubcolumn(array_col, 'size0'), getSubcolumn(tuple_col, 'elem_name')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "getTypeSerializationStreams",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalNotIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalNotInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalNotNullIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalNotNullInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalNullIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalNullInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "globalVariable",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "greatCircleAngle",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "greatCircleDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "greater",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "greater(a, b)\n    -- a > b",
      "description": "Compares two values for greater-than relation.",
      "arguments": "- `a` — First value.<sup>[*](#comparison-rules)</sup>\n- `b` — Second value.<sup>[*](#comparison-rules)</sup>\n",
      "returnedValue": "Returns `1` if `a` is greater than `b`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 2 > 1, 1 > 2;\n```\n\n```response title=Response\n┌─greater(2, 1)─┬─greater(1, 2)─┐\n│             1 │             0 │\n└───────────────┴───────────────┘\n```\n\n",
      "categories": "Comparison"
    },
    {
      "name": "greaterOrEquals",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "greaterOrEquals(a, b)\n    -- a >= b",
      "description": "Compares two values for greater-than-or-equal-to relation.",
      "arguments": "- `a` — First value.<sup>[*](#comparison-rules)</sup>\n- `b` — Second value.<sup>[*](#comparison-rules)</sup>\n",
      "returnedValue": "Returns `1` if `a` is greater than or equal to `b`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 2 >= 1, 2 >= 2, 1 >= 2;\n```\n\n```response title=Response\n┌─greaterOrEquals(2, 1)─┬─greaterOrEquals(2, 2)─┬─greaterOrEquals(1, 2)─┐\n│                     1 │                     1 │                     0 │\n└───────────────────────┴───────────────────────┴───────────────────────┘\n```\n\n",
      "categories": "Comparison"
    },
    {
      "name": "greatest",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "greatest(x1[, x2, ..., xN])",
      "description": "\nReturns the greatest value among the arguments.\n\n- For arrays, returns the lexicographically greatest array.\n- For DateTime types, the result type is promoted to the largest type (e.g., DateTime64 if mixed with DateTime32).\n    ",
      "arguments": "- `x1[, x2, ..., xN]` — One or multiple values to compare. All arguments must be of comparable types.\n",
      "returnedValue": "The greatest value among the arguments, promoted to the largest compatible type.",
      "examples": "**Numeric types**\n\n```sql title=Query\nSELECT greatest(1, 2, toUInt8(3), 3.) AS result, toTypeName(result) AS type;\n-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.\n```\n\n```response title=Response\n┌─result─┬─type────┐\n│      3 │ Float64 │\n└────────┴─────────┘\n```\n\n**Arrays**\n\n```sql title=Query\nSELECT greatest(['hello'], ['there'], ['world']);\n```\n\n```response title=Response\n┌─greatest(['hello'], ['there'], ['world'])─┐\n│ ['world']                                 │\n└───────────────────────────────────────────┘\n```\n\n**DateTime types**\n\n```sql title=Query\nSELECT greatest(toDateTime32(now() + toIntervalDay(1)), toDateTime64(now(), 3));\n-- The type returned is a DateTime64 as the DateTime32 must be promoted to 64 bit for the comparison.\n```\n\n```response title=Response\n┌─greatest(toD⋯(now(), 3))─┐\n│  2025-05-28 15:50:53.000 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Conditional"
    },
    {
      "name": "groupArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAt",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersect",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLast",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvg",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSum",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySorted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAnd",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOr",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXor",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAnd",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOr",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXor",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcat",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "group_concat",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "groupConcat",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3CellAreaM2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3CellAreaRads2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3Distance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3EdgeAngle",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3EdgeLengthKm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3EdgeLengthM",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ExactEdgeLengthKm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ExactEdgeLengthM",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ExactEdgeLengthRads",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetBaseCell",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetDestinationIndexFromUnidirectionalEdge",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetFaces",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetIndexesFromUnidirectionalEdge",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetOriginIndexFromUnidirectionalEdge",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetPentagonIndexes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetRes0Indexes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetResolution",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetUnidirectionalEdge",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetUnidirectionalEdgeBoundary",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3GetUnidirectionalEdgesFromHexagon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3HexAreaKm2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3HexAreaM2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3HexRing",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3IndexesAreNeighbors",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3IsPentagon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3IsResClassIII",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3IsValid",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3Line",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3NumHexagons",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3PointDistKm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3PointDistM",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3PointDistRads",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ToCenterChild",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ToChildren",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ToGeo",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ToGeoBoundary",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ToParent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3ToString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3UnidirectionalEdgeIsValid",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "h3kRing",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "halfMD5",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT halfMD5(par1,par2,...,parN);",
      "description": "\n[Interprets](../..//sql-reference/functions/type-conversion-functions.md/#type_conversion_functions-reinterpretAsString) all the input\nparameters as strings and calculates the MD5 hash value for each of them. Then combines hashes, takes the first 8 bytes of the hash of the\nresulting string, and interprets them as [UInt64](../../../sql-reference/data-types/int-uint.md) in big-endian byte order. The function is\nrelatively slow (5 million short strings per second per processor core).\n\nConsider using the [sipHash64](../../sql-reference/functions/hash-functions.md/#hash_functions-siphash64) function instead.\n                       ",
      "arguments": "- `par1,par2,...,parN` — \nThe function takes a variable number of input parameters. Arguments can be any of the supported data types. For some data types calculated\nvalue of hash function may be the same for the same values even if types of arguments differ (integers of different size, named and unnamed\nTuple with the same data, Map and the corresponding Array(Tuple(key, value)) type with the same data).\n                       \n",
      "returnedValue": "The computed half MD5 hash of the given input params returned as a [UInt64](../../../sql-reference/data-types/int-uint.md) in big-endian byte order.",
      "examples": "****\n\n```sql title=Query\nSELECT HEX(halfMD5('abc', 'cde', 'fgh'));\n```\n\n```response title=Response\n┌─hex(halfMD5('abc', 'cde', 'fgh'))─┐\n│ 2C9506B7374CFAF4                  │\n└───────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "has",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "has(arr, x)",
      "description": "Returns whether the array contains the specified element.",
      "arguments": "- `arr` — The source array. [`Array(T)`](/sql-reference/data-types/array).\n- `x` — The value to search for in the array.\n",
      "returnedValue": "Returns `1` if the array contains the specified element, otherwise `0`. [UInt8](/sql-reference/data-types/int-uint).",
      "examples": "**Basic usage**\n\n```sql title=Query\nSELECT has([1, 2, 3], 2)\n```\n\n```response title=Response\n1\n```\n\n**Not found**\n\n```sql title=Query\nSELECT has([1, 2, 3], 4)\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "hasAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "hasAll(set, subset)",
      "description": "\nChecks whether one array is a subset of another.\n\n- An empty array is a subset of any array.\n- `Null` is processed as a value.\n- The order of values in both the arrays does not matter.\n",
      "arguments": "- `set` — Array of any type with a set of elements. [`Array`](/sql-reference/data-types/array).\n- `subset` — Array of any type that shares a common supertype with `set` containing elements that should be tested to be a subset of `set`. [`Array`](/sql-reference/data-types/array).\n",
      "returnedValue": "- `1`, if `set` contains all of the elements from `subset`.\n- `0`, otherwise.\n\nRaises a `NO_COMMON_TYPE` exception if the set and subset elements do not share a common supertype.",
      "examples": "**Empty arrays**\n\n```sql title=Query\nSELECT hasAll([], [])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing NULL values**\n\n```sql title=Query\nSELECT hasAll([1, Null], [Null])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing values of a different type**\n\n```sql title=Query\nSELECT hasAll([1.0, 2, 3, 4], [1, 3])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing String values**\n\n```sql title=Query\nSELECT hasAll(['a', 'b'], ['a'])\n```\n\n```response title=Response\n1\n```\n\n**Arrays without a common type**\n\n```sql title=Query\nSELECT hasAll([1], ['a'])\n```\n\n```response title=Response\nRaises a NO_COMMON_TYPE exception\n```\n\n**Array of arrays**\n\n```sql title=Query\nSELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "hasAny",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "hasAny(arr_x, arr_y)",
      "description": "\nChecks whether two arrays have intersection by some elements.\n\n- `Null` is processed as a value.\n- The order of the values in both of the arrays does not matter.\n",
      "arguments": "- `arr_x` — Array of any type with a set of elements. [`Array(T)`](/sql-reference/data-types/array).\n- `arr_y` — Array of any type that shares a common supertype with array `arr_x`. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "- `1`, if `arr_x` and `arr_y` have one similar element at least.\n- `0`, otherwise.\n\nRaises a `NO_COMMON_TYPE` exception if any of the elements of the two arrays do not share a common supertype.",
      "examples": "**One array is empty**\n\n```sql title=Query\nSELECT hasAny([1], [])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing NULL values**\n\n```sql title=Query\nSELECT hasAny([Null], [Null, 1])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing values of a different type**\n\n```sql title=Query\nSELECT hasAny([-128, 1., 512], [1])\n```\n\n```response title=Response\n1\n```\n\n**Arrays without a common type**\n\n```sql title=Query\nSELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])\n```\n\n```response title=Response\nRaises a `NO_COMMON_TYPE` exception\n```\n\n**Array of arrays**\n\n```sql title=Query\nSELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])\n```\n\n```response title=Response\n1\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "hasColumnInTable",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hasSubsequence",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hasSubsequenceCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hasSubsequenceCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hasSubsequenceUTF8",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hasSubstr",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "hasSubstr(arr1, arr2)",
      "description": "\nChecks whether all the elements of array2 appear in a array1 in the same exact order.\nTherefore, the function will return `1`, if and only if array1 = prefix + array2 + suffix.\n\nIn other words, the functions will check whether all the elements of array2 are contained in array1 like the `hasAll` function.\nIn addition, it will check that the elements are observed in the same order in both array1 and array2.\n\n- The function will return `1` if array2 is empty.\n- `Null` is processed as a value. In other words `hasSubstr([1, 2, NULL, 3, 4], [2,3])` will return `0`. However, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` will return `1`\n- The order of values in both the arrays does matter.\n\nRaises a `NO_COMMON_TYPE` exception if any of the elements of the two arrays do not share a common supertype.\n",
      "arguments": "- `arr1` — Array of any type with a set of elements. [`Array(T)`](/sql-reference/data-types/array).\n- `arr2` — Array of any type with a set of elements. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns `1` if array `arr1` contains array `arr2`. Otherwise, returns `0`.",
      "examples": "**Both arrays are empty**\n\n```sql title=Query\nSELECT hasSubstr([], [])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing NULL values**\n\n```sql title=Query\nSELECT hasSubstr([1, Null], [Null])\n```\n\n```response title=Response\n1\n```\n\n**Arrays containing values of a different type**\n\n```sql title=Query\nSELECT hasSubstr([1.0, 2, 3, 4], [1, 3])\n```\n\n```response title=Response\n0\n```\n\n**Arrays containing strings**\n\n```sql title=Query\nSELECT hasSubstr(['a', 'b'], ['a'])\n```\n\n```response title=Response\n1\n```\n\n**Arrays with valid ordering**\n\n```sql title=Query\nSELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])\n```\n\n```response title=Response\n1\n```\n\n**Arrays with invalid ordering**\n\n```sql title=Query\nSELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])\n```\n\n```response title=Response\n0\n```\n\n**Array of arrays**\n\n```sql title=Query\nSELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])\n```\n\n```response title=Response\n1\n```\n\n**Arrays without a common type**\n\n```sql title=Query\nSELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])\n```\n\n```response title=Response\nRaises a `NO_COMMON_TYPE` exception\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "hasThreadFuzzer",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hasToken",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Performs lookup of needle in haystack using tokenbf_v1 index.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Search"
    },
    {
      "name": "hasTokenCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Performs case insensitive lookup of needle in haystack using tokenbf_v1 index.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Search"
    },
    {
      "name": "hasTokenCaseInsensitiveOrNull",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Performs case insensitive lookup of needle in haystack using tokenbf_v1 index. Returns null if needle is ill-formed.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Search"
    },
    {
      "name": "hasTokenOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Performs lookup of needle in haystack using tokenbf_v1 index. Returns null if needle is ill-formed.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Search"
    },
    {
      "name": "hex",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hilbertDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nDecodes a Hilbert curve index back into a tuple of unsigned integers, representing coordinates in multi-dimensional space.\n\nThe function has two modes of operation:\n- Simple\n- Expanded\n\nSimple Mode: Accepts the desired tuple size as the first argument (up to 2) and the Hilbert index as the second argument. This mode decodes the index into a tuple of the specified size.\n[example:simple]\nWill decode into: `(8, 0)`\nThe resulting tuple size cannot be more than 2\n\nExpanded Mode: Takes a range mask (tuple) as the first argument and the Hilbert index as the second argument.\nEach number in the mask specifies the number of bits by which the corresponding decoded argument will be right-shifted, effectively scaling down the output values.\n[example:range_shrank]\nNote: see hilbertEncode() docs on why range change might be beneficial.\nStill limited to 2 numbers at most.\n\nHilbert code for one argument is always the argument itself (as a tuple).\n[example:identity]\nProduces: `(1)`\n\nA single argument with a tuple specifying bit shifts will be right-shifted accordingly.\n[example:identity_shrank]\nProduces: `(128)`\n\nThe function accepts a column of codes as a second argument:\n[example:from_table]\n\nThe range tuple must be a constant:\n[example:from_table_range]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**simple**\n\n```sql title=Query\nSELECT hilbertDecode(2, 64)\n```\n\n```response title=Response\n\n```\n\n**range_shrank**\n\n```sql title=Query\nSELECT hilbertDecode((1,2), 1572864)\n```\n\n```response title=Response\n\n```\n\n**identity**\n\n```sql title=Query\nSELECT hilbertDecode(1, 1)\n```\n\n```response title=Response\n\n```\n\n**identity_shrank**\n\n```sql title=Query\nSELECT hilbertDecode(tuple(2), 512)\n```\n\n```response title=Response\n\n```\n\n**from_table**\n\n```sql title=Query\nSELECT hilbertDecode(2, code) FROM table\n```\n\n```response title=Response\n\n```\n\n**from_table_range**\n\n```sql title=Query\nSELECT hilbertDecode((1,2), code) FROM table\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "hilbertEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nCalculates code for Hilbert Curve for a list of unsigned integers.\n\nThe function has two modes of operation:\n- Simple\n- Expanded\n\nSimple: accepts up to 2 unsigned integers as arguments and produces a UInt64 code.\n[example:simple]\nProduces: `31`\n\nExpanded: accepts a range mask (tuple) as a first argument and up to 2 unsigned integers as other arguments.\nEach number in the mask configures the number of bits by which the corresponding argument will be shifted left, effectively scaling the argument within its range.\n[example:range_expanded]\nProduces: `4031541586602`\nNote: tuple size must be equal to the number of the other arguments\n\nRange expansion can be beneficial when you need a similar distribution for arguments with wildly different ranges (or cardinality)\nFor example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF)\n\nFor a single argument without a tuple, the function returns the argument itself as the Hilbert index, since no dimensional mapping is needed.\n[example:identity]\nProduces: `1`\n\nIf a single argument is provided with a tuple specifying bit shifts, the function shifts the argument left by the specified number of bits.\n[example:identity_expanded]\nProduces: `512`\n\nThe function also accepts columns as arguments:\n[example:from_table]\n\nBut the range tuple must still be a constant:\n[example:from_table_range]\n\nPlease note that you can fit only so much bits of information into Hilbert code as UInt64 has.\nTwo arguments will have a range of maximum 2^32 (64/2) each\nAll overflow will be clamped to zero\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**simple**\n\n```sql title=Query\nSELECT hilbertEncode(3, 4)\n```\n\n```response title=Response\n\n```\n\n**range_expanded**\n\n```sql title=Query\nSELECT hilbertEncode((10,6), 1024, 16)\n```\n\n```response title=Response\n\n```\n\n**identity**\n\n```sql title=Query\nSELECT hilbertEncode(1)\n```\n\n```response title=Response\n\n```\n\n**identity_expanded**\n\n```sql title=Query\nSELECT hilbertEncode(tuple(2), 128)\n```\n\n```response title=Response\n\n```\n\n**from_table**\n\n```sql title=Query\nSELECT hilbertEncode(n1, n2) FROM table\n```\n\n```response title=Response\n\n```\n\n**from_table_range**\n\n```sql title=Query\nSELECT hilbertEncode((1,2), n1, n2) FROM table\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "histogram",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hiveHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hop",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hopEnd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hopStart",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hostName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hostname",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "hostName",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "hypot",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "icebergBucket",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "icebergBucket(N, value)",
      "description": "Implements logic of iceberg bucket transform: https://iceberg.apache.org/spec/#bucket-transform-details.",
      "arguments": "- `N` — modulo, positive integer, always constant.\n- `value` — Integer, bool, decimal, float, string, fixed_string, uuid, date, time or datetime value.\n",
      "returnedValue": "Int32",
      "examples": "**Example**\n\n```sql title=Query\nSELECT icebergBucket(5, 1.0 :: Float32)\n```\n\n```response title=Response\n4\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "icebergHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "icebergHash(N, value)",
      "description": "Implements logic of iceberg hashing transform: https://iceberg.apache.org/spec/#appendix-b-32-bit-hash-requirements.",
      "arguments": "- `value` — Integer, bool, decimal, float, string, fixed_string, uuid, date, time, datetime.\n",
      "returnedValue": "Int32",
      "examples": "**Example**\n\n```sql title=Query\nSELECT icebergHash(1.0 :: Float32)\n```\n\n```response title=Response\n-142385009\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "icebergTruncate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "icebergTruncate(N, value)",
      "description": "Implements logic of iceberg truncate transform: https://iceberg.apache.org/spec/#truncate-transform-details.",
      "arguments": "- `value` — String, integer or Decimal value.\n",
      "returnedValue": "The same type as argument",
      "examples": "**Example**\n\n```sql title=Query\nSELECT icebergTruncate(3, 'iceberg')\n```\n\n```response title=Response\nice\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "identity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "idnaDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "idnaDecode(str)",
      "description": "\nComputes the Unicode representation of ASCII-encoded Internationalized Domain Name.",
      "arguments": "- `str` — Input string\n",
      "returnedValue": "An Unicode-encoded domain name [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT idnaDecode('xn--strae-oqa.xn--mnchen-3ya.de') AS unicode;\n```\n\n```response title=Response\n┌─unicode───────────┐\n│ straße.münchen.de │\n└───────────────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "idnaEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "idnaEncode(str)",
      "description": "\nComputes an ASCII representation of an Internationalized Domain Name. Throws an exception in case of error.",
      "arguments": "- `str` — Input string\n",
      "returnedValue": "An ASCII-encoded domain name [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT idnaEncode('straße.münchen.de') AS ascii;\n```\n\n```response title=Response\n┌─ascii───────────────────────────┐\n│ xn--strae-oqa.xn--mnchen-3ya.de │\n└─────────────────────────────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "if",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "if(cond, then, else)",
      "description": "\nPerforms conditional branching.\n\n- If the condition `cond` evaluates to a non-zero value, the function returns the result of the expression `then`.\n- If `cond` evaluates to zero or NULL, the result of the `else` expression is returned.\n\nThe setting [`short_circuit_function_evaluation`](/operations/settings/settings#short_circuit_function_evaluation) controls whether short-circuit evaluation is used.\n\nIf enabled, the `then` expression is evaluated only on rows where `cond` is true and the `else` expression where `cond` is false.\n\nFor example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the following query:\n\n```sql\nSELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10)\n```\n\n`then` and `else` must be of a similar type.\n",
      "arguments": "- `cond` — The evaluated condition. [`UInt8`](/sql-reference/data-types/int-uint), `Nullable(UInt8)` or `NULL`.\n- `then` — The expression returned if `cond` is true.\n- `else` — The expression returned if `cond` is false or `NULL`.\n",
      "returnedValue": "The result of either the `then` or `else` expressions, depending on condition `cond`.",
      "examples": "**Example usage**\n\n```sql title=Query\nSELECT if(1, 2 + 2, 2 + 6) AS res;\n```\n\n```response title=Response\n┌─res─┐\n│   4 │\n└─────┘\n```\n\n",
      "categories": "Conditional"
    },
    {
      "name": "ifNotFinite",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "ifNotFinite(x,y)",
      "description": "\nChecks whether a floating point value is finite.\n\nYou can get a similar result by using the [ternary operator](/sql-reference/functions/conditional-functions#if): `isFinite(x) ? x : y`.\n    ",
      "arguments": "- `x` — Value to check if infinite. Float32/Float64\n- `y` — Fallback value. Float32/Float64\n",
      "returnedValue": "- `x` if `x` is finite.\n- `y` if `x` is not finite.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 1/0 AS infimum, ifNotFinite(infimum,42)\n```\n\n```response title=Response\ninf  42\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "ifNull",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ignore",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ilike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "in",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "inIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "indexHint",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "indexOf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "indexOf(arr, x)",
      "description": "\nReturns the index of the first element with value 'x' (starting from 1) if it is in the array.\nIf the array does not contain the searched-for value, the function returns `0`.\n\nElements set to `NULL` are handled as normal values.\n    ",
      "arguments": "- `arr` — An array to search in for `x`. [`Array`](/sql-reference/data-types/array).\n- `x` — Value of the first matching element in `arr` for which to return an index. UInt64.\n",
      "returnedValue": "Returns the index (numbered from one) of the first `x` in `arr` if it exists. Otherwise, returns `0`.",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT indexOf([5, 4, 1, 3], 3)\n```\n\n```response title=Response\n4\n```\n\n**Array with nulls**\n\n```sql title=Query\nSELECT indexOf([1, 3, NULL, NULL], NULL)\n```\n\n```response title=Response\n3\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "indexOfAssumeSorted",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "indexOfAssumeSorted(arr, x)",
      "description": "\nReturns the index of the first element with value 'x' (starting from `1`) if it is in the array.\nIf the array does not contain the searched-for value, the function returns `0`.\n\n:::note\nUnlike the `indexOf` function, this function assumes that the array is sorted in\nascending order. If the array is not sorted, results are undefined.\n:::\n    ",
      "arguments": "- `arr` — A sorted array to search. [`Array(T)`](/sql-reference/data-types/array).\n- `x` — Value of the first matching element in sorted `arr` for which to return an index.UInt64\n",
      "returnedValue": "Returns the index (numbered from one) of the first `x` in `arr` if it exists. Otherwise, returns `0`.",
      "examples": "**Basic example**\n\n```sql title=Query\nSELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)\n```\n\n```response title=Response\n5\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "initcap",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "initcapUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "initialQueryID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "initialQueryStartTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "initialQueryStartTime()",
      "description": "Returns the start time of the initial current query.",
      "arguments": "",
      "returnedValue": "Start time of the initial query.",
      "examples": "**simple**\n\n```sql title=Query\nSELECT initialQueryStartTime()\n```\n\n```response title=Response\n2025-01-28 11:38:04\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "initial_query_id",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "initialQueryID",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "initial_query_start_time",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "initialQueryStartTime",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "initializeAggregation",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "instr",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "positionCaseInsensitive",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intDiv",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "intDiv(x, y)",
      "description": "\nPerforms an integer division of two values `x` by `y`. In other words it\ncomputes the quotient rounded down to the next smallest integer.\n\nThe result has the same width as the dividend (the first parameter).\n\nAn exception is thrown when dividing by zero, when the quotient does not fit\nin the range of the dividend, or when dividing a minimal negative number by minus one.\n    ",
      "arguments": "- `x` — Left hand operand.\n- `y` — Right hand operand.\n",
      "returnedValue": "Result of integer division of `x` and `y`",
      "examples": "**Integer division of two floats**\n\n```sql title=Query\nSELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)\n```\n\n```response title=Response\n┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐\n│ 1000 │ Int64                                   │\n└──────┴─────────────────────────────────────────┘\n```\n\n**Quotient does not fit in the range of the dividend**\n\n```sql title=Query\nSELECT\nintDiv(1, 0.001) AS res,\ntoTypeName(res)\n```\n\n```response title=Response\nReceived exception from server (version 23.2.1):\nCode: 153. DB::Exception: Received from localhost:9000. DB::Exception:\nCannot perform integer division, because it will produce infinite or too\nlarge number: While processing intDiv(1, 0.001) AS res, toTypeName(res).\n(ILLEGAL_DIVISION)\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "intDivOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "intDivOrNull(x, y)",
      "description": "\nSame as `intDiv` but returns NULL when dividing by zero or when dividing a\nminimal negative number by minus one.\n    ",
      "arguments": "- `x` — Left hand operand.\n- `y` — Right hand operand.\n",
      "returnedValue": "Result of integer division of `x` and `y`, or NULL.",
      "examples": "**Integer division by zero**\n\n```sql title=Query\nSELECT intDivOrNull(1, 0)\n```\n\n```response title=Response\n\\N\n```\n\n**Dividing a minimal negative number by minus 1**\n\n```sql title=Query\nSELECT intDivOrNull(-9223372036854775808, -1)\n```\n\n```response title=Response\n\\N\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "intDivOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "intDivOrZero(a, b)",
      "description": "\nSame as `intDiv` but returns zero when dividing by zero or when dividing a\nminimal negative number by minus one.\n    ",
      "arguments": "- `a` — Left hand operand.\n- `b` — Right hand operand.\n",
      "returnedValue": "Result of integer division of a and b, or zero.",
      "examples": "**Integer division by zero**\n\n```sql title=Query\nSELECT intDivOrZero(1, 0)\n```\n\n```response title=Response\n0\n```\n\n**Dividing a minimal negative number by minus 1**\n\n```sql title=Query\nSELECT intDivOrZero(0.05, -1)\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "intExp10",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intExp2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intHash32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSum",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isConstant",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isDecimalOverflow",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isDynamicElementInSharedData",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "isDynamicElementInSharedData(dynamic)",
      "description": "\nReturns true for rows in Dynamic column that are not separated into subcolumns and stored inside shared variant in binary form.\n",
      "arguments": "- `dynamic` — Dynamic column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;\nINSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);\nSELECT d, isDynamicElementInSharedData(d) FROM test;\n```\n\n```response title=Response\n┌─d─────────────┬─isDynamicElementInSharedData(d)─┐\n│ ᴺᵁᴸᴸ          │ false              │\n│ 42            │ false              │\n│ Hello, World! │ true               │\n│ [1,2,3]       │ true               │\n└───────────────┴────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "isFinite",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "isFinite(x)",
      "description": "\nReturns `1` if the Float32 or Float64 argument not infinite and not a `NaN`,\notherwise this function returns `0`.\n    ",
      "arguments": "- `x` — Number to check for finiteness. Float32 or Float64.\n",
      "returnedValue": "`1` if x is not infinite and not `NaN`, otherwise `0`.",
      "examples": "**Test if a number is finite**\n\n```sql title=Query\nSELECT isFinite(inf)\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "isIPAddressInRange",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isIPv4String",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isIPv6String",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isInfinite",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "isInfinite(x)",
      "description": "\n    Returns `1` if the Float32 or Float64 argument is infinite, otherwise this function returns `0`.\n    Note that `0` is returned for a `NaN`.\n    ",
      "arguments": "- `x` — Number to check for infiniteness. Float32 or Float64.\n",
      "returnedValue": "`1` if x is infinite, otherwise `0` (including for `NaN`).",
      "examples": "**Test if a number is infinite**\n\n```sql title=Query\nSELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))\n```\n\n```response title=Response\n1 0 0\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "isMergeTreePartCoveredBy",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Checks if one MergeTree part covers another",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Introspection"
    },
    {
      "name": "isNaN",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "isNaN(x)",
      "description": "Returns `1` if the Float32 and Float64 argument is `NaN`, otherwise returns `0`.",
      "arguments": "- `x` — Argument to evaluate for if it is `NaN`\n",
      "returnedValue": "`1` if `NaN`, otherwise `0`",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT isNaN(NaN)\n```\n\n```response title=Response\n1\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "isNotDistinctFrom",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nPerforms a null-safe comparison between two values. This function will consider\ntwo `NULL` values as identical and will return `true`, which is distinct from the usual\nequals behavior where comparing two `NULL` values would return `NULL`.\n\nCurrently, this function can only be used in the `JOIN ON` section of a query.\n[example:join_on_is_not_distinct_from]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**join_on_is_not_distinct_from**\n\n```sql title=Query\nSELECT * FROM (SELECT NULL AS a) AS t1 JOIN (SELECT NULL AS b) AS t2 ON isNotDistinctFrom(t1.a, t2.b)\n```\n\n```response title=Response\nNULL\tNULL\n```\n\n",
      "categories": "Nullable"
    },
    {
      "name": "isNotNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isNull",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isNullable",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isValidJSON",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isValidUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "isZeroOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "jaroSimilarity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the Jaro similarity between two byte-string.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "jaroWinklerSimilarity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the Jaro-Winkler similarity between two byte-string.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "javaHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "javaHashUTF16LE",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "joinGet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "joinGetOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "jsonMergePatch",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "JSONMergePatch",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "jumpConsistentHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kafkaMurmurHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "keccak256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "SELECT keccak256(message)",
      "description": "Calculates the Keccak-256 cryptographic hash of the given string.\n        This hash function is widely used in blockchain applications, particularly Ethereum.",
      "arguments": "- `message` — The input [String](../../sql-reference/data-types/string.md).\n",
      "returnedValue": "A [FixedString(32)](../../sql-reference/data-types/fixedstring.md) containing the 32-byte Keccak-256 hash of the input string.",
      "examples": "****\n\n```sql title=Query\nSELECT hex(keccak256('hello'))\n```\n\n```response title=Response\n┌─hex(keccak256('hello'))──────────────────────────────────────────┐\n│ 1C8AFF950685C2ED4BC3174F3472287B56D9517B9C948127319A09A7A36DEAC8 │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "kolmogorovSmirnovTest",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kostikConsistentHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kql_array_sort_asc",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kql_array_sort_desc",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPop",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSamp",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lag",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrame",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBuckets",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lastValueRespectNulls",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "anyLast_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "last_value",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "anyLast",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "last_value_respect_nulls",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "anyLast_respect_nulls",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lcase",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "lower",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lcm",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "lcm(x, y)",
      "description": "\nReturns the least common multiple of two values `x` and `y`.\n\nAn exception is thrown when dividing by zero or when dividing a minimal negative number by minus one.\n    ",
      "arguments": "- `x` — First integer\n- `y` — Second integer\n",
      "returnedValue": "The least common multiple of `x` and `y`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT lcm(6, 8)\n```\n\n```response title=Response\n24\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "lead",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrame",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "least",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "least(x1[, x2, ..., xN])",
      "description": "\nReturns the smallest value among the arguments.\n\n- For arrays, returns the lexicographically least array.\n- For DateTime types, the result type is promoted to the largest type (e.g., DateTime64 if mixed with DateTime32).\n    ",
      "arguments": "- `x1[, x2, ..., xN]` — One or multiple values to compare. All arguments must be of comparable types.\n",
      "returnedValue": "The least value among the arguments, promoted to the largest compatible type.",
      "examples": "**Numeric types**\n\n```sql title=Query\nSELECT least(1, 2, toUInt8(3), 3.) AS result, toTypeName(result) AS type;\n-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.\n```\n\n```response title=Response\n┌─result─┬─type────┐\n│      1 │ Float64 │\n└────────┴─────────┘\n```\n\n**Arrays**\n\n```sql title=Query\nSELECT least(['hello'], ['there'], ['world']);\n```\n\n```response title=Response\n┌─least(['hell⋯ ['world'])─┐\n│ ['hello']                │\n└──────────────────────────┘\n```\n\n**DateTime types**\n\n```sql title=Query\nSELECT least(toDateTime32(now() + toIntervalDay(1)), toDateTime64(now(), 3));\n-- The type returned is a DateTime64 as the DateTime32 must be promoted to 64 bit for the comparison.\n```\n\n```response title=Response\n┌─least(toDate⋯(now(), 3))─┐\n│  2025-05-27 15:55:20.000 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Conditional"
    },
    {
      "name": "left",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leftPad",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leftPadUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leftUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lemmatize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "length",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "length(x)",
      "description": "\nCalculates the length of a string or array.\n\n- For String or FixedString arguments: calculates the number of bytes in the string.\n- For Array arguments: calculates the number of elements in the array.\n- If applied to a FixedString argument, the function is a constant expression.\n\nPlease note that the number of bytes in a string is not the same as the number of\nUnicode \"code points\" and it is not the same as the number of Unicode \"grapheme clusters\"\n(what we usually call \"characters\") and it is not the same as the visible string width.\n\nIt is ok to have ASCII NUL bytes in strings, and they will be counted as well.\n    ",
      "arguments": "- `x` — String, FixedString or Array for which to calculate the number of bytes (for String/FixedString) or elements (for Array).\n",
      "returnedValue": "Returns the number of number of bytes in the String/FixedString `x` / the number of elements in array `x`",
      "examples": "**string1**\n\n```sql title=Query\nSELECT length('Hello, world!')\n```\n\n```response title=Response\n13\n```\n\n**arr1**\n\n```sql title=Query\nSELECT length(['Hello', 'world'])\n```\n\n```response title=Response\n2\n```\n\n**constexpr**\n\n```sql title=Query\nWITH 'hello' || toString(number) AS str\nSELECT str,\nisConstant(length(str)) AS str_length_is_constant,\nisConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant\nFROM numbers(3)\n```\n\n```response title=Response\n┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐\n│ hello0 │                      0 │                            1 │\n│ hello1 │                      0 │                            1 │\n│ hello2 │                      0 │                            1 │\n└────────┴────────────────────────┴──────────────────────────────┘\n```\n\n**unicode**\n\n```sql title=Query\nSELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)\n```\n\n```response title=Response\n┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐\n│ ёлка │            8 │                4 │ ёлка │           10 │                5 │\n└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘\n```\n\n**ascii_vs_utf8**\n\n```sql title=Query\nSELECT 'ábc' AS str, length(str), lengthUTF8(str)\n```\n\n```response title=Response\n┌─str─┬─length(str)──┬─lengthUTF8(str)─┐\n│ ábc │            4 │               3 │\n└─────┴──────────────┴─────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "lengthUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "less",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "less(a, b)\n    -- a < b",
      "description": "Compares two values for less-than relation.",
      "arguments": "- `a` — First value.<sup>[*](#comparison-rules)</sup>\n- `b` — Second value.<sup>[*](#comparison-rules)</sup>\n",
      "returnedValue": "Returns `1` if `a` is less than `b`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 1 < 2, 2 < 1;\n```\n\n```response title=Response\n┌─less(1, 2)─┬─less(2, 1)─┐\n│          1 │          0 │\n└────────────┴────────────┘\n```\n\n",
      "categories": "Comparison"
    },
    {
      "name": "lessOrEquals",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "lessOrEquals(a, b)\n    -- a <= b",
      "description": "Compares two values for less-than-or-equal-to relation.",
      "arguments": "- `a` — First value.<sup>[*](#comparison-rules)</sup>\n- `b` — Second value.<sup>[*](#comparison-rules)</sup>\n",
      "returnedValue": "Returns `1` if `a` is less than or equal to `b`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 1 <= 2, 2 <= 2, 3 <= 2;\n```\n\n```response title=Response\n┌─lessOrEquals(1, 2)─┬─lessOrEquals(2, 2)─┬─lessOrEquals(3, 2)─┐\n│                  1 │                  1 │                  0 │\n└────────────────────┴────────────────────┴────────────────────┘\n```\n\n",
      "categories": "Comparison"
    },
    {
      "name": "levenshteinDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "editDistance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "levenshteinDistanceUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "editDistanceUTF8",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lgamma",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "like",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ln",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "log",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "locate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "location(needle, haystack[, start_pos])",
      "description": "Like function `position` but with arguments `haystack` and `locate` switched. The behavior of this function depends on the ClickHouse version: In versions < v24.3, `locate` was an alias of function `position` and accepted arguments `(haystack, needle[, start_pos])`. In versions >= 24.3,, `locate` is an individual function (for better compatibility with MySQL) and accepts arguments `(needle, haystack[, start_pos])`. The previous behavior can be restored using setting `function_locate_has_mysql_compatible_argument_order = false`.",
      "arguments": "- `needle` — Substring to be searched (String)\n- `haystack` — String in which the search is performed (String).\n- `start_pos` — Position (1-based) in `haystack` at which the search starts (UInt*).\n",
      "returnedValue": "Starting position in bytes and counting from 1, if the substring was found. 0, if the substring was not found.",
      "examples": "**Example**\n\n```sql title=Query\nSELECT locate('abcabc', 'ca');\n```\n\n```response title=Response\n3\n```\n\n",
      "categories": "String Search"
    },
    {
      "name": "log",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "log10",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "log1p",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "log2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "logTrace",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lowCardinalityIndices",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lowCardinalityKeys",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lower",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lowerUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "lowerUTF8(input)",
      "description": "Converts a string to lowercase, assuming that the string contains valid UTF-8 encoded text. If this assumption is violated, no exception is thrown and the result is undefined.",
      "arguments": "- `input` — Input with String type\n",
      "returnedValue": "A String data type value",
      "examples": "**first**\n\n```sql title=Query\nSELECT lowerUTF8('München') as Lowerutf8;\n```\n\n```response title=Response\nmünchen\n```\n\n",
      "categories": "String"
    },
    {
      "name": "lpad",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "leftPad",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ltrim",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "trimLeft",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lttb",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "largestTriangleThreeBuckets",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "makeDate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "makeDate(year, month, day)\nmakeDate(year, day_of_year)",
      "description": "\nCreates a `Date` from either:\n- a year, month and day\n- a year and day of year\n    ",
      "arguments": "- `year` — Year number. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `month` — Month number (1-12). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `day` — Day of the month (1-31). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `day_of_year` — Day of the year (1-365). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n",
      "returnedValue": "Returns a `Date` value constructed from the provided arguments. [`Date`](../data-types/date.md).",
      "examples": "**Date from a year, month, day**\n\n```sql title=Query\nSELECT makeDate(2023, 2, 28) AS date;\n```\n\n```response title=Response\n┌───────date─┐\n│ 2023-02-28 │\n└────────────┘\n```\n\n**Date from year and day of year**\n\n```sql title=Query\nSELECT makeDate(2023, 42) AS date;\n```\n\n```response title=Response\n┌───────date─┐\n│ 2023-02-11 │\n└────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "makeDate32",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "makeDate32(year, month, day)\nmakeDate32(year, day_of_year)",
      "description": "\nCreates a `Date32` from either:\n- a year, month and day\n- a year and day of year\n    ",
      "arguments": "- `year` — Year number. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `month` — Month number (1-12). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `day` — Day of the month (1-31). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `day_of_year` — Day of the year (1-365). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n",
      "returnedValue": "Returns a `Date32` value constructed from the provided arguments. [`Date32`](../data-types/date32.md).",
      "examples": "**Date32 from a year, month, day**\n\n```sql title=Query\nSELECT makeDate(2023, 2, 28) AS date;\n```\n\n```response title=Response\n┌───────date─┐\n│ 2023-02-28 │\n└────────────┘\n```\n\n**Date32 from year and day of year**\n\n```sql title=Query\nSELECT makeDate(2023, 42) AS date;\n```\n\n```response title=Response\n┌───────date─┐\n│ 2023-02-11 │\n└────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "makeDateTime",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "makeDateTime(year, month, day, hour, minute, second[, timezone])",
      "description": "\nCreates a `DateTime` from year, month, day, hour, minute, and second, with optional timezone.\n    ",
      "arguments": "- `year` — Year number. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `month` — Month number (1-12). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `day` — Day of the month (1-31). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `hour` — Hour (0-23). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `minute` — Minute (0-59). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `second` — Second (0-59). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `timezone` — Optional. Timezone name. [`String`](../data-types/string.md).\n",
      "returnedValue": "Returns a `DateTime` value constructed from the provided arguments. [`DateTime`](../data-types/datetime.md).",
      "examples": "**DateTime from year, month, day, hour, minute, second**\n\n```sql title=Query\nSELECT makeDateTime(2023, 2, 28, 17, 12, 33) AS DateTime;\n```\n\n```response title=Response\n┌────────────DateTime─┐\n│ 2023-02-28 17:12:33 │\n└─────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "makeDateTime64",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "makeDateTime64(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])",
      "description": "\nCreates a `DateTime64` from year, month, day, hour, minute, second, with optional fraction, precision, and timezone.\n    ",
      "arguments": "- `year` — Year number. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `month` — Month number (1-12). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `day` — Day of the month (1-31). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `hour` — Hour (0-23). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `minute` — Minute (0-59). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `second` — Second (0-59). [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `fraction` — Optional. Fractional part of the second. [`(U)Int*`](../data-types/int-uint.md)/[`Float32/64`](../data-types/float.md)/[`Decimal`](../data-types/decimal.md).\n- `precision` — Optional. Precision for the fractional part (0-9). [`UInt8`](../data-types/int-uint.md).\n- `timezone` — Optional. Timezone name. [`String`](../data-types/string.md).\n",
      "returnedValue": "Returns a `DateTime64` value constructed from the provided arguments. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**DateTime64 from year, month, day, hour, minute, second**\n\n```sql title=Query\nSELECT makeDateTime64(2023, 5, 15, 10, 30, 45, 779, 5);\n```\n\n```response title=Response\n┌─makeDateTime64(2023, 5, 15, 10, 30, 45, 779, 5)─┐\n│                       2023-05-15 10:30:45.00779 │\n└─────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "mannWhitneyUTest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "map",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapAdd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayAll.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapAll**\n\n```sql title=Query\nSELECT mapAll((k, v) -> v = 1, map('k1', 1, 'k2', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapApply",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayMap.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapApply**\n\n```sql title=Query\nSELECT mapApply((k, v) -> (k, v * 2), map('k1', 1, 'k2', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapConcat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayConcat.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapConcat**\n\n```sql title=Query\nSELECT mapConcat(map('k1', 'v1'), map('k2', 'v2'))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapContains",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "mapContainsKey",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapContainsKey",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Checks whether the map has the specified key.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapContainsKey**\n\n```sql title=Query\nSELECT mapContainsKey(map('k1', 'v1', 'k2', 'v2'), 'k1')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapContainsKeyLike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Checks whether map contains key LIKE specified pattern.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapContainsKeyLike**\n\n```sql title=Query\nSELECT mapContainsKeyLike(map('k1-1', 1, 'k2-1', 2), 'k1%')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapContainsValue",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Checks whether the map has the specified value.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapContainsValue**\n\n```sql title=Query\nSELECT mapContainsValue(map('k1', 'v1', 'k2', 'v2'), 'v1')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapContainsValueLike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Checks whether map contains value LIKE specified pattern.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapContainsValueLike**\n\n```sql title=Query\nSELECT mapContainsValueLike(map(1, 'v1-1', '2, 'v2-2'), 'v1%')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapExists",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayExists.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapExists**\n\n```sql title=Query\nSELECT mapExists((k, v) -> v = 1, map('k1', 1, 'k2', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapExtractKeyLike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns a map with elements which key matches the specified pattern.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapExtractKeyLike**\n\n```sql title=Query\nSELECT mapExtractKeyLike(map('k1-1', 1, 'k2-1', 2), 'k1%')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapExtractValueLike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns a map with elements which value matches the specified pattern.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapExtractValueLike**\n\n```sql title=Query\nSELECT mapExtractValueLike(map('k1-1', 'v1-1', 'k2-1', 'v2-1'), 'v1%')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapFilter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayFilter.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapFilter**\n\n```sql title=Query\nSELECT mapFilter((k, v) -> v > 1, map('k1', 1, 'k2', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapFromArrays",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapFromString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "extractKeyValuePairs",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapKeys",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns an array with the keys of map.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapKeys**\n\n```sql title=Query\nSELECT mapKeys(map('k1', 'v1', 'k2', 'v2'))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapPartialReverseSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayPartialReverseSort.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapPartialReverseSort**\n\n```sql title=Query\nSELECT mapPartialReverseSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapPartialSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayReverseSort.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapPartialSort**\n\n```sql title=Query\nSELECT mapPartialSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapPopulateSeries",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapReverseSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arrayReverseSort.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapReverseSort**\n\n```sql title=Query\nSELECT mapReverseSort((k, v) -> v, map('k1', 3, 'k2', 1, 'k3', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapSort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "The same as arraySort.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapSort**\n\n```sql title=Query\nSELECT mapSort((k, v) -> v, map('k1', 3, 'k2', 1, 'k3', 2))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "mapSubtract",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapUpdate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mapValues",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns an array with the values of map.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**mapValues**\n\n```sql title=Query\nSELECT mapValues(map('k1', 'v1', 'k2', 'v2'))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Map"
    },
    {
      "name": "match",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "materialize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "max",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "max2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "max2(x, y)",
      "description": "\n    Returns the bigger of two numeric values `x` and `y`. The returned value is of type Float64.\n    ",
      "arguments": "- `x` — First value\n- `y` — Second value\n",
      "returnedValue": "Returns the bigger value of `x` and `y`",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT max2(-1, 2)\n```\n\n```response title=Response\n2\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "maxIntersections",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPosition",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArrays",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "median",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantile",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianBFloat16",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileBFloat16",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianBFloat16Weighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileBFloat16Weighted",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianDD",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileDD",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianDeterministic",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileDeterministic",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianExact",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileExact",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianExactHigh",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileExactHigh",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianExactLow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileExactLow",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianExactWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileExactWeighted",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianExactWeightedInterpolated",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileExactWeightedInterpolated",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianGK",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileGK",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianInterpolatedWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileInterpolatedWeighted",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianTDigest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileTDigest",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianTDigestWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileTDigestWeighted",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianTiming",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileTiming",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "medianTimingWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "quantileTimingWeighted",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mergeTreePartInfo",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Represents String value as a MergeTreePartInfo structure",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Introspection"
    },
    {
      "name": "metroHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mid",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "substring",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "min",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "min2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "min2(x, y)",
      "description": "\n    Returns the smaller of two numeric values `x` and `y`. The returned value is of type Float64.\n    ",
      "arguments": "- `x` — First value\n- `y` — Second value\n",
      "returnedValue": "Returns the smaller value of `x` and `y`",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT min2(-1, 2)\n```\n\n```response title=Response\n-1\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "minMappedArrays",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minSampleSizeContinous",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "minSampleSizeContinuous",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minSampleSizeContinuous",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minSampleSizeConversion",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minus",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "minus(x, y)",
      "description": "\nCalculates the difference of two values `a` and `b`. The result is always signed.\nSimilar to plus, it is possible to subtract an integer from a date or date with time.\nAdditionally, subtraction between date with time is supported, resulting in the time difference between them.\n    ",
      "arguments": "- `x` — Minuend\n- `y` — Subtrahend\n",
      "returnedValue": "x minus y",
      "examples": "**Subtracting two numbers**\n\n```sql title=Query\nSELECT minus(10,5)\n```\n\n```response title=Response\n5\n```\n\n**Subtracting an integer and a date**\n\n```sql title=Query\nSELECT minus(toDate('2025-01-01'),5)\n```\n\n```response title=Response\n2024-12-27\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "mismatches",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "byteHammingDistance",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mod",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "modulo",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "modOrNull",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "moduloOrNull",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "modulo",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "modulo(a, b)",
      "description": "\n    Calculates the remainder of the division of two values a by b.\n\n    The result type is an integer if both inputs are integers. If one of the\n    inputs is a floating-point number, the result type is Float64.\n\n    The remainder is computed like in C++. Truncated division is used for\n    negative numbers.\n\n    An exception is thrown when dividing by zero or when dividing a minimal\n    negative number by minus one.\n    ",
      "arguments": "- `a` — The dividend\n- `b` — The divisor (modulus)\n",
      "returnedValue": "The remainder of a % b",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT modulo(5, 2)\n```\n\n```response title=Response\n1\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "moduloLegacy",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "moduloOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "moduloOrNull(x, y)",
      "description": "\nCalculates the remainder when dividing `a` by `b`. Similar to function `modulo` except that `moduloOrNull` will return NULL\nif the right argument is 0.\n    ",
      "arguments": "- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `y` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the remainder of the division of `x` by `y`, or null when the divisor is zero.",
      "examples": "**moduloOrNull by zero**\n\n```sql title=Query\nSELECT moduloOrNull(5, 0)\n```\n\n```response title=Response\n\\N\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "moduloOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "moduloOrZero(a, b)",
      "description": "\nLike modulo but returns zero when the divisor is zero, as opposed to an\nexception with the modulo function.\n    ",
      "arguments": "- `a` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `b` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "The remainder of a % b, or `0` when the divisor is `0`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT moduloOrZero(5, 0)\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "monthName",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mortonDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nDecodes a Morton encoding (ZCurve) into the corresponding unsigned integer tuple\n\nThe function has two modes of operation:\n- Simple\n- Expanded\n\nSimple: accepts a resulting tuple size as a first argument and the code as a second argument.\n[example:simple]\nWill decode into: `(1,2,3,4)`\nThe resulting tuple size cannot be more than 8\n\nExpanded: accepts a range mask (tuple) as a first argument and the code as a second argument.\nEach number in mask configures the amount of range shrink\n1 - no shrink\n2 - 2x shrink\n3 - 3x shrink\n....\nUp to 8x shrink.\n[example:range_shrank]\nNote: see mortonEncode() docs on why range change might be beneficial.\nStill limited to 8 numbers at most.\n\nMorton code for one argument is always the argument itself (as a tuple).\n[example:identity]\nProduces: `(1)`\n\nYou can shrink one argument too:\n[example:identity_shrank]\nProduces: `(128)`\n\nThe function accepts a column of codes as a second argument:\n[example:from_table]\n\nThe range tuple must be a constant:\n[example:from_table_range]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**simple**\n\n```sql title=Query\nSELECT mortonDecode(4, 2149)\n```\n\n```response title=Response\n\n```\n\n**range_shrank**\n\n```sql title=Query\nSELECT mortonDecode((1,2), 1572864)\n```\n\n```response title=Response\n\n```\n\n**identity**\n\n```sql title=Query\nSELECT mortonDecode(1, 1)\n```\n\n```response title=Response\n\n```\n\n**identity_shrank**\n\n```sql title=Query\nSELECT mortonDecode(tuple(2), 32768)\n```\n\n```response title=Response\n\n```\n\n**from_table**\n\n```sql title=Query\nSELECT mortonDecode(2, code) FROM table\n```\n\n```response title=Response\n\n```\n\n**from_table_range**\n\n```sql title=Query\nSELECT mortonDecode((1,2), code) FROM table\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "mortonEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nCalculates Morton encoding (ZCurve) for a list of unsigned integers\n\nThe function has two modes of operation:\n- Simple\n- Expanded\n\nSimple: accepts up to 8 unsigned integers as arguments and produces a UInt64 code.\n[example:simple]\n\nExpanded: accepts a range mask (tuple) as a first argument and up to 8 unsigned integers as other arguments.\nEach number in mask configures the amount of range expansion\n1 - no expansion\n2 - 2x expansion\n3 - 3x expansion\n....\nUp to 8x expansion.\n[example:range_expanded]\nNote: tuple size must be equal to the number of the other arguments\n\nRange expansion can be beneficial when you need a similar distribution for arguments with wildly different ranges (or cardinality)\nFor example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF)\n\nMorton encoding for one argument is always the argument itself.\n[example:identity]\nProduces: `1`\n\nYou can expand one argument too:\n[example:identity_expanded]\nProduces: `32768`\n\nThe function also accepts columns as arguments:\n[example:from_table]\n\nBut the range tuple must still be a constant:\n[example:from_table_range]\n\nPlease note that you can fit only so much bits of information into Morton code as UInt64 has.\nTwo arguments will have a range of maximum 2^32 (64/2) each\nThree arguments: range of max 2^21 (64/3) each\nAnd so on, all overflow will be clamped to zero\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**simple**\n\n```sql title=Query\nSELECT mortonEncode(1, 2, 3)\n```\n\n```response title=Response\n\n```\n\n**range_expanded**\n\n```sql title=Query\nSELECT mortonEncode((1,2), 1024, 16)\n```\n\n```response title=Response\n\n```\n\n**identity**\n\n```sql title=Query\nSELECT mortonEncode(1)\n```\n\n```response title=Response\n\n```\n\n**identity_expanded**\n\n```sql title=Query\nSELECT mortonEncode(tuple(2), 128)\n```\n\n```response title=Response\n\n```\n\n**from_table**\n\n```sql title=Query\nSELECT mortonEncode(n1, n2) FROM table\n```\n\n```response title=Response\n\n```\n\n**from_table_range**\n\n```sql title=Query\nSELECT mortonEncode((1,2), n1, n2) FROM table\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "multiFuzzyMatchAllIndices",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiFuzzyMatchAny",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiFuzzyMatchAnyIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiIf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "multiIf(cond_1, then_1, cond_2, then_2, ..., else)",
      "description": "\nAllows writing the [`CASE`](/sql-reference/operators#conditional-expression) operator more compactly in the query.\nEvaluates each condition in order. For the first condition that is true (non-zero and not `NULL`), returns the corresponding branch value.\nIf none of the conditions are true, returns the `else` value.\n\nSetting [`short_circuit_function_evaluation`](/operations/settings/settings#short_circuit_function_evaluation) controls\nwhether short-circuit evaluation is used. If enabled, the `then_i` expression is evaluated only on rows where\n`((NOT cond_1) AND ... AND (NOT cond_{i-1}) AND cond_i)` is true.\n\nFor example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the following query:\n\n```sql\nSELECT multiIf(number = 2, intDiv(1, number), number = 5) FROM numbers(10)\n```\n\nAll branch and else expressions must have a common supertype. `NULL` conditions are treated as false.\n    ",
      "arguments": "- `cond_N` — The N-th evaluated condition which controls if `then_N` is returned. Each must be UInt8, Nullable(UInt8), or NULL.\n- `then_N` — The result of the function when `cond_N` is true.\n- `else` — The result of the function if none of the conditions is true.\n",
      "returnedValue": "Returns the result of `then_N` for matching `cond_N`, otherwise returns the `else` condition.",
      "examples": "**Example usage**\n\n```sql title=Query\nCREATE TABLE LEFT_RIGHT (left Nullable(UInt8), right Nullable(UInt8)) ENGINE = Memory;\nINSERT INTO LEFT_RIGHT VALUES (NULL, 4), (1, 3), (2, 2), (3, 1), (4, NULL);\n\nSELECT\n    left,\n    right,\n    multiIf(left < right, 'left is smaller', left > right, 'left is greater', left = right, 'Both equal', 'Null value') AS result\nFROM LEFT_RIGHT;\n```\n\n```response title=Response\n┌─left─┬─right─┬─result──────────┐\n│ ᴺᵁᴸᴸ │     4 │ Null value      │\n│    1 │     3 │ left is smaller │\n│    2 │     2 │ Both equal      │\n│    3 │     1 │ left is greater │\n│    4 │  ᴺᵁᴸᴸ │ Null value      │\n└──────┴───────┴─────────────────┘\n```\n\n",
      "categories": "Conditional"
    },
    {
      "name": "multiMatchAllIndices",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiMatchAny",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiMatchAnyIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAllPositions",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAllPositionsCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAllPositionsCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAllPositionsUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAny",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAnyCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAnyCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchAnyUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstIndexCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstIndexCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstIndexUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstPosition",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstPositionCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstPositionCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiSearchFirstPositionUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "multiply",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "multiply(x, y)",
      "description": "Calculates the product of two values `x` and `y`.",
      "arguments": "- `x` — factor\n- `y` — factor\n",
      "returnedValue": "The product of x and y",
      "examples": "**Multiplying two numbers**\n\n```sql title=Query\nSELECT multiply(5,5)\n```\n\n```response title=Response\n25\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "multiplyDecimal",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "multiplyDecimal(a, b[, result_scale])",
      "description": "\nPerforms multiplication on two decimals. Result value will be of type [Decimal256](/sql-reference/data-types/decimal).\nResult scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.\n\n:::note\nThese functions work significantly slower than usual `multiply`.\nIn case you don't really need controlled precision and/or need fast computation, consider using [multiply](#multiply)\n:::\n    ",
      "arguments": "- `a` — First value. Type [Decimal](/sql-reference/data-types/decimal).\n- `b` — Second value. Type [Decimal](/sql-reference/data-types/decimal).\n- `result_scale` — Scale of result. Type [Int/UInt](/sql-reference/data-types/int-uint).\n",
      "returnedValue": "The result of multiplication with the given scale. Type: [Decimal256](/sql-reference/data-types/decimal).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)\n```\n\n```response title=Response\n25.2\n```\n\n**Difference with regular multiplication**\n\n```sql title=Query\nSELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)\n```\n\n```response title=Response\n┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐\n│                                               -26.8609633 │\n└───────────────────────────────────────────────────────────┘\n┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐\n│                                                         -26.8609 │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n**Decimal overflow**\n\n```sql title=Query\nSELECT\n    toDecimal64(-12.647987876, 9) AS a,\n    toDecimal64(123.967645643, 9) AS b,\n    multiplyDecimal(a, b);\nSELECT\n    toDecimal64(-12.647987876, 9) AS a,\n    toDecimal64(123.967645643, 9) AS b,\n    a * b;\n```\n\n```response title=Response\n┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐\n│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │\n└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘\nReceived exception from server (version 22.11.1):\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow:\nWhile processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "murmurHash2_32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "murmurHash2_64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "murmurHash3_128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "murmurHash3_32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "murmurHash3_64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "negate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "negate(x)",
      "description": "Negates the argument `x`. The result is always signed.",
      "arguments": "- `x` — The value to negate.\n",
      "returnedValue": "Returns -x from x",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT negate(10)\n```\n\n```response title=Response\n-10\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "neighbor",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nested",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nThis is a function used internally by the ClickHouse engine and not meant to be used directly.\n\nReturns the array of tuples from multiple arrays.\n\nThe first argument must be a constant array of Strings determining the names of the resulting Tuple.\nThe other arguments must be arrays of the same size.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**nested**\n\n```sql title=Query\nSELECT nested(['keys', 'values'], ['key_1', 'key_2'], ['value_1','value_2'])\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "netloc",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramDistanceCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramDistanceCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramDistanceUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashArg",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashArgCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashArgCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashArgUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramMinHashUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSearch",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSearchCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSearchCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSearchUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSimHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSimHashCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSimHashCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngramSimHashUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ngrams",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Splits a UTF-8 string into n-grams symbols.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Splitting"
    },
    {
      "name": "nonNegativeDerivative",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normL1",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L1Norm",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normL2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L2Norm",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normL2Squared",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L2SquaredNorm",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normLinf",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "LinfNorm",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normLp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "LpNorm",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeL1",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L1Normalize",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeL2",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "L2Normalize",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeLinf",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "LinfNormalize",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeLp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "LpNormalize",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeQuery",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeQueryKeepNames",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeUTF8NFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeUTF8NFD",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeUTF8NFKC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizeUTF8NFKD",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizedQueryHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "normalizedQueryHashKeepNames",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "not",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "notEmpty",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "notEmpty(arr)",
      "description": "\nChecks whether the input array is non-empty.\n\nAn array is considered non-empty if it contains at least one element.\n\n:::note\nCan be optimized by enabling the [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns) setting. With `optimize_functions_to_subcolumns = 1` the function reads only [size0](/sql-reference/data-types/array#array-size) subcolumn instead of reading and processing the whole array column. The query `SELECT notEmpty(arr) FROM table` transforms to `SELECT arr.size0 != 0 FROM TABLE`.\n:::\n\nThe function also works for [strings](string-functions.md#notempty) or [UUID](uuid-functions.md#notempty).\n    ",
      "arguments": "- `arr` — Input array. [`Array(T)`](/sql-reference/data-types/array).\n",
      "returnedValue": "Returns `1` for a non-empty array or `0` for an empty array. [`UInt8`](../data-types/int-uint.md).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT notEmpty([1,2]);\n```\n\n```response title=Response\n1\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "notEquals",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "notEquals(a, b)\n    -- a != b\n    -- a <> b",
      "description": "Compares two values for inequality.",
      "arguments": "- `a` — First value.<sup>[*](#comparison-rules)</sup>\n- `b` — Second value.<sup>[*](#comparison-rules)</sup>\n",
      "returnedValue": "Returns `1` if `a` is not equal to `b`, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint/)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT 1 != 2, 1 != 1;\n```\n\n```response title=Response\n┌─notEquals(1, 2)─┬─notEquals(1, 1)─┐\n│               1 │               0 │\n└─────────────────┴─────────────────┘\n```\n\n",
      "categories": "Comparison"
    },
    {
      "name": "notILike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "notIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "notInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "notLike",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "notNullIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "notNullInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothing",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "now",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "now64",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nowInBlock",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_value",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntile",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nullIf",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nullIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nullInIgnoreSet",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "or",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "overlay",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReplace a part of a string `input` with another string `replace`, starting at 1-based index `offset`. By default, the number of bytes removed from `input` equals the length of `replace`. If `length` (the optional fourth argument) is specified, a different number of bytes is removed.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Replacement"
    },
    {
      "name": "overlayUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReplace a part of a string `input` with another string `replace`, starting at 1-based index `offset`. By default, the number of characters removed from `input` equals the length of `replace`. If `length` (the optional fourth argument) is specified, a different number of characters is removed.\n\nAssumes that the string contains valid UTF-8 encoded text. If this assumption is violated, no exception is thrown and the result is undefined.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Replacement"
    },
    {
      "name": "parseDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime32BestEffort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime32BestEffortOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime32BestEffortOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64BestEffort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64BestEffortOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64BestEffortOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64BestEffortUS",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64BestEffortUSOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64BestEffortUSOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64InJodaSyntax",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64InJodaSyntaxOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64InJodaSyntaxOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTime64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeBestEffort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeBestEffortOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeBestEffortOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeBestEffortUS",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeBestEffortUSOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeBestEffortUSOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeInJodaSyntax",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeInJodaSyntaxOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeInJodaSyntaxOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseDateTimeOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "parseReadableSize",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "parseReadableSize(x)",
      "description": "Given a string containing a byte size and `B`, `KiB`, `KB`, `MiB`, `MB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) or decimal byte unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it throws an exception.",
      "arguments": "- `x` — Readable size with ISO/IEC 80000-13 or decimal byte unit ([String](../../sql-reference/data-types/string.md))\n",
      "returnedValue": "Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md))",
      "examples": "**basic**\n\n```sql title=Query\nSELECT arrayJoin(['1 B', '1 KiB', '3 MB', '5.314 KiB']) AS readable_sizes, parseReadableSize(readable_sizes) AS sizes;\n```\n\n```response title=Response\n┌─readable_sizes─┬───sizes─┐\n│ 1 B            │       1 │\n│ 1 KiB          │    1024 │\n│ 3 MB           │ 3000000 │\n│ 5.314 KiB      │    5442 │\n└────────────────┴─────────┘\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "parseReadableSizeOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "parseReadableSizeOrNull(x)",
      "description": "Given a string containing a byte size and `B`, `KiB`, `KB`, `MiB`, `MB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) or decimal byte unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `NULL`",
      "arguments": "- `x` — Readable size with ISO/IEC 80000-13  or decimal byte unit ([String](../../sql-reference/data-types/string.md))\n",
      "returnedValue": "Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md)))",
      "examples": "**basic**\n\n```sql title=Query\nSELECT arrayJoin(['1 B', '1 KiB', '3 MB', '5.314 KiB', 'invalid']) AS readable_sizes, parseReadableSizeOrNull(readable_sizes) AS sizes;\n```\n\n```response title=Response\n┌─readable_sizes─┬───sizes─┐\n│ 1 B            │       1 │\n│ 1 KiB          │    1024 │\n│ 3 MB           │ 3000000 │\n│ 5.314 KiB      │    5442 │\n│ invalid        │    ᴺᵁᴸᴸ │\n└────────────────┴─────────┘\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "parseReadableSizeOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "parseReadableSizeOrZero(x)",
      "description": "Given a string containing a byte size and `B`, `KiB`, `KB`, `MiB`, `MB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) or decimal byte unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `0`",
      "arguments": "- `x` — Readable size with ISO/IEC 80000-13 or decimal byte unit ([String](../../sql-reference/data-types/string.md))\n",
      "returnedValue": "Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md))",
      "examples": "**basic**\n\n```sql title=Query\nSELECT arrayJoin(['1 B', '1 KiB', '3 MB', '5.314 KiB', 'invalid']) AS readable_sizes, parseReadableSizeOrZero(readable_sizes) AS sizes;\n```\n\n```response title=Response\n┌─readable_sizes─┬───sizes─┐\n│ 1 B            │       1 │\n│ 1 KiB          │    1024 │\n│ 3 MB           │ 3000000 │\n│ 5.314 KiB      │    5442 │\n│ invalid        │       0 │\n└────────────────┴─────────┘\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "parseTimeDelta",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "partitionID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "partitionId",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "partitionId",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "path",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "pathFull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRank",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percent_rank",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": "percentRank",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "pi",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "plus",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "plus(x, y)",
      "description": "\nCalculates the sum of two values `x` and `y`. Alias: `x + y` (operator).\nIt is possible to add an integer and a date or date with time. The former\noperation increments the number of days in the date, the latter operation\nincrements the number of seconds in the date with time.\n    ",
      "arguments": "- `x` — Left hand operand.\n- `y` — Right hand operand.\n",
      "returnedValue": "The sum of x and y",
      "examples": "**Adding two numbers**\n\n```sql title=Query\nSELECT plus(5,5)\n```\n\n```response title=Response\n10\n```\n\n**Adding an integer and a date**\n\n```sql title=Query\nSELECT plus(toDate('2025-01-01'),5)\n```\n\n```response title=Response\n2025-01-06\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "pmod",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "positiveModulo",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "pmodOrNull",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "positiveModuloOrNull",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "pointInEllipses",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "pointInPolygon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonAreaCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonAreaSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonConvexHullCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonPerimeterCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonPerimeterSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsDistanceCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsDistanceSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsEqualsCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsIntersectionCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsIntersectionSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsSymDifferenceCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsSymDifferenceSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsUnionCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsUnionSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsWithinCartesian",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "polygonsWithinSpherical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "port",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns the port or `default_port` if there is no port in the URL (or in case of validation error).",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "portRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `port`, but conforms to RFC 3986.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "position",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "positionCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "positionCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "positionUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "positiveModulo",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "positiveModulo(x, y)",
      "description": "\nCalculates the remainder when dividing `x` by `y`. Similar to function\n`modulo` except that `positiveModulo` always return non-negative number.\n    ",
      "arguments": "- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `y` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the difference between `x` and the nearest integer not greater than\n`x` divisible by `y`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT positiveModulo(-1, 10)\n```\n\n```response title=Response\n9\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "positiveModuloOrNull",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "positiveModuloOrNull(x, y)",
      "description": "\nCalculates the remainder when dividing `a` by `b`. Similar to function `positiveModulo` except that `positiveModuloOrNull` will return NULL\nif the right argument is 0.\n    ",
      "arguments": "- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n- `x` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).\n",
      "returnedValue": "Returns the difference between `x` and the nearest integer not greater than\n`x` divisible by `y`, `null` when the divisor is zero.",
      "examples": "**positiveModuloOrNull**\n\n```sql title=Query\nSELECT positiveModuloOrNull(5, 0)\n```\n\n```response title=Response\n\\N\n```\n\n",
      "categories": "Arithmetic"
    },
    {
      "name": "positive_modulo",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "positiveModulo",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "positive_modulo_or_null",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "positiveModuloOrNull",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "pow",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "power",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "pow",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "printf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nThe `printf` function formats the given string with the values (strings, integers, floating-points etc.) listed in the arguments, similar to printf function in C++.\nThe format string can contain format specifiers starting with `%` character.\nAnything not contained in `%` and the following format specifier is considered literal text and copied verbatim into the output.\nLiteral `%` character can be escaped by `%%`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**sum**\n\n```sql title=Query\nselect printf('%%%s %s %d', 'Hello', 'World', 2024);\n```\n\n```response title=Response\n%Hello World 2024\n```\n\n",
      "categories": "String Replacement"
    },
    {
      "name": "proportionsZTest",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "protocol",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "punycodeDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "punycodeDecode(str)",
      "description": "\nComputes a Punycode representation of a string. Throws an exception if the input is not valid Punycode.",
      "arguments": "- `str` — A Punycode-encoded string\n",
      "returnedValue": "The plaintext representation [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT punycodeDecode('Mnchen-3ya') AS plain;\n```\n\n```response title=Response\n┌─plain───┐\n│ München │\n└─────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "punycodeEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "punycodeEncode(str)",
      "description": "\nComputes a Punycode representation of a string.",
      "arguments": "- `str` — Input string\n",
      "returnedValue": "The punycode representation [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT punycodeEncode('München') AS puny;\n```\n\n```response title=Response\n┌─puny───────┐\n│ Mnchen-3ya │\n└────────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "quantile",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16Weighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDD",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministic",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExact",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusive",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHigh",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusive",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolated",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGK",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTiming",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantiles",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16Weighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDD",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministic",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExact",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusive",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHigh",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusive",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolated",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGK",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTiming",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "queryID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "queryString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "queryStringAndFragment",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "query_id",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "queryID",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "radians",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rand",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rand32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "rand",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rand64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "randBernoulli",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the Bernoulli distribution.\nAccepts one parameter - probability of success.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randBernoulli(0.1) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randBinomial",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the binomial distribution.\nAccepts two parameters - number of experiments and probability of success in each experiment.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randBinomial(10, 0.1) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randCanonical",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nThe function generates pseudo random results with independent and identically distributed uniformly distributed values in [0, 1).\nNon-deterministic. Return type is Float64.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**randCanonical**\n\n```sql title=Query\nSELECT randCanonical()\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randChiSquared",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the chi-squared distribution (a distribution of a sum of the squares of k independent standard normal random variables).\nAccepts one parameter - degree of freedom.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randChiSquared(5) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randConstant",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "randExponential",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the exponential distribution.\nAccepts one parameter - lambda value.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randExponential(0, 5) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randFisherF",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the f-distribution.\nThe F-distribution is the distribution of X = (S1 / d1) / (S2 / d2) where d1 and d2 are degrees of freedom.\nAccepts two parameters - degrees of freedom.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randFisherF(5) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randLogNormal",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the lognormal distribution (a distribution of a random variable whose logarithm is normally distributed).\nAccepts two parameters - mean and standard deviation.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randLogNormal(0, 5) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randNegativeBinomial",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the negative binomial distribution.\nAccepts two parameters - number of experiments and probability of success in each experiment.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randNegativeBinomial(10, 0.1) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randNormal",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the normal distribution.\nAccepts two parameters - mean and standard deviation.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randNormal(0, 5) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randPoisson",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the poisson distribution.\nAccepts one parameter - the mean number of occurrences.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randPoisson(3) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randStudentT",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the t-distribution.\nAccepts one parameter - degree of freedom.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randStudentT(5) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randUniform",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a random number from the uniform distribution in the specified range.\nAccepts two parameters - minimum bound and maximum bound.\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT randUniform(0, 1) FROM numbers(100000);\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Random Number"
    },
    {
      "name": "randomFixedString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "randomPrintableASCII",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "randomString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "randomStringUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "range",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "range([start, ] end [, step])",
      "description": "\nReturns an array of numbers from `start` to `end - 1` by `step`.\n\nThe supported types are:\n- `UInt8/16/32/64`\n- `Int8/16/32/64]`\n\n- All arguments `start`, `end`, `step` must be one of the above supported types. Elements of the returned array will be a super type of the arguments.\n- An exception is thrown if the function returns an array with a total length more than the number of elements specified by setting [`function_range_max_elements_in_block`](../../operations/settings/settings.md#function_range_max_elements_in_block).\n- Returns `NULL` if any argument has Nullable(nothing) type. An exception is thrown if any argument has `NULL` value (Nullable(T) type).\n    ",
      "arguments": "- `start` — Optional. The first element of the array. Required if `step` is used. Default value: `0`.\n- `end` — Required. The number before which the array is constructed.\n- `step` — Optional. Determines the incremental step between each element in the array. Default value: `1`.\n",
      "returnedValue": "Array of numbers from `start` to `end - 1` by `step`.",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);\n```\n\n```response title=Response\n┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐\n│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │\n└─────────────┴─────────────┴────────────────┴─────────────────┘\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "rank",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorr",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "readWKBLineString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKBLineString(wkt_string)",
      "description": "\n    Parses a Well-Known Binary (WKB) representation of a LineString geometry and returns it in the internal ClickHouse format.\n    ",
      "arguments": "- `wkb_string` — The input WKB string representing a LineString geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the linestring geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKBLineString(unhex('010200000004000000000000000000f03f000000000000f03f0000000000000040000000000000004000000000000008400000000000000840000000000000f03f000000000000f03f'));\n```\n\n```response title=Response\n┌─readWKBLineString(unhex'0102000000040000000000...'))─┐\n    │ [(1,1),(2,2),(3,3),(1,1)]                            │\n    └──────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Geo"
    },
    {
      "name": "readWKBMultiLineString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKBMultiLineString(wkt_string)",
      "description": "\n            Parses a Well-Known Binary (WKB) representation of a MultiLineString geometry and returns it in the internal ClickHouse format.\n            ",
      "arguments": "- `wkb_string` — The input WKB string representing a MultiLineString geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the multilinestring geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKTMultiLineString(unhex('010500000002000000010200000003000000000000000000f03f000000000000f03f0000000000000040000000000000004000000000000008400000000000000840010200000003000000000000000000104000000000000010400000000000001440000000000000144000000000000018400000000000001840'));\n```\n\n```response title=Response\n┌─readWKBMultiLineString('unhex('010500000002000000010200000003000000000...'))─┐\n            │ [[(1,1),(2,2),(3,3)],[(4,4),(5,5),(6,6)]]                                    │\n            └──────────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Geo"
    },
    {
      "name": "readWKBMultiPolygon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKBMultiPolygon(wkt_string)",
      "description": "\n        Parses a Well-Known Binary (WKB) representation of a MultiPolygon geometry and returns it in the internal ClickHouse format.\n        ",
      "arguments": "- `wkb_string` — The input WKB string representing a MultiPolygon geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the MultiPolygon geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKBMultiPolygon(unhex('0106000000020000000103000000020000000500000000000000000000400000000000000000000000000000244000000000000000000000000000002440000000000000244000000000000000000000000000002440000000000000004000000000000000000500000000000000000010400000000000001040000000000000144000000000000010400000000000001440000000000000144000000000000010400000000000001440000000000000104000000000000010400103000000010000000400000000000000000024c000000000000024c000000000000024c000000000000022c000000000000022c0000000000000244000000000000024c000000000000024c0'));\n```\n\n```response title=Response\n┌─readWKBMultiPolygon(unhex'01060000000200000001030000000200000005000000000000000000004000000000000000000000000000002440...'))─┐\n        │ [[[(2,0),(10,0),(10,10),(0,10),(2,0)],[(4,4),(5,4),(5,5),(4,5),(4,4)]],[[(-10,-10),(-10,-9),(-9,10),(-10,-10)]]]             │\n        └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Geo"
    },
    {
      "name": "readWKBPoint",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKBPoint(wkt_string)",
      "description": "\n    Parses a Well-Known Binary (WKB) representation of a Point geometry and returns it in the internal ClickHouse format.\n    ",
      "arguments": "- `wkb_string` — The input WKB string representing a Point geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the point geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKBPoint(unhex('010100000000000000000000000000000000000000'));\n```\n\n```response title=Response\n┌─readWKBPoint(unhex'010100000000000000000000000...'))─┐\n    │ (0,0)                                                │\n    └──────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Geo"
    },
    {
      "name": "readWKBPolygon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKBPolygon(wkt_string)",
      "description": "\n                Parses a Well-Known Binary (WKB) representation of a Polygon geometry and returns it in the internal ClickHouse format.\n                ",
      "arguments": "- `wkb_string` — The input WKB string representing a Polygon geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the Polygon geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKBPolygon(unhex('01030000000100000005000000000000000000f03f0000000000000000000000000000244000000000000000000000000000002440000000000000244000000000000000000000000000002440000000000000f03f0000000000000000'));\n```\n\n```response title=Response\n┌─readWKBPolygon(unhex'01030000000200000005000000000000000000000000000000000000000000000000002440000000000000000000000000000024...'))─┐\n                │ (1,0),(10,0),(10,10),(0,10),(1,0)]]                                                                                                 │\n                └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Geo"
    },
    {
      "name": "readWKTLineString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKTLineString(wkt_string)",
      "description": "\nParses a Well-Known Text (WKT) representation of a LineString geometry and returns it in the internal ClickHouse format.\n",
      "arguments": "- `wkt_string` — The input WKT string representing a LineString geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the linestring geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKTLineString('LINESTRING (1 1, 2 2, 3 3, 1 1)');\n```\n\n```response title=Response\n┌─readWKTLineString('LINESTRING (1 1, 2 2, 3 3, 1 1)')─┐\n│ [(1,1),(2,2),(3,3),(1,1)]                            │\n└──────────────────────────────────────────────────────┘\n```\n\n**second call**\n\n```sql title=Query\nSELECT toTypeName(readWKTLineString('LINESTRING (1 1, 2 2, 3 3, 1 1)'));\n```\n\n```response title=Response\n┌─toTypeName(readWKTLineString('LINESTRING (1 1, 2 2, 3 3, 1 1)'))─┐\n│ LineString                                                       │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "readWKTMultiLineString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "readWKTMultiLineString(wkt_string)",
      "description": "\nParses a Well-Known Text (WKT) representation of a MultiLineString geometry and returns it in the internal ClickHouse format.\n",
      "arguments": "- `wkt_string` — The input WKT string representing a MultiLineString geometry.\n",
      "returnedValue": "The function returns a ClickHouse internal representation of the multilinestring geometry.",
      "examples": "**first call**\n\n```sql title=Query\nSELECT readWKTMultiLineString('MULTILINESTRING ((1 1, 2 2, 3 3), (4 4, 5 5, 6 6))');\n```\n\n```response title=Response\n┌─readWKTMultiLineString('MULTILINESTRING ((1 1, 2 2, 3 3), (4 4, 5 5, 6 6))')─┐\n│ [[(1,1),(2,2),(3,3)],[(4,4),(5,5),(6,6)]]                                    │\n└──────────────────────────────────────────────────────────────────────────────┘\n```\n\n**second call**\n\n```sql title=Query\nSELECT toTypeName(readWKTLineString('MULTILINESTRING ((1 1, 2 2, 3 3, 1 1))'));\n```\n\n```response title=Response\n┌─toTypeName(readWKTLineString('MULTILINESTRING ((1 1, 2 2, 3 3, 1 1))'))─┐\n│ MultiLineString                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Geo"
    },
    {
      "name": "readWKTMultiPolygon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "readWKTPoint",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "readWKTPolygon",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "readWKTRing",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regexpExtract",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Extracts the first string in haystack that matches the regexp pattern and corresponds to the regex group index.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Search"
    },
    {
      "name": "regexpQuoteMeta",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionHierarchy",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionIn",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToArea",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToCity",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToContinent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToCountry",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToDistrict",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToPopulation",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "regionToTopContinent",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpret",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsDate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsFixedString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsFloat32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsFloat64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsInt128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsInt256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUInt128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUInt256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reinterpretAsUUID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "repeat",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "replace",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "replaceAll",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "replaceAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "replaceOne",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "replaceRegexpAll",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "replaceRegexpOne",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "replicate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retention",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "reverse",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "reverse(arr | str)",
      "description": "Reverses the order of the elements in the input array or the characters in the input string.",
      "arguments": "- `arr | str` — The source array or string. [`Array(T)`](/sql-reference/data-types/array), [`String`](/sql-reference/data-types/string).\n",
      "returnedValue": "Returns an array or string with the order of elements or characters reversed.",
      "examples": "**Reverse array**\n\n```sql title=Query\nSELECT reverse([1, 2, 3, 4]);\n```\n\n```response title=Response\n[4, 3, 2, 1]\n```\n\n**Reverse string**\n\n```sql title=Query\nSELECT reverse('abcd');\n```\n\n```response title=Response\n'dcba'\n```\n\n",
      "categories": "Arrays"
    },
    {
      "name": "reverseUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "revision",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "right",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rightPad",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rightPadUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rightUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "round",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "roundAge",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "roundBankers",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "roundDown",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "roundDuration",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "roundToExp2",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rowNumberInAllBlocks",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rowNumberInBlock",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_number",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rpad",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "rightPad",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rtrim",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "trimRight",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "runningAccumulate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "runningConcurrency",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "runningDifference",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "runningDifferenceStartingWithFirstValue",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2CapContains",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2CapUnion",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2CellsIntersect",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2GetNeighbors",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2RectAdd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2RectContains",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2RectIntersection",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2RectUnion",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "s2ToGeo",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "scalarProduct",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "dotProduct",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCount",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatch",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEvents",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNode",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "seriesDecomposeSTL",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nDecomposes a time series using STL [(Seasonal-Trend Decomposition Procedure Based on Loess)](https://www.wessa.net/download/stl.pdf) into a season, a trend and a residual component.\n\n**Syntax**\n\n```sql\nseriesDecomposeSTL(series, period);\n```\n\n**Arguments**\n\n- `series` - An array of numeric values\n- `period` - A positive number\n\nThe number of data points in `series` should be at least twice the value of `period`.\n\n**Returned value**\n\n- An array of four arrays where the first array include seasonal components, the second array - trend, the third array - residue component, and the fourth array - baseline(seasonal + trend) component.\n\nType: [Array](../../sql-reference/data-types/array.md).\n\n**Examples**\n\nQuery:\n\n```sql\nSELECT seriesDecomposeSTL([10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34], 3) AS print_0;\n```\n\nResult:\n\n```text\n┌───────────print_0──────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ [[\n        -13.529999, -3.1799996, 16.71,      -13.53,     -3.1799996, 16.71,      -13.53,     -3.1799996,\n        16.71,      -13.530001, -3.18,      16.710001,  -13.530001, -3.1800003, 16.710001,  -13.530001,\n        -3.1800003, 16.710001,  -13.530001, -3.1799994, 16.71,      -13.529999, -3.1799994, 16.709997\n    ],\n    [\n        23.63,     23.63,     23.630003, 23.630001, 23.630001, 23.630001, 23.630001, 23.630001,\n        23.630001, 23.630001, 23.630001, 23.63,     23.630001, 23.630001, 23.63,     23.630001,\n        23.630001, 23.63,     23.630001, 23.630001, 23.630001, 23.630001, 23.630001, 23.630003\n    ],\n    [\n        0, 0.0000019073486, -0.0000019073486, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.0000019073486, 0,\n        0\n    ],\n    [\n        10.1, 20.449999, 40.340004, 10.100001, 20.45, 40.34, 10.100001, 20.45, 40.34, 10.1, 20.45, 40.34,\n        10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.1, 20.45, 40.34, 10.100002, 20.45, 40.34\n    ]]                                                                                                                   │\n└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Time Series"
    },
    {
      "name": "seriesOutliersDetectTukey",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nDetects outliers in series data using [Tukey Fences](https://en.wikipedia.org/wiki/Outlier#Tukey%27s_fences).\n\n**Syntax**\n\n```sql\nseriesOutliersDetectTukey(series);\nseriesOutliersDetectTukey(series, min_percentile, max_percentile, k);\n```\n\n**Arguments**\n\n- `series` - An array of numeric values.\n- `min_quantile` - The minimum quantile to be used to calculate inter-quantile range [(IQR)](https://en.wikipedia.org/wiki/Interquartile_range). The value must be in range [0.02,0.98]. The default is 0.25.\n- `max_quantile` - The maximum quantile to be used to calculate inter-quantile range (IQR). The value must be in range [0.02, 0.98]. The default is 0.75.\n- `k` - Non-negative constant value to detect mild or stronger outliers. The default value is 1.5\n\nAt least four data points are required in `series` to detect outliers.\n\n**Returned value**\n\n- Returns an array of the same length as the input array where each value represents score of possible anomaly of corresponding element in the series. A non-zero score indicates a possible anomaly.\n\nType: [Array](../../sql-reference/data-types/array.md).\n\n**Examples**\n\nQuery:\n\n```sql\nSELECT seriesOutliersDetectTukey([-3, 2, 15, 3, 5, 6, 4, 5, 12, 45, 12, 3, 3, 4, 5, 6]) AS print_0;\n```\n\nResult:\n\n```text\n┌───────────print_0─────────────────┐\n│[0,0,0,0,0,0,0,0,0,27,0,0,0,0,0,0] │\n└───────────────────────────────────┘\n```\n\nQuery:\n\n```sql\nSELECT seriesOutliersDetectTukey([-3, 2, 15, 3, 5, 6, 4.50, 5, 12, 45, 12, 3.40, 3, 4, 5, 6], 0.2, 0.8, 1.5) AS print_0;\n```\n\nResult:\n\n```text\n┌─print_0──────────────────────────────┐\n│ [0,0,0,0,0,0,0,0,0,19.5,0,0,0,0,0,0] │\n└──────────────────────────────────────┘\n```",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Time Series"
    },
    {
      "name": "seriesPeriodDetectFFT",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nFinds the period of the given time series data using FFT\nFFT - Fast Fourier transform (https://en.wikipedia.org/wiki/Fast_Fourier_transform)\n\n**Syntax**\n\n```sql\nseriesPeriodDetectFFT(series);\n```\n\n**Arguments**\n\n- `series` - An array of numeric values\n\n**Returned value**\n\n- A real value equal to the period of time series\n- Returns NAN when number of data points are less than four.\n\nType: [Float64](../../sql-reference/data-types/float.md).\n\n**Examples**\n\nQuery:\n\n```sql\nSELECT seriesPeriodDetectFFT([1, 4, 6, 1, 4, 6, 1, 4, 6, 1, 4, 6, 1, 4, 6, 1, 4, 6, 1, 4, 6]) AS print_0;\n```\n\nResult:\n\n```text\n┌───────────print_0──────┐\n│                      3 │\n└────────────────────────┘\n```\n\n```sql\nSELECT seriesPeriodDetectFFT(arrayMap(x -> abs((x % 6) - 3), range(1000))) AS print_0;\n```\n\nResult:\n\n```text\n┌─print_0─┐\n│       6 │\n└─────────┘\n```\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Time Series"
    },
    {
      "name": "serverTimeZone",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "serverTimezone",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "serverTimezone",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "serverTimeZone()",
      "description": "\nReturns the timezone of the server, i.e. the value of the [`timezone`](/operations/server-configuration-parameters/settings#timezone) setting.\nIf the function is executed in the context of a distributed table, then it generates a normal column with values relevant to each shard. Otherwise, it produces a constant value.\n    ",
      "arguments": "",
      "returnedValue": "Returns the server timezone as a [`String`](/sql-reference/data-types/string).",
      "examples": "**Get server time zone**\n\n```sql title=Query\nSELECT serverTimeZone()\n```\n\n```response title=Response\n┌─serverTimeZone()─┐\n│ UTC              │\n└──────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "serverUUID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "shardCount",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "shardNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "showCertificate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sigmoid",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sign",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleJSONExtractBool",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONExtractBool(json, field_name)",
      "description": "Parses a true/false value from the value of the field named field_name. The result is UInt8.",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns 1 if the value of the field is true, 0 otherwise. This means this function will return 0 including (and not only) in the following cases:\n - If the field doesn't exists.\n - If the field contains true as a string, e.g.: {\"field\":\"true\"}.\n - If the field contains 1 as a numerical value.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":false,\"bar\":true}');\nINSERT INTO jsons VALUES ('{\"foo\":\"true\",\"qux\":1}');\n\nSELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;\nSELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;\n```\n\n```response title=Response\n0\n1\n0\n0\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleJSONExtractFloat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONExtractFloat(json, field_name)",
      "description": "Parses Float64 from the value of the field named field_name. If this is a string field, it tries to parse a number from the beginning of the string. If the field does not exist, or it exists but does not contain a number, it returns 0.",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns the number parsed from the field if the field exists and contains a number, 0 otherwise.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":\"-4e3\"}');\nINSERT INTO jsons VALUES ('{\"foo\":-3.4}');\nINSERT INTO jsons VALUES ('{\"foo\":5}');\nINSERT INTO jsons VALUES ('{\"foo\":\"not1number\"}');\nINSERT INTO jsons VALUES ('{\"baz\":2}');\n\nSELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;\n```\n\n```response title=Response\n0\n-4000\n0\n-3.4\n5\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleJSONExtractInt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONExtractInt(json, field_name)",
      "description": "Parses Int64 from the value of the field named field_name. If this is a string field, it tries to parse a number from the beginning of the string. If the field does not exist, or it exists but does not contain a number, it returns 0.",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns the number parsed from the field if the field exists and contains a number, 0 otherwise.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":\"-4e3\"}');\nINSERT INTO jsons VALUES ('{\"foo\":-3.4}');\nINSERT INTO jsons VALUES ('{\"foo\":5}');\nINSERT INTO jsons VALUES ('{\"foo\":\"not1number\"}');\nINSERT INTO jsons VALUES ('{\"baz\":2}');\n\nSELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;\n```\n\n```response title=Response\n0\n-4\n0\n-3\n5\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleJSONExtractRaw",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONExtractRaw(json, field_name)",
      "description": "Returns the value of the field named field_name as a String, including separators.",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns the value of the field as a String including separators if the field exists, or an empty String otherwise.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":\"-4e3\"}');\nINSERT INTO jsons VALUES ('{\"foo\":-3.4}');\nINSERT INTO jsons VALUES ('{\"foo\":5}');\nINSERT INTO jsons VALUES ('{\"foo\":{\"def\":[1,2,3]}}');\nINSERT INTO jsons VALUES ('{\"baz\":2}');\n\nSELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;\n```\n\n```response title=Response\n\"-4e3\"\n-3.4\n5\n{\"def\":[1,2,3]}\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleJSONExtractString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONExtractString(json, field_name)",
      "description": "Parses String in double quotes from the value of the field named field_name.\n\n        There is currently no support for code points in the format \\uXXXX\\uYYYY that are not from the basic multilingual plane (they are converted to CESU-8 instead of UTF-8).",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns the value of a field as a String, including separators. The value is unescaped. It returns an empty String: if the field doesn't contain a double quoted string, if unescaping fails or if the field doesn't exist.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":\"\\\\n\\\\u0000\"}');\nINSERT INTO jsons VALUES ('{\"foo\":\"\\\\u263\"}');\nINSERT INTO jsons VALUES ('{\"foo\":\"\\\\u263a\"}');\nINSERT INTO jsons VALUES ('{\"foo\":\"hello}');\n\nSELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;\n```\n\n```response title=Response\n\\n\\0\n\n☺\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleJSONExtractUInt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONExtractUInt(json, field_name)",
      "description": "Parses UInt64 from the value of the field named field_name. If this is a string field, it tries to parse a number from the beginning of the string. If the field does not exist, or it exists but does not contain a number, it returns 0.",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns the number parsed from the field if the field exists and contains a number, 0 otherwise.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":\"4e3\"}');\nINSERT INTO jsons VALUES ('{\"foo\":3.4}');\nINSERT INTO jsons VALUES ('{\"foo\":5}');\nINSERT INTO jsons VALUES ('{\"foo\":\"not1number\"}');\nINSERT INTO jsons VALUES ('{\"baz\":2}');\n\nSELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;\n```\n\n```response title=Response\n0\n4\n0\n3\n5\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleJSONHas",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "simpleJSONHas(json, field_name)",
      "description": "Checks whether there is a field named field_name.  The result is UInt8.",
      "arguments": "- `json` — The JSON in which the field is searched for. String.\n- `field_name` — The name of the field to search for. String literal.\n",
      "returnedValue": "It returns 1 if the field exists, 0 otherwise.",
      "examples": "**simple**\n\n```sql title=Query\nCREATE TABLE jsons\n(\n    json String\n)\nENGINE = Memory;\n\nINSERT INTO jsons VALUES ('{\"foo\":\"true\",\"qux\":1}');\n\nSELECT simpleJSONHas(json, 'foo') FROM jsons;\nSELECT simpleJSONHas(json, 'bar') FROM jsons;\n```\n\n```response title=Response\n1\n0\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "simpleLinearRegression",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sin",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "sin(x)",
      "description": "Returns the sine of the argument.",
      "arguments": "- `x` — The number whose sine will be returned. (U)Int*, Float* or Decimal*.\n",
      "returnedValue": "The sine of x.",
      "examples": "**simple**\n\n```sql title=Query\nSELECT sin(1.23)\n```\n\n```response title=Response\n0.9424888019316975\n```\n\n",
      "categories": "Mathematical"
    },
    {
      "name": "singleValueOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sinh",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sipHash128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sipHash128Keyed",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sipHash128Reference",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Like [sipHash128](#hash_functions-siphash128) but implements the 128-bit algorithm from the original authors of SipHash.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**hash**\n\n```sql title=Query\nSELECT hex(sipHash128Reference('foo', '\\x01', 3))\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "sipHash128ReferenceKeyed",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Same as [sipHash128Reference](#hash_functions-siphash128reference) but additionally takes an explicit key argument instead of using a fixed key.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**hash**\n\n```sql title=Query\nSELECT hex(sipHash128ReferenceKeyed((506097522914230528, 1084818905618843912),'foo', '\\x01', 3));\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "sipHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sipHash64Keyed",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPop",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSamp",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sleep",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sleepEachRow",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "snowflakeIDToDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "snowflakeIDToDateTime(value[, epoch[, time_zone]])",
      "description": "Returns the timestamp component of a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) as a value of type [DateTime](../data-types/datetime.md).",
      "arguments": "- `value` — Snowflake ID. [UInt64](../data-types/int-uint.md)\n- `epoch` — Epoch of the Snowflake ID in milliseconds since 1970-01-01. Defaults to 0 (1970-01-01). For the Twitter/X epoch (2015-01-01), provide 1288834974657. Optional. [UInt*](../data-types/int-uint.md)\n- `time_zone` — [Timezone](/operations/server-configuration-parameters/settings.md/#server_configuration_parameters-timezone). The function parses `time_string` according to the timezone. Optional. [String](../data-types/string.md)\n",
      "returnedValue": "The timestamp component of `value` as a [DateTime](../data-types/datetime.md) value.",
      "examples": "**simple**\n\n```sql title=Query\nSELECT snowflakeIDToDateTime(7204436857747984384)\n```\n\n```response title=Response\n2024-06-06 10:59:58\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "snowflakeIDToDateTime64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "snowflakeIDToDateTime64(value[, epoch[, time_zone]])",
      "description": "Returns the timestamp component of a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) as a value of type [DateTime64](../data-types/datetime64.md).",
      "arguments": "- `value` — Snowflake ID. [UInt64](../data-types/int-uint.md)\n- `epoch` — Epoch of the Snowflake ID in milliseconds since 1970-01-01. Defaults to 0 (1970-01-01). For the Twitter/X epoch (2015-01-01), provide 1288834974657. Optional. [UInt*](../data-types/int-uint.md)\n- `time_zone` — [Timezone](/operations/server-configuration-parameters/settings.md/#server_configuration_parameters-timezone). The function parses `time_string` according to the timezone. Optional. [String](../data-types/string.md)\n",
      "returnedValue": "The timestamp component of `value` as a [DateTime64](../data-types/datetime64.md) with scale = 3, i.e. millisecond precision.",
      "examples": "**simple**\n\n```sql title=Query\nSELECT snowflakeIDToDateTime64(7204436857747984384)\n```\n\n```response title=Response\n2024-06-06 10:59:58\n```\n\n",
      "categories": "UUID"
    },
    {
      "name": "snowflakeToDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "snowflakeToDateTime64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "soundex",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Returns Soundex code of a string.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "space",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkBar",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": "sparkbar",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbar",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparseGrams",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Finds all substrings of a given string that have a length of at least `n`,\nwhere the hashes of the (n-1)-grams at the borders of the substring\nare strictly greater than those of any (n-1)-gram inside the substring.",
      "arguments": "- `s` — An input string\n- `min_ngram_length` — The minimum length of extracted ngram. The default and minimal value is 3\n- `max_ngram_length` — The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n",
      "returnedValue": "An array of selected substrings",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "sparseGramsHashes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Finds hashes of all substrings of a given string that have a length of at least `n`,\nwhere the hashes of the (n-1)-grams at the borders of the substring\nare strictly greater than those of any (n-1)-gram inside the substring.",
      "arguments": "- `s` — An input string\n- `min_ngram_length` — The minimum length of extracted ngram. The default and minimal value is 3\n- `max_ngram_length` — The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n",
      "returnedValue": "An array of selected substrings hashes",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "sparseGramsHashesUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Finds hashes of all substrings of a given string that have a length of at least `n`,\nwhere the hashes of the (n-1)-grams at the borders of the substring\nare strictly greater than those of any (n-1)-gram inside the substring.",
      "arguments": "- `s` — An input string\n- `min_ngram_length` — The minimum length of extracted ngram. The default and minimal value is 3\n- `max_ngram_length` — The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n",
      "returnedValue": "An array of selected substrings hashes",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "sparseGramsUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Finds all substrings of a given string that have a length of at least `n`,\nwhere the hashes of the (n-1)-grams at the borders of the substring\nare strictly greater than those of any (n-1)-gram inside the substring.",
      "arguments": "- `s` — An input string\n- `min_ngram_length` — The minimum length of extracted ngram. The default and minimal value is 3\n- `max_ngram_length` — The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n",
      "returnedValue": "An array of selected substrings",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "splitByAlpha",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "alphaTokens",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "splitByChar",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "splitByNonAlpha",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "splitByRegexp",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "splitByString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "splitByWhitespace",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sqid",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "sqidEncode",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sqidDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "sqidDecode(number1, ...)",
      "description": "\nTransforms a [Sqid](https://sqids.org/) back into an array of numbers.",
      "arguments": "- `sqid` — A sqid\n",
      "returnedValue": "An array of [UInt64](/sql-reference/data-types/int-uint.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT sqidDecode('gXHfJ1C6dN');\n```\n\n```response title=Response\n┌─sqidDecode('gXHfJ1C6dN')─┐\n│ [1,2,3,4,5]              │\n└──────────────────────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "sqidEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "sqidEncode(number1, ...)",
      "description": "\nTransforms numbers into a [Sqid](https://sqids.org/) which is a Youtube-like ID string.",
      "arguments": "- `number1, ...` — Arbitrarily many UInt8, UInt16, UInt32 or UInt64 arguments\n",
      "returnedValue": "A hash id [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT sqidEncode(1, 2, 3, 4, 5);\n```\n\n```response title=Response\n┌─sqidEncode(1, 2, 3, 4, 5)─┐\n│ gXHfJ1C6dN                │\n└───────────────────────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "sqrt",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "startsWith",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "startsWithUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns whether string `str` starts with `prefix`, the difference between `startsWithUTF8` and `startsWith` is that `startsWithUTF8` match `str` and `suffix` by UTF-8 characters.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**startsWithUTF8**\n\n```sql title=Query\nselect startsWithUTF8('富强民主文明和谐', '富强');\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "String"
    },
    {
      "name": "stddevPop",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSamp",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stem",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegression",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegression",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "str_to_date",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "parseDateTimeOrNull",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "str_to_map",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "extractKeyValuePairs",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stringBytesEntropy",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "stringBytesEntropy(s);",
      "description": "Calculates Shannon's entropy of byte distribution in a string.",
      "arguments": "- `s` — The string to analyze. [String](../../sql-reference/data-types/string.md))\n",
      "returnedValue": "The Shannon entropy of the byte distribution. [Float64](../../sql-reference/data-types/float.md).",
      "examples": "**Example**\n\n```sql title=Query\nSELECT stringBytesEntropy('Hello, world!');\n```\n\n```response title=Response\n3.180832987205441\n```\n\n",
      "categories": "String"
    },
    {
      "name": "stringBytesUniq",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "stringBytesUniq(s);",
      "description": "Counts the number of distinct bytes in a string.",
      "arguments": "- `s` — The string to analyze. [String](../../sql-reference/data-types/string.md)\n",
      "returnedValue": "The number of distinct bytes in the string. [UInt16](../../sql-reference/data-types/int-uint.md).",
      "examples": "**Example**\n\n```sql title=Query\nSELECT stringBytesUniq('Hello, world!');\n```\n\n```response title=Response\n10\n```\n\n",
      "categories": "String"
    },
    {
      "name": "stringJaccardIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the Jaccard similarity index between two byte strings.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "stringJaccardIndexUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates the Jaccard similarity index between two UTF8 strings.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String"
    },
    {
      "name": "stringToH3",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "structureToCapnProtoSchema",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nFunction that converts ClickHouse table structure to CapnProto format schema\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**random**\n\n```sql title=Query\nSELECT structureToCapnProtoSchema('s String, x UInt32', 'MessageName') format TSVRaw\n```\n\n```response title=Response\nstruct MessageName\n{\n    s @0 : Data;\n    x @1 : UInt32;\n}\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "structureToProtobufSchema",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nFunction that converts ClickHouse table structure to Protobuf format schema\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**random**\n\n```sql title=Query\nSELECT structureToCapnProtoSchema('s String, x UInt32', 'MessageName') format TSVRaw\n```\n\n```response title=Response\nsyntax = \"proto3\";\n\nmessage MessageName\n{\n    bytes s = 1;\n    uint32 x = 2;\n}\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "studentTTest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "subBitmap",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subBitmap(bitmap, offset, cardinality_limit)",
      "description": "Returns a subset of the bitmap, starting from position `offset`. The maximum cardinality of the returned bitmap is `cardinality_limit`.",
      "arguments": "- `bitmap` — Bitmap object. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction).\n- `offset` — Number of set bits to skip from the beginning (zero-based). [`UInt32`](/sql-reference/data-types/int-uint)\n- `cardinality_limit` — Maximum number of set bits to include in the subset. [`UInt32`](/sql-reference/data-types/int-uint)\n",
      "returnedValue": "Returns a bitmap containing at most `limit` set bits, starting after skipping `offset` set bits in ascending order. [`AggregateFunction(groupBitmap, T)`](/sql-reference/data-types/aggregatefunction)",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT bitmapToArray(subBitmap(bitmapBuild([1, 2, 3, 4, 5]), 2, 2)) AS res;\n```\n\n```response title=Response\n┌─res────┐\n│ [3, 4] │\n└────────┘\n```\n\n",
      "categories": "Bitmap"
    },
    {
      "name": "subDate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "substr",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "substring",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "substring",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "substringIndex",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "substringIndexUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "substringUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "subtractDays",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractDays(datetime, num)",
      "description": "\nSubtracts a specified number of days from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of days from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of days to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` days. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract days from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractDays(date, 31) AS subtract_days_with_date,\n    subtractDays(date_time, 31) AS subtract_days_with_date_time,\n    subtractDays(date_time_string, 31) AS subtract_days_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_days_with_date─┬─subtract_days_with_date_time─┬─subtract_days_with_date_time_string─┐\n│              2023-12-01 │          2023-12-01 00:00:00 │             2023-12-01 00:00:00.000 │\n└─────────────────────────┴──────────────────────────────┴─────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 day)\n```\n\n```response title=Response\n┌─minus(CAST('⋯valDay(10))─┐\n│               1998-06-06 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractHours",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractHours(datetime, num)",
      "description": "\nSubtracts a specified number of hours from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of hours from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of hours to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` hours. [`DateTime`](../data-types/datetime.md)/[`DateTime64(3)`](../data-types/datetime64.md).",
      "examples": "**Subtract hours from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractHours(date, 12) AS subtract_hours_with_date,\n    subtractHours(date_time, 12) AS subtract_hours_with_date_time,\n    subtractHours(date_time_string, 12) AS subtract_hours_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_hours_with_date─┬─subtract_hours_with_date_time─┬─subtract_hours_with_date_time_string─┐\n│      2023-12-31 12:00:00 │           2023-12-31 12:00:00 │              2023-12-31 12:00:00.000 │\n└──────────────────────────┴───────────────────────────────┴──────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 hour)\n```\n\n```response title=Response\n┌─minus(CAST('⋯alHour(10))─┐\n│      1998-06-15 14:00:00 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractInterval",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractInterval(interval_1, interval_2)",
      "description": "\nAdds a negated interval to another interval or tuple of intervals.\n\nNote: Intervals of the same type will be combined into a single interval. For instance if `toIntervalDay(2)` and `toIntervalDay(1)` are\npassed then the result will be `(1)` rather than `(2,1)`.\n    ",
      "arguments": "- `interval_1` — First interval or interval of tuples. [`interval`](../data-types/special-data-types/interval.md)/[`tuple`](../data-types/tuple.md)([`interval`](../data-types/special-data-types/interval.md)).\n- `interval_2` — Second interval to be negated. [`interval`](../data-types/special-data-types/interval.md).\n",
      "returnedValue": "Returns a tuple of intervals. [`tuple`](../data-types/tuple.md)([`interval`](../data-types/special-data-types/interval.md)).",
      "examples": "**Subtract intervals**\n\n```sql title=Query\nSELECT subtractInterval(INTERVAL 1 DAY, INTERVAL 1 MONTH);\nSELECT subtractInterval((INTERVAL 1 DAY, INTERVAL 1 YEAR), INTERVAL 1 MONTH);\nSELECT subtractInterval(INTERVAL 2 DAY, INTERVAL 1 DAY);\n```\n\n```response title=Response\n┌─subtractInterval(toIntervalDay(1), toIntervalMonth(1))─┐\n│ (1,-1)                                                 │\n└────────────────────────────────────────────────────────┘\n┌─subtractInterval((toIntervalDay(1), toIntervalYear(1)), toIntervalMonth(1))─┐\n│ (1,1,-1)                                                                    │\n└─────────────────────────────────────────────────────────────────────────────┘\n┌─subtractInterval(toIntervalDay(2), toIntervalDay(1))─┐\n│ (1)                                                  │\n└──────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractMicroseconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractMicroseconds(datetime, num)",
      "description": "\nSubtracts a specified number of microseconds from a date with time or a string-encoded date with time.\n    ",
      "arguments": "- `datetime` — Date with time to subtract specified number of microseconds from. [`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of microseconds to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` microseconds. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract microseconds from different date time types**\n\n```sql title=Query\nWITH\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractMicroseconds(date_time, 1000000) AS subtract_microseconds_with_date_time,\n    subtractMicroseconds(date_time_string, 1000000) AS subtract_microseconds_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_microseconds_with_date_time─┬─subtract_microseconds_with_date_time_string─┐\n│           2023-12-31 23:59:59.000000 │                  2023-12-31 23:59:59.000000 │\n└──────────────────────────────────────┴─────────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::DateTime, INTERVAL 10 microsecond)\n```\n\n```response title=Response\n┌─minus(CAST('1⋯osecond(10))─┐\n│ 1998-06-15 23:59:59.999990 │\n└────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractMilliseconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractMilliseconds(datetime, num)",
      "description": "\nSubtracts a specified number of milliseconds from a date with time or a string-encoded date with time.\n    ",
      "arguments": "- `datetime` — Date with time to subtract specified number of milliseconds from. [`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of milliseconds to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` milliseconds. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract milliseconds from different date time types**\n\n```sql title=Query\nWITH\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractMilliseconds(date_time, 1000) AS subtract_milliseconds_with_date_time,\n    subtractMilliseconds(date_time_string, 1000) AS subtract_milliseconds_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_milliseconds_with_date_time─┬─subtract_milliseconds_with_date_time_string─┐\n│              2023-12-31 23:59:59.000 │                     2023-12-31 23:59:59.000 │\n└──────────────────────────────────────┴─────────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::DateTime, INTERVAL 10 millisecond)\n```\n\n```response title=Response\n┌─minus(CAST('⋯second(10))─┐\n│  1998-06-15 23:59:59.990 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractMinutes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractMinutes(datetime, num)",
      "description": "\nSubtracts a specified number of minutes from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of minutes from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of minutes to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` minutes. [`DateTime`](../data-types/datetime.md)/[`DateTime64(3)`](../data-types/datetime64.md).",
      "examples": "**Subtract minutes from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractMinutes(date, 30) AS subtract_minutes_with_date,\n    subtractMinutes(date_time, 30) AS subtract_minutes_with_date_time,\n    subtractMinutes(date_time_string, 30) AS subtract_minutes_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_minutes_with_date─┬─subtract_minutes_with_date_time─┬─subtract_minutes_with_date_time_string─┐\n│        2023-12-31 23:30:00 │             2023-12-31 23:30:00 │                2023-12-31 23:30:00.000 │\n└────────────────────────────┴─────────────────────────────────┴────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 minute)\n```\n\n```response title=Response\n┌─minus(CAST('⋯Minute(10))─┐\n│      1998-06-15 23:50:00 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractMonths",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractMonths(datetime, num)",
      "description": "\nSubtracts a specified number of months from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of months from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of months to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` months. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract months from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractMonths(date, 1) AS subtract_months_with_date,\n    subtractMonths(date_time, 1) AS subtract_months_with_date_time,\n    subtractMonths(date_time_string, 1) AS subtract_months_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_months_with_date─┬─subtract_months_with_date_time─┬─subtract_months_with_date_time_string─┐\n│                2023-12-01 │            2023-12-01 00:00:00 │               2023-12-01 00:00:00.000 │\n└───────────────────────────┴────────────────────────────────┴───────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 month)\n```\n\n```response title=Response\n┌─minus(CAST('⋯lMonth(10))─┐\n│               1997-08-16 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractNanoseconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractNanoseconds(datetime, num)",
      "description": "\nSubtracts a specified number of nanoseconds from a date with time or a string-encoded date with time.\n    ",
      "arguments": "- `datetime` — Date with time to subtract specified number of nanoseconds from. [`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of nanoseconds to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` nanoseconds. [`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract nanoseconds from different date time types**\n\n```sql title=Query\nWITH\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractNanoseconds(date_time, 1000) AS subtract_nanoseconds_with_date_time,\n    subtractNanoseconds(date_time_string, 1000) AS subtract_nanoseconds_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_nanoseconds_with_date_time─┬─subtract_nanoseconds_with_date_time_string─┐\n│       2023-12-31 23:59:59.999999000 │              2023-12-31 23:59:59.999999000 │\n└─────────────────────────────────────┴────────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::DateTime, INTERVAL 10 nanosecond)\n```\n\n```response title=Response\n┌─minus(CAST('19⋯anosecond(10))─┐\n│ 1998-06-15 23:59:59.999999990 │\n└───────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractQuarters",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractQuarters(datetime, num)",
      "description": "\nSubtracts a specified number of quarters from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of quarters from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of quarters to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` quarters. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract quarters from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractQuarters(date, 1) AS subtract_quarters_with_date,\n    subtractQuarters(date_time, 1) AS subtract_quarters_with_date_time,\n    subtractQuarters(date_time_string, 1) AS subtract_quarters_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_quarters_with_date─┬─subtract_quarters_with_date_time─┬─subtract_quarters_with_date_time_string─┐\n│                  2023-10-01 │              2023-10-01 00:00:00 │                 2023-10-01 00:00:00.000 │\n└─────────────────────────────┴──────────────────────────────────┴─────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 quarter)\n```\n\n```response title=Response\n┌─minus(CAST('1⋯Quarter(10))─┐\n│                1996-09-16 │\n└───────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractSeconds",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractSeconds(datetime, num)",
      "description": "\nSubtracts a specified number of seconds from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of seconds from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of seconds to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` seconds. [`DateTime`](../data-types/datetime.md)/[`DateTime64(3)`](../data-types/datetime64.md).",
      "examples": "**Subtract seconds from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractSeconds(date, 60) AS subtract_seconds_with_date,\n    subtractSeconds(date_time, 60) AS subtract_seconds_with_date_time,\n    subtractSeconds(date_time_string, 60) AS subtract_seconds_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_seconds_with_date─┬─subtract_seconds_with_date_time─┬─subtract_seconds_with_date_time_string─┐\n│        2023-12-31 23:59:00 │             2023-12-31 23:59:00 │                2023-12-31 23:59:00.000 │\n└────────────────────────────┴─────────────────────────────────┴────────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 second)\n```\n\n```response title=Response\n┌─minus(CAST('⋯Second(10))─┐\n│      1998-06-15 23:59:50 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractTupleOfIntervals",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractTupleOfIntervals(datetime, intervals)",
      "description": "\nConsecutively subtracts a tuple of intervals from a date or a date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract intervals from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n- `intervals` — Tuple of intervals to subtract from `datetime`. [`Tuple(T)`](../data-types/tuple.md)([`interval`](../data-types/special-data-types/interval.md)).\n",
      "returnedValue": "Returns `date` with subtracted `intervals`. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract tuple of intervals from date**\n\n```sql title=Query\nWITH toDate('2018-01-01') AS date SELECT subtractTupleOfIntervals(date, (INTERVAL 1 DAY, INTERVAL 1 YEAR))\n```\n\n```response title=Response\n┌─subtractTupl⋯alYear(1)))─┐\n│               2016-12-31 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractWeeks",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractWeeks(datetime, num)",
      "description": "\nSubtracts a specified number of weeks from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of weeks from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of weeks to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` weeks. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract weeks from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractWeeks(date, 1) AS subtract_weeks_with_date,\n    subtractWeeks(date_time, 1) AS subtract_weeks_with_date_time,\n    subtractWeeks(date_time_string, 1) AS subtract_weeks_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_weeks_with_date─┬─subtract_weeks_with_date_time─┬─subtract_weeks_with_date_time_string─┐\n│               2023-12-25 │           2023-12-25 00:00:00 │              2023-12-25 00:00:00.000 │\n└──────────────────────────┴───────────────────────────────┴──────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 week)\n```\n\n```response title=Response\n┌─minus(CAST('⋯alWeek(10))─┐\n│               1998-04-07 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "subtractYears",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "subtractYears(datetime, num)",
      "description": "\nSubtracts a specified number of years from a date, a date with time or a string-encoded date or date with time.\n    ",
      "arguments": "- `datetime` — Date or date with time to subtract specified number of years from. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md)/[`String`](../data-types/string.md).\n- `num` — Number of years to subtract. [`(U)Int*`](../data-types/int-uint.md)/[`Float*`](../data-types/float.md).\n",
      "returnedValue": "Returns `datetime` minus `num` years. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).",
      "examples": "**Subtract years from different date types**\n\n```sql title=Query\nWITH\n    toDate('2024-01-01') AS date,\n    toDateTime('2024-01-01 00:00:00') AS date_time,\n    '2024-01-01 00:00:00' AS date_time_string\nSELECT\n    subtractYears(date, 1) AS subtract_years_with_date,\n    subtractYears(date_time, 1) AS subtract_years_with_date_time,\n    subtractYears(date_time_string, 1) AS subtract_years_with_date_time_string\n```\n\n```response title=Response\n┌─subtract_years_with_date─┬─subtract_years_with_date_time─┬─subtract_years_with_date_time_string─┐\n│               2023-01-01 │           2023-01-01 00:00:00 │              2023-01-01 00:00:00.000 │\n└──────────────────────────┴───────────────────────────────┴──────────────────────────────────────┘\n```\n\n**Using alternative INTERVAL syntax**\n\n```sql title=Query\nSELECT dateSub('1998-06-16'::Date, INTERVAL 10 year)\n```\n\n```response title=Response\n┌─minus(CAST('⋯alYear(10))─┐\n│               1988-06-16 │\n└──────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "sum",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCount",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahan",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFiltered",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArrays",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflow",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "svg",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "synonyms",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tan",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tanh",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tcpPort",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tgamma",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsU",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "throwIf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tid",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeDiff",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the difference between two dates or dates with time values. The difference is calculated in seconds units (see toRelativeSecondNum).\nIt is same as `dateDiff` and was added only for MySQL support. `dateDiff` is preferred.\n\nExample:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT timeDiff(UTCTimestamp(), now());\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "timeSeriesDeltaToGrid",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGrid",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGrid",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamples",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGrid",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStaleness",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSlot",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSlots",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeZone",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "timezone",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeZoneOf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "timezoneOf",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeZoneOffset",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "timezoneOffset",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "time_bucket",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toStartOfInterval",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timestamp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "timestamp(expr[, expr_time])",
      "description": "\nConverts the first argument `expr` to type [`DateTime64(6)`](/sql-reference/data-types/datetime64).\nIf a second argument `expr_time` is provided, it adds the specified time to the converted value.\n    ",
      "arguments": "- `expr` — Date or date with time. [`String`](/sql-reference/data-types/string).\n- `expr_time` — Optional. Time to add to the converted value. [`String`](/sql-reference/data-types/string).\n",
      "returnedValue": "Returns the converted value of `expr`, or `expr` with added time. [`DateTime64(6)`](../data-types/datetime64.md).",
      "examples": "**Convert date string to DateTime64(6)**\n\n```sql title=Query\nSELECT timestamp('2023-12-31') AS ts;\n```\n\n```response title=Response\n┌─────────────────────────ts─┐\n│ 2023-12-31 00:00:00.000000 │\n└────────────────────────────┘\n```\n\n**Add time to date string**\n\n```sql title=Query\nSELECT timestamp('2023-12-31 12:00:00', '12:00:00.11') AS ts;\n```\n\n```response title=Response\n┌─────────────────────────ts─┐\n│ 2024-01-01 00:00:00.110000 │\n└────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "timestampDiff",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "dateDiff",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timestamp_diff",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "dateDiff",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timezone",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "timezone()",
      "description": "\nReturns the time zone name of the current session or converts a time zone\noffset or name to a canonical time zone name.\n    ",
      "arguments": "",
      "returnedValue": "Returns the canonical time zone name as a [`String`](/sql-reference/data-types/string).",
      "examples": "**Get current session time zone**\n\n```sql title=Query\nSELECT timezone()\n```\n\n```response title=Response\n┌─timezone()───────┐\n│ Europe/Amsterdam │\n└──────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "timezoneOf",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "timeZoneOf(datetime)",
      "description": "\nReturns the timezone name of a [`DateTime`](/sql-reference/data-types/datetime) or [`DateTime64`](/sql-reference/data-types/datetime64) value.\n    ",
      "arguments": "- `datetime` — A value of type [`DateTime`](/sql-reference/data-types/datetime) or [`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the timezone name for `datetime`. [`String`](/sql-reference/data-types/string).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT timezoneOf(now());\n```\n\n```response title=Response\n┌─timezoneOf(now())─┐\n│ Europe/Amsterdam  │\n└───────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "timezoneOffset",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "timeZoneOffset(datetime)",
      "description": "\nReturns the timezone offset in seconds from [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).\nThe function takes daylight saving time and historical timezone changes at the specified date and time into account.\n    ",
      "arguments": "- `datetime` — `DateTime` value to get the timezone offset for. [`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the offset from UTC in seconds. [`Int32`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toDateTime('2021-04-21 10:20:30', 'America/New_York') AS Time,\ntoTypeName(Time) AS Type,\ntimeZoneOffset(Time) AS Offset_in_seconds,\n(Offset_in_seconds / 3600) AS Offset_in_hours;\n```\n\n```response title=Response\n┌────────────────Time─┬─Type─────────────────────────┬─Offset_in_seconds─┬─Offset_in_hours─┐\n│ 2021-04-21 10:20:30 │ DateTime('America/New_York') │            -14400 │              -4 │\n└─────────────────────┴──────────────────────────────┴───────────────────┴─────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toBFloat16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nConverts Float32 to BFloat16 with losing the precision.\n\nExample:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT toBFloat16(12.3::Float32);\n```\n\n```response title=Response\n12.3125\n```\n\n",
      "categories": "Type Conversion"
    },
    {
      "name": "toBFloat16OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nConverts String to Nullable(BFloat16).\n\nIf the string does not represent a floating point value, the function returns NULL.\n\nThe function allows a silent loss of precision while converting from the string representation. In that case, it will return the truncated result.\n\nExample of successful conversion:\n[example:typical]\n\nExamples of not successful conversion:\n[example:invalid1]\n[example:invalid2]\n\nExample of a loss of precision:\n[example:precision]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT toBFloat16OrNull('12.3');\n```\n\n```response title=Response\n12.3125\n```\n\n**invalid1**\n\n```sql title=Query\nSELECT toBFloat16OrNull('abc');\n```\n\n```response title=Response\nNULL\n```\n\n**invalid2**\n\n```sql title=Query\nSELECT toBFloat16OrNull(' 1');\n```\n\n```response title=Response\nNULL\n```\n\n**precision**\n\n```sql title=Query\nSELECT toBFloat16OrNull('12.3456789');\n```\n\n```response title=Response\n12.375\n```\n\n",
      "categories": "Type Conversion"
    },
    {
      "name": "toBFloat16OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nConverts String to BFloat16.\n\nIf the string does not represent a floating point value, the function returns zero.\n\nThe function allows a silent loss of precision while converting from the string representation. In that case, it will return the truncated result.\n\nExample of successful conversion:\n[example:typical]\n\nExamples of not successful conversion:\n[example:invalid1]\n[example:invalid2]\n\nExample of a loss of precision:\n[example:precision]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT toBFloat16OrZero('12.3');\n```\n\n```response title=Response\n12.3125\n```\n\n**invalid1**\n\n```sql title=Query\nSELECT toBFloat16OrZero('abc');\n```\n\n```response title=Response\n0\n```\n\n**invalid2**\n\n```sql title=Query\nSELECT toBFloat16OrZero(' 1');\n```\n\n```response title=Response\n0\n```\n\n**precision**\n\n```sql title=Query\nSELECT toBFloat16OrZero('12.3456789');\n```\n\n```response title=Response\n12.375\n```\n\n",
      "categories": "Type Conversion"
    },
    {
      "name": "toBool",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toColumnTypeName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDate32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDate32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDate32OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDate32OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTime32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTime64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTime64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTime64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTime64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTimeOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTimeOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDateTimeOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDayOfMonth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toDayOfMonth(datetime)",
      "description": "\nReturns the day of the month (1-31) of a `Date` or `DateTime`.\n        ",
      "arguments": "- `datetime` — A `Date` or `DateTime` value to get the day of month from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the day of the month of the given date/time. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toDayOfMonth(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toDayOfMonth(toDateTime('2023-04-21 10:20:30'))─┐\n│                                              21 │\n└─────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toDayOfWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toDayOfWeek(datetime[, mode[, timezone]])",
      "description": "\nReturns the number of the day within the week of a `Date` or `DateTime` value.\n\nThe two-argument form of `toDayOfWeek()` enables you to specify whether the week starts on Monday or Sunday,\nand whether the return value should be in the range from 0 to 6 or 1 to 7.\n\n| Mode | First day of week | Range                                          |\n|------|-------------------|------------------------------------------------|\n| 0    | Monday            | 1-7: Monday = 1, Tuesday = 2, ..., Sunday = 7  |\n| 1    | Monday            | 0-6: Monday = 0, Tuesday = 1, ..., Sunday = 6  |\n| 2    | Sunday            | 0-6: Sunday = 0, Monday = 1, ..., Saturday = 6 |\n| 3    | Sunday            | 1-7: Sunday = 1, Monday = 2, ..., Saturday = 7 |\n        ",
      "arguments": "- `datetime` — A Date or DateTime value to get the day of week from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n- `mode` — Optional. Integer specifying the week mode (0-3). Defaults to 0 if omitted.\n- `timezone` — Optional. String specifying the timezone.\n",
      "returnedValue": "Returns the day of the week for the given `Date` or `DateTime`. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\n-- The following date is April 21, 2023, which was a Friday:\nSELECT\n    toDayOfWeek(toDateTime('2023-04-21')),\n    toDayOfWeek(toDateTime('2023-04-21'), 1)\n```\n\n```response title=Response\n┌─toDayOfWeek(toDateTime('2023-04-21'))─┬─toDayOfWeek(toDateTime('2023-04-21'), 1)─┐\n│                                     5 │                                        4 │\n└───────────────────────────────────────┴──────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toDayOfYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toDayOfYear(datetime)",
      "description": "\nReturns the number of the day within the year (1-366) of a `Date` or `DateTime` value.\n        ",
      "arguments": "- `datetime` — A Date or DateTime value to get the day of year from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the day of the year of the given Date or DateTime. [`UInt16`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toDayOfYear(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toDayOfYear(toDateTime('2023-04-21 10:20:30'))─┐\n│                                            111 │\n└────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toDaysSinceYearZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns for a given date or date with time, the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601.\nThe calculation is the same as in MySQL's TO_DAYS() function.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT toDaysSinceYearZero(toDate('2023-09-08'))\n```\n\n```response title=Response\n713569\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toDecimal128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal128OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal128OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal128OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal256OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal256OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal256OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal32OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal32OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimal64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toDecimalString",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns string representation of a number. First argument is the number of any numeric type,\nsecond argument is the desired number of digits in fractional part. Returns String.\n\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**toDecimalString**\n\n```sql title=Query\nSELECT toDecimalString(2.1456,2)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Type Conversion"
    },
    {
      "name": "toFixedString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat32OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat32OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toFloat64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toHour",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toHour(datetime)",
      "description": "\nReturns the hour component (0-23) of a `Date` or `DateTime` value.\n        ",
      "arguments": "- `datetime` — A `Date` or `DateTime` value to get the hour from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "The hour of the given `Date` or `DateTime` value. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toHour(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toHour(toDateTime('2023-04-21 10:20:30'))─┐\n    │                                        10 │\n    └───────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toIPv4",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv4OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv4OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv4OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv6",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv6OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv6OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIPv6OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toISOWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toISOYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt128OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt128OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt128OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt16OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt16OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt16OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt256OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt256OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt256OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt32OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt32OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt8OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt8OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInt8OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toInterval",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Creates an interval from a value and a unit.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Type Conversion"
    },
    {
      "name": "toIntervalDay",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalHour",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalMicrosecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalMillisecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalMinute",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalMonth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalNanosecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalQuarter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalSecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toIntervalYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toJSONString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toLastDayOfMonth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toLastDayOfMonth(value)",
      "description": "\nRounds up a date or date with time to the last day of the month.\n\n:::note\nThe return type can be configured by setting [`enable_extended_results_for_datetime_functions`](/operations/settings/settings#enable_extended_results_for_datetime_functions).\n:::\n    ",
      "arguments": "- `value` — The date or date with time to round up to the last day of the month. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n",
      "returnedValue": "Returns the date of the last day of the month for the given date or date with time. [`Date`](../data-types/date.md).",
      "examples": "**Round up to the last day of the month**\n\n```sql title=Query\nSELECT toLastDayOfMonth(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toLastDayOfMonth(toDateTime('2023-04-21 10:20:30'))─┐\n│                                          2023-04-30 │\n└─────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toLastDayOfWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toLowCardinality",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toMillisecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toMillisecond(datetime)",
      "description": "\nReturns the millisecond component (0-999) of a `DateTime` or `DateTime64` value.\n    ",
      "arguments": "- `datetime` — A `DateTime` or `DateTime64` value to get the millisecond from. [`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the millisecond in the minute (0 - 59) of the given `Date` or `DateTime`. [`UInt16`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toMillisecond(toDateTime64('2023-04-21 10:20:30.456', 3));\n```\n\n```response title=Response\n┌──toMillisecond(toDateTime64('2023-04-21 10:20:30.456', 3))─┐\n│                                                        456 │\n└────────────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toMinute",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toMinute(datetime)",
      "description": "\nReturns the minute component (0-59) of a `Date` or `DateTime` value.\n    ",
      "arguments": "- `datetime` — A `Date` or `DateTime` value to get the minute from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the minute of the hour (0 - 59) of the given `Date` or `DateTime` value. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toMinute(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toMinute(toDateTime('2023-04-21 10:20:30'))─┐\n│                                          20 │\n└─────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toModifiedJulianDay",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toModifiedJulianDayOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toMonday",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toMonday(value)",
      "description": "\nRounds down a date or date with time to the Monday of the same week. Returns the date.\n\n:::note\nThe return type can be configured by setting [`enable_extended_results_for_datetime_functions`](/operations/settings/settings#enable_extended_results_for_datetime_functions).\n:::\n    ",
      "arguments": "- `value` — The date or date with time to round down to the Monday of the week. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n",
      "returnedValue": "Returns the date of the Monday of the same week for the given date or date with time. [`Date`](../data-types/date.md).",
      "examples": "**Round down to the Monday of the week**\n\n```sql title=Query\nSELECT\ntoMonday(toDateTime('2023-04-21 10:20:30')), -- A Friday\ntoMonday(toDate('2023-04-24'));              -- Already a Monday\n```\n\n```response title=Response\n┌─toMonday(toDateTime('2023-04-21 10:20:30'))─┬─toMonday(toDate('2023-04-24'))─┐\n│                                  2023-04-17 │                     2023-04-24 │\n└─────────────────────────────────────────────┴────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toMonth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toMonth(datetime)",
      "description": "\nReturns the month component (1-12) of a `Date` or `DateTime` value.\n    ",
      "arguments": "- `datetime` — A Date or DateTime value to get the month from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the month of the given date/time. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toMonth(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toMonth(toDateTime('2023-04-21 10:20:30'))─┐\n│                                          4 │\n└────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toMonthNumSinceEpoch",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toMonthNumSinceEpoch(date)",
      "description": "Returns amount of months passed from year 1970",
      "arguments": "- `date` — Date, DateTime or DateTime64\n",
      "returnedValue": "Positive integer",
      "examples": "**Example**\n\n```sql title=Query\nSELECT toMonthNumSinceEpoch(toDate('2024-10-01'))\n```\n\n```response title=Response\n657\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toNullable",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toQuarter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toQuarter(datetime)",
      "description": "\nReturns the quarter of the year (1-4) for a given `Date` or `DateTime` value.\n    ",
      "arguments": "- `datetime` — A `Date` or `DateTime` value to get the quarter of the year from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "The quarter of the year for the given date/time. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toQuarter(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toQuarter(toDateTime('2023-04-21 10:20:30'))─┐\n│                                            2 │\n└──────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toRelativeDayNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeHourNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeMinuteNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeMonthNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeQuarterNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeSecondNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeWeekNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toRelativeYearNum",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toSecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toSecond(datetime)",
      "description": "\nReturns the second component (0-59) of a `Date` or `DateTime` value.\n        ",
      "arguments": "- `datetime` — A `Date` or `DateTime` value to get the second from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the second in the minute (0 - 59) of the given `Date` or `DateTime` value. [`UInt8`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toSecond(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toSecond(toDateTime('2023-04-21 10:20:30'))─┐\n│                                          30 │\n└─────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toStartOfDay",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfFifteenMinutes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfFiveMinute",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "toStartOfFiveMinutes",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfFiveMinutes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfHour",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfISOYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toStartOfISOYear(value)",
      "description": "\nRounds down a date or date with time to the first day of the ISO year, which can be different than a regular year. See [ISO week date](https://en.wikipedia.org/wiki/ISO_week_date).\n\n:::note\nThe return type can be configured by setting [`enable_extended_results_for_datetime_functions`](/operations/settings/settings#enable_extended_results_for_datetime_functions).\n:::\n    ",
      "arguments": "- `value` — The date or date with time to round down to the first day of the ISO year. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n",
      "returnedValue": "Returns the first day of the ISO year for the given date or date with time. [`Date`](../data-types/date.md).",
      "examples": "**Round down to the first day of the ISO year**\n\n```sql title=Query\nSELECT toStartOfISOYear(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toStartOfISOYear(toDateTime('2023-04-21 10:20:30'))─┐\n│                                          2023-01-02 │\n└─────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toStartOfInterval",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfMicrosecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfMillisecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfMinute",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfMonth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toStartOfMonth(value)",
      "description": "\nRounds down a date or date with time to the first day of the month.\n\n:::note\nThe return type can be configured by setting [`enable_extended_results_for_datetime_functions`](/operations/settings/settings#enable_extended_results_for_datetime_functions).\n:::\n    ",
      "arguments": "- `value` — The date or date with time to round down to the first day of the month. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n",
      "returnedValue": "Returns the first day of the month for the given date or date with time. [`Date`](../data-types/date.md).",
      "examples": "**Round down to the first day of the month**\n\n```sql title=Query\nSELECT toStartOfMonth(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toStartOfMonth(toDateTime('2023-04-21 10:20:30'))─┐\n│                                        2023-04-01 │\n└───────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toStartOfNanosecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfQuarter",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toStartOfQuarter(value)",
      "description": "\nRounds down a date or date with time to the first day of the quarter. The first day of the quarter is either 1 January, 1 April, 1 July, or 1 October.\n\n:::note\nThe return type can be configured by setting [`enable_extended_results_for_datetime_functions`](/operations/settings/settings#enable_extended_results_for_datetime_functions).\n:::\n    ",
      "arguments": "- `value` — The date or date with time to round down to the first day of the quarter. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n",
      "returnedValue": "Returns the first day of the quarter for the given date or date with time. [`Date`](../data-types/date.md).",
      "examples": "**Round down to the first day of the quarter**\n\n```sql title=Query\nSELECT toStartOfQuarter(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toStartOfQuarter(toDateTime('2023-04-21 10:20:30'))─┐\n│                                          2023-04-01 │\n└─────────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toStartOfSecond",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfTenMinutes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStartOfYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toStartOfYear(value)",
      "description": "\nRounds down a date or date with time to the first day of the year. Returns the date as a `Date` object.\n\n:::note\nThe return type can be configured by setting [`enable_extended_results_for_datetime_functions`](/operations/settings/settings#enable_extended_results_for_datetime_functions).\n:::\n    ",
      "arguments": "- `value` — The date or date with time to round down. [`Date`](../data-types/date.md)/[`Date32`](../data-types/date32.md)/[`DateTime`](../data-types/datetime.md)/[`DateTime64`](../data-types/datetime64.md).\n",
      "returnedValue": "Returns the first day of the year for the given date/time. [`Date`](../data-types/date.md).",
      "examples": "**Round down to the first day of the year**\n\n```sql title=Query\nSELECT toStartOfYear(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toStartOfYear(toDateTime('2023-04-21 10:20:30'))─┐\n│                                       2023-01-01 │\n└──────────────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toStringCutToZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTime64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTime64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTime64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTimeOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTimeOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTimeWithFixedDate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTimeZone",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "toTimezone",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toTimezone",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toTimeZone(datetime, timezone)",
      "description": "\nConverts a `DateTime` or `DateTime64` to the specified time zone.\nThe internal value (number of unix seconds) of the data doesn't change.\nOnly the value's time zone attribute and the value's string representation changes.\n        ",
      "arguments": "- `date` — The value to convert. [`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n- `timezone` — The target time zone name as a [`String`](/sql-reference/data-types/string).\n",
      "returnedValue": "Returns the same timestamp as the input, but with the specified time zone. [`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toDateTime('2019-01-01 00:00:00', 'UTC') AS time_utc,\ntoTypeName(time_utc) AS type_utc,\ntoInt32(time_utc) AS int32utc,\ntoTimeZone(time_utc, 'Asia/Yekaterinburg') AS time_yekat,\ntoTypeName(time_yekat) AS type_yekat,\ntoInt32(time_yekat) AS int32yekat,\ntoTimeZone(time_utc, 'US/Samoa') AS time_samoa,\ntoTypeName(time_samoa) AS type_samoa,\ntoInt32(time_samoa) AS int32samoa\nFORMAT Vertical;\n```\n\n```response title=Response\nRow 1:\n──────\ntime_utc:   2019-01-01 00:00:00\ntype_utc:   DateTime('UTC')\nint32utc:   1546300800\ntime_yekat: 2019-01-01 05:00:00\ntype_yekat: DateTime('Asia/Yekaterinburg')\nint32yekat: 1546300800\ntime_samoa: 2018-12-31 13:00:00\ntype_samoa: DateTime('US/Samoa')\nint32samoa: 1546300800\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toTypeName",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt128",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt128OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nConverts a string in the first argument of the function to UInt128 by parsing it.\nIf it cannot parse the value, returns the default value, which can be provided as the second function argument, and if provided, must be of UInt128 type.\nIf the default value is not provided in the second argument, it is assumed to be zero.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**Successful conversion**\n\n```sql title=Query\nSELECT toUInt128OrDefault('1', 2::UInt128)\n```\n\n```response title=Response\n1\n```\n\n**Default value**\n\n```sql title=Query\nSELECT toUInt128OrDefault('upyachka', 123456789012345678901234567890::UInt128)\n```\n\n```response title=Response\n123456789012345678901234567890\n```\n\n**Implicit default value**\n\n```sql title=Query\nSELECT toUInt128OrDefault('upyachka')\n```\n\n```response title=Response\n0\n```\n\n",
      "categories": "Type Conversion"
    },
    {
      "name": "toUInt128OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt128OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt16",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt16OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt16OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt16OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt256",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt256OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt256OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt256OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt32OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt32OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt32OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt64OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt64OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt64OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt8OrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt8OrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUInt8OrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUTCTimestamp",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUUID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUUIDOrDefault",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUUIDOrNull",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUUIDOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUnixTimestamp",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toUnixTimestamp(date, [timezone])",
      "description": "\nConverts a `String`, `Date`, or `DateTime` to a Unix timestamp (seconds since `1970-01-01 00:00:00 UTC`) as `UInt32`.\n    ",
      "arguments": "- `date` — Value to convert. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64)/[`String`](/sql-reference/data-types/string).\n- `timezone` — Optional. Timezone to use for conversion. If not specified, the server's timezone is used. [`String`](/sql-reference/data-types/string).\n",
      "returnedValue": "Returns the Unix timestamp as [`UInt32`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT\n'2017-11-05 08:07:47' AS dt_str,\ntoUnixTimestamp(dt_str) AS from_str,\ntoUnixTimestamp(dt_str, 'Asia/Tokyo') AS from_str_tokyo,\ntoUnixTimestamp(toDateTime(dt_str)) AS from_datetime,\ntoUnixTimestamp(toDateTime64(dt_str, 0)) AS from_datetime64,\ntoUnixTimestamp(toDate(dt_str)) AS from_date,\ntoUnixTimestamp(toDate32(dt_str)) AS from_date32\nFORMAT Vertical;\n```\n\n```response title=Response\nRow 1:\n──────\ndt_str:          2017-11-05 08:07:47\nfrom_str:        1509869267\nfrom_str_tokyo:  1509836867\nfrom_datetime:   1509869267\nfrom_datetime64: 1509869267\nfrom_date:       1509840000\nfrom_date32:     1509840000\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toUnixTimestamp64Micro",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUnixTimestamp64Milli",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUnixTimestamp64Nano",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toUnixTimestamp64Second",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toValidUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toYYYYMM",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toYYYYMMDD",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toYYYYMMDDhhmmss",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "toYear",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toYear(datetime)",
      "description": "\nReturns the year component (AD) of a `Date` or `DateTime` value.\n    ",
      "arguments": "- `datetime` — A `Date` or `DateTime` value to get the year from. [`Date`](/sql-reference/data-types/date)/[`Date32`](/sql-reference/data-types/date32)/[`DateTime`](/sql-reference/data-types/datetime)/[`DateTime64`](/sql-reference/data-types/datetime64).\n",
      "returnedValue": "Returns the year of the given Date or DateTime. [`UInt16`](/sql-reference/data-types/int-uint).",
      "examples": "**Usage example**\n\n```sql title=Query\nSELECT toYear(toDateTime('2023-04-21 10:20:30'))\n```\n\n```response title=Response\n┌─toYear(toDateTime('2023-04-21 10:20:30'))─┐\n    │                                     2023  │\n    └───────────────────────────────────────────┘\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toYearNumSinceEpoch",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "toYearNumSinceEpoch(date)",
      "description": "Returns amount of years passed from year 1970",
      "arguments": "- `date` — Date, DateTime or DateTime64\n",
      "returnedValue": "Positive integer",
      "examples": "**Example**\n\n```sql title=Query\nSELECT toYearNumSinceEpoch(toDate('2024-10-01'))\n```\n\n```response title=Response\n54\n```\n\n",
      "categories": "Dates and Times"
    },
    {
      "name": "toYearWeek",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "to_utc_timestamp",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toUTCTimestamp",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "today",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tokens",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Splits the text into tokens by a given tokenizer.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "String Splitting"
    },
    {
      "name": "topK",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeighted",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topLevelDomain",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nExtracts the the top-level domain from a URL.\n\nReturns an empty string if the argument cannot be parsed as a URL or does not contain a top-level domain.\n        ",
      "arguments": "",
      "returnedValue": "",
      "examples": "**topLevelDomain**\n\n```sql title=Query\nSELECT topLevelDomain('svn+ssh://www.some.svn-hosting.com:80/repo/trunk')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "URL"
    },
    {
      "name": "topLevelDomainRFC",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to topLevelDomain, but conforms to RFC 3986.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "URL"
    },
    {
      "name": "transactionID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "transactionLatestSnapshot",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "transactionOldestSnapshot",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "transform",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "translate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "translateUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "trim",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "trimBoth",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "trimBoth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "trimLeft",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "trimRight",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "trunc",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "truncate",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "trunc",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tryBase32Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nDecode a [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoded string. If the input string is not a valid Base32 return an empty string.",
      "arguments": "- `arg` — A Base32 (rfc4648) encoded string\n",
      "returnedValue": "",
      "examples": "**simple_decoding1**\n\n```sql title=Query\nSELECT tryBase32Decode('ME======')\n```\n\n```response title=Response\na\n```\n\n**simple_decoding2**\n\n```sql title=Query\nSELECT tryBase32Decode('JBSWY3DP')\n```\n\n```response title=Response\nHello\n```\n\n**non_ascii**\n\n```sql title=Query\nSELECT hex(tryBase32Decode('4W2HIXV4'))\n```\n\n```response title=Response\nE5B4745EBC\n```\n\n**invalid_base32**\n\n```sql title=Query\nSELECT tryBase32Decode('invalid_base32')\n```\n\n```response title=Response\n\n```\n\n**empty_string**\n\n```sql title=Query\nSELECT tryBase32Decode('')\n```\n\n```response title=Response\n\n```\n\n**non_base32_characters**\n\n```sql title=Query\nSELECT tryBase32Decode('12345')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "String"
    },
    {
      "name": "tryBase58Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tryBase64Decode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "tryBase64Decode(encoded)",
      "description": "Decodes a String or FixedString from base64, like base64Decode but returns an empty string in case of an error.",
      "arguments": "- `encoded` — String column or constant. If the string is not a valid Base64-encoded value, returns an empty string.\n",
      "returnedValue": "A string containing the decoded value of the argument.",
      "examples": "**valid**\n\n```sql title=Query\nSELECT tryBase64Decode('Y2xpY2tob3VzZQ==')\n```\n\n```response title=Response\nclickhouse\n```\n\n**invalid**\n\n```sql title=Query\nSELECT tryBase64Decode('invalid')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "tryBase64URLDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "tryBase64URLDecode(encodedUrl)",
      "description": "Decodes an URL from base64, like base64URLDecode but returns an empty string in case of an error.",
      "arguments": "- `encodedURL` — String column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, returns an empty string.\n",
      "returnedValue": "A string containing the decoded value of the argument.",
      "examples": "**valid**\n\n```sql title=Query\nSELECT tryBase64URLDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')\n```\n\n```response title=Response\nhttps://clickhouse.com\n```\n\n**invalid**\n\n```sql title=Query\nSELECT tryBase64UrlDecode('aHR0cHM6Ly9jbGlja')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "tryDecrypt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Similar to `decrypt`, but returns NULL if decryption fails because of using the wrong key.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": "Encryption"
    },
    {
      "name": "tryIdnaEncode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "punycodeEncode(str)",
      "description": "\nComputes a ASCII representation of an Internationalized Domain Name. Returns an empty string in case of error",
      "arguments": "- `str` — Input string\n",
      "returnedValue": "An ASCII-encoded domain name [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT idnaEncodeOrNull('München') AS ascii;\n```\n\n```response title=Response\n┌─ascii───────────────────────────┐\n│ xn--strae-oqa.xn--mnchen-3ya.de │\n└─────────────────────────────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "tryPunycodeDecode",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "punycodeDecode(str)",
      "description": "\nComputes a Punycode representation of a string. Returns an empty string if the input is not valid Punycode.",
      "arguments": "- `str` — A Punycode-encoded string\n",
      "returnedValue": "The plaintext representation [String](/sql-reference/data-types/string.md).",
      "examples": "**simple**\n\n```sql title=Query\nSELECT tryPunycodeDecode('Mnchen-3ya') AS plain;\n```\n\n```response title=Response\n┌─plain───┐\n│ München │\n└─────────┘\n```\n\n",
      "categories": "Encoding"
    },
    {
      "name": "tumble",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tumbleEnd",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tumbleStart",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tuple",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns a tuple by grouping input arguments.\n\nFor columns C1, C2, ... with the types T1, T2, ..., it returns a named Tuple(C1 T1, C2 T2, ...) type tuple containing these columns if their names are unique and can be treated as unquoted identifiers, otherwise a Tuple(T1, T2, ...) is returned. There is no cost to execute the function.\nTuples are normally used as intermediate values for an argument of IN operators, or for creating a list of formal parameters of lambda functions. Tuples can't be written to a table.\n\nThe function implements the operator `(x, y, ...)`.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT tuple(1, 2)\n```\n\n```response title=Response\n(1,2)\n```\n\n",
      "categories": "Tuple"
    },
    {
      "name": "tupleConcat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleDivide",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleDivideByNumber",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleElement",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleHammingDistance",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleIntDiv",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleIntDivByNumber",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleIntDivOrZero",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleIntDivOrZeroByNumber",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleMinus",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleModulo",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleModuloByNumber",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleMultiply",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleMultiplyByNumber",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleNames",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nConverts a tuple into an array of column names. For a tuple in the form `Tuple(a T, b T, ...)`, it returns an array of strings representing the named columns of the tuple. If the tuple elements do not have explicit names, their indices will be used as the column names instead.\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nSELECT tupleNames(tuple(1 as a, 2 as b))\n```\n\n```response title=Response\n['a','b']\n```\n\n",
      "categories": "Tuple"
    },
    {
      "name": "tupleNegate",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tuplePlus",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "tupleToNameValuePairs",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ucase",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "upper",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "unbin",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "unhex",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniq",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExact",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqTheta",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaIntersect",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nTwo uniqThetaSketch objects to do intersect calculation(set operation ∩), the result is a new uniqThetaSketch.\n\nA uniqThetaSketch object is to be constructed by aggregation function uniqTheta with -State.\n\nUniqThetaSketch is a data structure storage of approximate values set.\nFor more information on RoaringBitmap, see: [Theta Sketch Framework](https://datasketches.apache.org/docs/Theta/ThetaSketchFramework.html).\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nselect finalizeAggregation(uniqThetaIntersect(arrayReduce('uniqThetaState',[1,2]), arrayReduce('uniqThetaState',[2,3,4])));\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "uniqThetaNot",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nTwo uniqThetaSketch objects to do a_not_b calculation(set operation ×), the result is a new uniqThetaSketch.\n\nA uniqThetaSketch object is to be constructed by aggregation function uniqTheta with -State.\n\nUniqThetaSketch is a data structure storage of approximate values set.\nFor more information on RoaringBitmap, see: [Theta Sketch Framework](https://datasketches.apache.org/docs/Theta/ThetaSketchFramework.html).\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nselect finalizeAggregation(uniqThetaNot(arrayReduce('uniqThetaState',[1,2]), arrayReduce('uniqThetaState',[2,3,4])));\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "uniqThetaUnion",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nTwo uniqThetaSketch objects to do union calculation(set operation ∪), the result is a new uniqThetaSketch.\n\nA uniqThetaSketch object is to be constructed by aggregation function uniqTheta with -State.\n\nUniqThetaSketch is a data structure storage of approximate values set.\nFor more information on RoaringBitmap, see: [Theta Sketch Framework](https://datasketches.apache.org/docs/Theta/ThetaSketchFramework.html).\n\nTypical usage:\n[example:typical]\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**typical**\n\n```sql title=Query\nselect finalizeAggregation(uniqThetaUnion(arrayReduce('uniqThetaState',[1,2]), arrayReduce('uniqThetaState',[2,3,4])));\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Other"
    },
    {
      "name": "uniqUpTo",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "upper",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "upperUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "upperUTF8(input)",
      "description": "Converts a string to lowercase, assuming that the string contains valid UTF-8 encoded text. If this assumption is violated, no exception is thrown and the result is undefined.",
      "arguments": "- `input` — Input with String type\n",
      "returnedValue": "A String data type value",
      "examples": "**first**\n\n```sql title=Query\nSELECT upperUTF8('München') as Upperutf8;\n```\n\n```response title=Response\nMÜNCHEN\n```\n\n",
      "categories": "String"
    },
    {
      "name": "uptime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "user",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "currentUser",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "validateNestedArraySizes",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPop",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSamp",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStable",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "variantElement",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "variantElement(variant, type_name, [, default_value])",
      "description": "\nExtracts a column with specified type from a `Variant` column.\n",
      "arguments": "- `variant` — Variant column\n- `type_name` — The name of the variant type to extract\n- `default_value` — The default value that will be used if variant doesn't have variant with specified type. Can be any type. Optional\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;\nINSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);\nSELECT v, variantElement(v, 'String'), variantElement(v, 'UInt64'), variantElement(v, 'Array(UInt64)') FROM test;\n```\n\n```response title=Response\n┌─v─────────────┬─variantElement(v, 'String')─┬─variantElement(v, 'UInt64')─┬─variantElement(v, 'Array(UInt64)')─┐\n│ ᴺᵁᴸᴸ          │ ᴺᵁᴸᴸ                        │                        ᴺᵁᴸᴸ │ []                                 │\n│ 42            │ ᴺᵁᴸᴸ                        │                          42 │ []                                 │\n│ Hello, World! │ Hello, World!               │                        ᴺᵁᴸᴸ │ []                                 │\n│ [1,2,3]       │ ᴺᵁᴸᴸ                        │                        ᴺᵁᴸᴸ │ [1,2,3]                            │\n└───────────────┴─────────────────────────────┴─────────────────────────────┴────────────────────────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "variantType",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "variantType(variant)",
      "description": "\nReturns the variant type name for each row of `Variant` column. If row contains NULL, it returns 'None' for it.\n",
      "arguments": "- `variant` — Variant column\n",
      "returnedValue": "",
      "examples": "**Example**\n\n```sql title=Query\nCREATE TABLE test (v Variant(UInt64, String, Array(UInt64))) ENGINE = Memory;\nINSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);\nSELECT variantType(v) FROM test;\n```\n\n```response title=Response\n┌─variantType(v)─┐\n│ None           │\n│ UInt64         │\n│ String         │\n│ Array(UInt64)  │\n└────────────────┘\n```\n\n",
      "categories": "JSON"
    },
    {
      "name": "vectorDifference",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "tupleMinus",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "vectorSum",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "tuplePlus",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "version",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visibleWidth",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamExtractBool",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONExtractBool",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamExtractFloat",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONExtractFloat",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamExtractInt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONExtractInt",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamExtractRaw",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONExtractRaw",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamExtractString",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONExtractString",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamExtractUInt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONExtractUInt",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "visitParamHas",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "simpleJSONHas",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "week",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toWeek",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTest",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "widthBucket",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "\nReturns the number of the bucket in which `operand` falls in a histogram having `count` equal-width buckets spanning the range `low` to `high`. Returns `0` if `operand < low`, and returns `count+1` if `operand >= high`.\n\n`operand`, `low`, `high` can be any native number type. `count` can only be unsigned native integer and its value cannot be zero.\n\n**Syntax**\n\n```sql\nwidthBucket(operand, low, high, count)\n```\n\nThere is also a case insensitive alias called `WIDTH_BUCKET` to provide compatibility with other databases.\n\n**Example**\n\nQuery:\n[example:simple]\n\nResult:\n\n```text\n┌─widthBucket(10.15, -8.6, 23, 18)─┐\n│                               11 │\n└──────────────────────────────────┘\n```\n",
      "arguments": "",
      "returnedValue": "",
      "examples": "**simple**\n\n```sql title=Query\nSELECT widthBucket(10.15, -8.6, 23, 18)\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Mathematical"
    },
    {
      "name": "width_bucket",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "widthBucket",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnel",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowID",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wkt",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashArg",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashArgCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashArgCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashArgUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleMinHashUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleSimHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleSimHashCaseInsensitive",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleSimHashCaseInsensitiveUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wordShingleSimHashUTF8",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "wyHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "xor",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "xxHash32",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "xxHash64",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "xxh3",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Calculates value of XXH3 64-bit hash function. Refer to https://github.com/Cyan4973/xxHash for detailed documentation.",
      "arguments": "",
      "returnedValue": "",
      "examples": "**hash**\n\n```sql title=Query\nSELECT xxh3('ClickHouse')\n```\n\n```response title=Response\n\n```\n\n",
      "categories": "Hash"
    },
    {
      "name": "yandexConsistentHash",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": "kostikConsistentHash",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "yearweek",
      "isAggregate": false,
      "caseInsensitive": true,
      "aliasTo": "toYearWeek",
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "yesterday",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "zookeeperSessionUptime",
      "isAggregate": false,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "aggThrowState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `aggThrow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "analysisOfVarianceState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `analysisOfVariance`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anySimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `any`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavySimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyHeavyState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `anyHeavy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLastState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `anyLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "anyLast_respect_nullsState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `anyLast_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "any_respect_nullsState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `any_respect_nulls`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_kState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `approx_top_k`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "approx_top_sumState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `approx_top_sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMaxState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `argMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "argMinState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `argMin`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `avg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "avgWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `avgWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "boundingRatioState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `boundingRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "categoricalInformationValueState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `categoricalInformationValue`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencySimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "contingencyState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `contingency`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `corr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrMatrixState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `corrMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "corrStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `corrStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "countState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `count`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `covarPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopMatrixState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `covarPopMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarPopStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `covarPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `covarSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampMatrixState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `covarSampMatrix`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "covarSampStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `covarSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `cramersV`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "cramersVBiasCorrectedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `cramersVBiasCorrected`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `deltaSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "deltaSumTimestampState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `deltaSumTimestamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "denseRankState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `denseRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctDynamicTypesState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `distinctDynamicTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `distinctJSONPaths`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "distinctJSONPathsAndTypesState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `distinctJSONPathsAndTypes`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropySimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "entropyState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `entropy`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "estimateCompressionRatioState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `estimateCompressionRatio`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialMovingAverageState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `exponentialMovingAverage`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedAvgState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `exponentialTimeDecayedAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedCountState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `exponentialTimeDecayedCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedMaxState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `exponentialTimeDecayedMax`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "exponentialTimeDecayedSumState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `exponentialTimeDecayedSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "flameGraphState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `flameGraph`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayInsertAtState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArrayInsertAt`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayIntersectState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArrayIntersect`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayLastState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArrayLast`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingAvgState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArrayMovingAvg`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArrayMovingSumState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArrayMovingSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySampleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArraySample`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupArraySortedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupArraySorted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitAndState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitOrState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitXorState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitmap`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapAndState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitmapAnd`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapOrState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitmapOr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupBitmapXorState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupBitmapXor`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupConcatState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupConcat`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArraySimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "groupUniqArrayState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `groupUniqArray`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "histogramState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `histogram`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "intervalLengthSumState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `intervalLengthSum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kolmogorovSmirnovTestState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `kolmogorovSmirnovTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtPopState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `kurtPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "kurtSampState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `kurtSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `lag`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "lagInFrameState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `lagInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "largestTriangleThreeBucketsState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `largestTriangleThreeBuckets`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `lead`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "leadInFrameState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `leadInFrame`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "mannWhitneyUTestState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `mannWhitneyUTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `max`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `maxIntersections`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxIntersectionsPositionState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `maxIntersectionsPosition`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "maxMappedArraysState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `maxMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "meanZTestState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `meanZTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `min`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "minMappedArraysState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `minMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nonNegativeDerivativeState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `nonNegativeDerivative`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `nothing`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingNullState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `nothingNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64ArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64ArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64Array",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64Distinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64ForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64If",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64Map",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64Merge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64OrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64OrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64Resample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64SimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nothingUInt64State",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `nothingUInt64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "nth_valueState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `nth_value`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "ntileState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `ntile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "percentRankState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `percentRank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantile`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16ArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16ArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16Array",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16Distinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16ForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16If",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16Map",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16Merge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16OrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16OrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16Resample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16SimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16State",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileBFloat16WeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDDState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileDeterministicState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactExclusiveState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactHighState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactInclusiveState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactLowState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileExactWeightedInterpolatedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileGKState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileInterpolatedWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTDigestWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantileTimingWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantileTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantiles`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16ArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16ArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16Array",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16Distinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16ForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16If",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16Map",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16Merge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16OrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16OrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16Resample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16SimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16State",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesBFloat16`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesBFloat16WeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesBFloat16Weighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDDState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesDD`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesDeterministicState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesDeterministic`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactExclusiveState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExactExclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactHighState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExactHigh`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactInclusiveState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExactInclusive`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactLowState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExactLow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExactWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesExactWeightedInterpolatedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesExactWeightedInterpolated`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesGKState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesGK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesInterpolatedWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesInterpolatedWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesTDigest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTDigestWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesTDigestWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesTiming`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "quantilesTimingWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `quantilesTimingWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `rank`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "rankCorrState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `rankCorr`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "retentionState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `retention`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "row_numberState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `row_number`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceCountState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sequenceCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sequenceMatch`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceMatchEventsState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sequenceMatchEvents`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sequenceNextNodeState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sequenceNextNode`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "simpleLinearRegressionState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `simpleLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "singleValueOrNullState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `singleValueOrNull`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewPopState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `skewPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "skewSampState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `skewSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sparkbarState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sparkbar`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `stddevPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevPopStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `stddevPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `stddevSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stddevSampStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `stddevSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLinearRegressionState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `stochasticLinearRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "stochasticLogisticRegressionState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `stochasticLogisticRegression`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "studentTTestState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `studentTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumArgMax",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumArgMin",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumArray",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumDistinct",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumForEach",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumIf",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMap",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMerge",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumOrDefault",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumOrNull",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumResample",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumSimpleState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumState",
      "isAggregate": true,
      "caseInsensitive": true,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sum`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumCountState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumCount`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumKahanState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumKahan`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumMapFiltered`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapFilteredWithOverflowState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumMapFilteredWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMapWithOverflowState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumMapWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumMappedArraysState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumMappedArrays`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "sumWithOverflowState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `sumWithOverflow`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "theilsUState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `theilsU`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesDeltaToGridState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `timeSeriesDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantDeltaToGridState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `timeSeriesInstantDeltaToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesInstantRateToGridState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `timeSeriesInstantRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesLastTwoSamplesState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `timeSeriesLastTwoSamples`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesRateToGridState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `timeSeriesRateToGrid`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "timeSeriesResampleToGridWithStalenessState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `timeSeriesResampleToGridWithStaleness`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `topK`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "topKWeightedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `topKWeighted`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniq`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombinedState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniqCombined`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64ArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64ArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64Array",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64Distinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64ForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64If",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64Map",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64Merge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64OrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64OrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64Resample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64SimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqCombined64State",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniqCombined64`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqExactState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniqExact`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12ArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12ArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12Array",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12Distinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12ForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12If",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12Map",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12Merge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12OrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12OrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12Resample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12SimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqHLL12State",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniqHLL12`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqThetaState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniqTheta`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "uniqUpToState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `uniqUpTo`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `varPop`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varPopStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `varPopStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `varSamp`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "varSampStableState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `varSampStable`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "welchTTestState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `welchTTest`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelArgMax",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMax` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelArgMin",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ArgMin` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelArray",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Array` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelDistinct",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Distinct` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelForEach",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `ForEach` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelIf",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `If` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelMap",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Map` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelMerge",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Merge` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelOrDefault",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrDefault` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelOrNull",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `OrNull` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelResample",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `Resample` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelSimpleState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `SimpleState` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    },
    {
      "name": "windowFunnelState",
      "isAggregate": true,
      "caseInsensitive": false,
      "aliasTo": null,
      "syntax": "",
      "description": "Generated by applying the `State` aggregate combinator to `windowFunnel`.",
      "arguments": "",
      "returnedValue": "",
      "examples": "",
      "categories": ""
    }
  ],
  "keywords": [
    "ADD",
    "ADD COLUMN",
    "ADD CONSTRAINT",
    "ADD INDEX",
    "ADD PROJECTION",
    "ADD STATISTICS",
    "ADMIN",
    "ADMIN OPTION FOR",
    "AFTER",
    "ALGORITHM",
    "ALIAS",
    "ALL",
    "ALL PROFILES",
    "ALL SETTINGS",
    "ALLOWED_LATENESS",
    "ALTER",
    "ALTER COLUMN",
    "ALTER DATABASE",
    "ALTER LIVE VIEW",
    "ALTER POLICY",
    "ALTER PROFILE",
    "ALTER PROFILES",
    "ALTER QUOTA",
    "ALTER ROLE",
    "ALTER ROW POLICY",
    "ALTER SETTINGS PROFILE",
    "ALTER TABLE",
    "ALTER TEMPORARY TABLE",
    "ALTER USER",
    "AND",
    "AND STDOUT",
    "ANTI",
    "ANY",
    "APPEND",
    "APPLY",
    "APPLY DELETED MASK",
    "APPLY PATCHES",
    "ARRAY",
    "ARRAY JOIN",
    "AS",
    "ASC",
    "ASCENDING",
    "ASOF",
    "ASSUME",
    "AST",
    "ASYNC",
    "ATTACH",
    "ATTACH PART",
    "ATTACH PARTITION",
    "ATTACH POLICY",
    "ATTACH PROFILE",
    "ATTACH QUOTA",
    "ATTACH ROLE",
    "ATTACH ROW POLICY",
    "ATTACH SETTINGS PROFILE",
    "ATTACH USER",
    "AUTO_INCREMENT",
    "AZURE",
    "BACKUP",
    "bagexpansion",
    "base_backup",
    "BCRYPT_HASH",
    "BCRYPT_PASSWORD",
    "BEGIN",
    "BEGIN TRANSACTION",
    "BETWEEN",
    "BIDIRECTIONAL",
    "BOTH",
    "BY",
    "CASCADE",
    "CASE",
    "CAST",
    "CHANGE",
    "CHANGEABLE_IN_READONLY",
    "CHANGED",
    "CHAR",
    "CHAR VARYING",
    "CHARACTER",
    "CHARACTER LARGE OBJECT",
    "CHARACTER VARYING",
    "CHECK",
    "CHECK ALL TABLES",
    "CHECK GRANT",
    "CHECK TABLE",
    "CLEANUP",
    "CLEAR",
    "CLEAR COLUMN",
    "CLEAR INDEX",
    "CLEAR PROJECTION",
    "CLEAR STATISTICS",
    "CLONE",
    "CLONE AS",
    "CLUSTER",
    "cluster_host_ids",
    "CLUSTERS",
    "CN",
    "CODEC",
    "COLLATE",
    "COLUMN",
    "COLUMNS",
    "COMMENT",
    "COMMENT COLUMN",
    "COMMIT",
    "COMPRESSION",
    "CONNECTIONS",
    "CONST",
    "CONSTRAINT",
    "CREATE",
    "CREATE POLICY",
    "CREATE PROFILE",
    "CREATE QUOTA",
    "CREATE ROLE",
    "CREATE ROW POLICY",
    "CREATE SETTINGS PROFILE",
    "CREATE TABLE",
    "CREATE TEMPORARY TABLE",
    "CREATE USER",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT GRANTS",
    "CURRENT QUOTA",
    "CURRENT ROLES",
    "CURRENT ROW",
    "CURRENT TRANSACTION",
    "CURRENT_USER",
    "CURRENTUSER",
    "D",
    "DATA",
    "DATA INNER UUID",
    "DATABASE",
    "DATABASES",
    "DATE",
    "DAY",
    "DAYS",
    "DD",
    "DEALLOCATE",
    "DEDUPLICATE",
    "DEFAULT",
    "DEFAULT DATABASE",
    "DEFAULT ROLE",
    "DEFINER",
    "DELETE",
    "DEPENDS",
    "DEPENDS ON",
    "DESC",
    "DESCENDING",
    "DESCRIBE",
    "DETACH",
    "DETACH PART",
    "DETACH PARTITION",
    "DICTIONARIES",
    "DICTIONARY",
    "DISK",
    "DISTINCT",
    "DISTINCT ON",
    "DIV",
    "DOUBLE_SHA1_HASH",
    "DOUBLE_SHA1_PASSWORD",
    "DROP",
    "DROP COLUMN",
    "DROP CONSTRAINT",
    "DROP DEFAULT",
    "DROP DETACHED PART",
    "DROP DETACHED PARTITION",
    "DROP INDEX",
    "DROP PART",
    "DROP PARTITION",
    "DROP PROJECTION",
    "DROP STATISTICS",
    "DROP TABLE",
    "DROP TEMPORARY TABLE",
    "ELSE",
    "EMPTY",
    "EMPTY AS",
    "ENABLED",
    "ENABLED ROLES",
    "END",
    "ENFORCED",
    "ENGINE",
    "EPHEMERAL",
    "ESTIMATE",
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXCEPT",
    "EXCEPT DATABASE",
    "EXCEPT DATABASES",
    "EXCEPT TABLE",
    "EXCEPT TABLES",
    "EXCHANGE",
    "EXCHANGE DICTIONARIES",
    "EXCHANGE TABLES",
    "EXECUTE",
    "EXISTS",
    "EXPLAIN",
    "EXPRESSION",
    "EXTENDED",
    "EXTERNAL",
    "EXTERNAL DDL FROM",
    "FALSE",
    "FETCH",
    "FETCH PART",
    "FETCH PARTITION",
    "FIELDS",
    "FILE",
    "Files",
    "FILESYSTEM",
    "FILESYSTEM CACHE",
    "FILESYSTEM CACHES",
    "FILTER",
    "FINAL",
    "FIRST",
    "FOLLOWING",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FOREIGN KEY",
    "FORGET",
    "FORGET PARTITION",
    "FORMAT",
    "FREEZE",
    "FROM",
    "FROM INFILE",
    "FROM SHARD",
    "FULL",
    "FULLTEXT",
    "FUNCTION",
    "GLOBAL",
    "GLOBAL IN",
    "GLOBAL NOT IN",
    "GRANT",
    "GRANT OPTION FOR",
    "GRANTEES",
    "GRANULARITY",
    "GROUP",
    "GROUP BY",
    "GROUPING",
    "GROUPING SETS",
    "GROUPS",
    "H",
    "HASH",
    "HAVING",
    "HDFS",
    "HH",
    "HIERARCHICAL",
    "HOST",
    "HOUR",
    "HOURS",
    "HTTP",
    "ID",
    "IDENTIFIED",
    "IF",
    "IF EMPTY",
    "IF EXISTS",
    "IF NOT EXISTS",
    "IGNORE",
    "IGNORE NULLS",
    "ILIKE",
    "IN",
    "IN PARTITION",
    "INDEX",
    "INDEXES",
    "INDICES",
    "INHERIT",
    "INJECTIVE",
    "INNER",
    "INSERT",
    "INSERT INTO",
    "INTERPOLATE",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "INTO OUTFILE",
    "INVISIBLE",
    "INVOKER",
    "IP",
    "IS",
    "IS NOT DISTINCT FROM",
    "IS NOT NULL",
    "IS NULL",
    "IS_OBJECT_ID",
    "JOIN",
    "JWT",
    "KERBEROS",
    "KEY",
    "KEY BY",
    "KEYED",
    "KEYED BY",
    "KEYS",
    "KILL",
    "KIND",
    "LARGE",
    "LARGE OBJECT",
    "LAST",
    "LAYOUT",
    "LDAP",
    "LEADING",
    "LEFT",
    "LEFT ARRAY JOIN",
    "LESS",
    "LESS THAN",
    "LEVEL",
    "LIFETIME",
    "LIGHTWEIGHT",
    "LIKE",
    "LIMIT",
    "LINEAR",
    "LIST",
    "LIVE",
    "LOCAL",
    "M",
    "MASTER",
    "MASTER THREAD",
    "MATCH",
    "MATERIALIZE",
    "MATERIALIZE COLUMN",
    "MATERIALIZE INDEX",
    "MATERIALIZE PROJECTION",
    "MATERIALIZE STATISTICS",
    "MATERIALIZE TTL",
    "MATERIALIZED",
    "MAX",
    "MCS",
    "MEMORY",
    "MERGES",
    "METRICS",
    "METRICS INNER UUID",
    "MI",
    "MICROSECOND",
    "MICROSECONDS",
    "MILLISECOND",
    "MILLISECONDS",
    "MIN",
    "MINUTE",
    "MINUTES",
    "MM",
    "MOD",
    "MODIFY",
    "MODIFY COLUMN",
    "MODIFY COMMENT",
    "MODIFY DATABASE COMMENT",
    "MODIFY DEFINER",
    "MODIFY ORDER BY",
    "MODIFY QUERY",
    "MODIFY REFRESH",
    "MODIFY SAMPLE BY",
    "MODIFY SETTING",
    "MODIFY SQL SECURITY",
    "MODIFY STATISTICS",
    "MODIFY TTL",
    "MONTH",
    "MONTHS",
    "MOVE",
    "MOVE PART",
    "MOVE PARTITION",
    "MS",
    "MUTATION",
    "N",
    "NAME",
    "NAMED",
    "NAMED COLLECTION",
    "NANOSECOND",
    "NANOSECONDS",
    "NEXT",
    "NO",
    "NO ACTION",
    "NO DELAY",
    "NO LIMITS",
    "NO_AUTHENTICATION",
    "NO_PASSWORD",
    "NONE",
    "NOT",
    "NOT BETWEEN",
    "NOT IDENTIFIED",
    "NOT ILIKE",
    "NOT IN",
    "NOT KEYED",
    "NOT LIKE",
    "NOT OVERRIDABLE",
    "NS",
    "NULL",
    "NULLS",
    "OFFSET",
    "ON",
    "ON DELETE",
    "ON UPDATE",
    "ON VOLUME",
    "ONLY",
    "OPTIMIZE",
    "OPTIMIZE TABLE",
    "OR",
    "OR REPLACE",
    "ORDER",
    "ORDER BY",
    "OUTER",
    "OVER",
    "OVERRIDABLE",
    "PARALLEL",
    "PARALLEL WITH",
    "PART",
    "PART_MOVE_TO_SHARD",
    "PARTIAL",
    "PARTITION",
    "PARTITION BY",
    "PARTITIONS",
    "PASTE",
    "PERIODIC",
    "PERIODIC REFRESH",
    "PERMANENTLY",
    "PERMISSIVE",
    "PERSISTENT",
    "PIPELINE",
    "PLAINTEXT_PASSWORD",
    "PLAN",
    "POPULATE",
    "PRECEDING",
    "PRECISION",
    "PREFIX",
    "PREPARE",
    "PREWHERE",
    "PRIMARY",
    "PRIMARY KEY",
    "PROFILE",
    "PROFILES",
    "PROJECTION",
    "Protobuf",
    "PULL",
    "Q",
    "QQ",
    "QUALIFY",
    "QUARTER",
    "QUARTERS",
    "QUERY",
    "QUERY TREE",
    "QUOTA",
    "RANDOMIZE",
    "RANDOMIZE FOR",
    "RANDOMIZED",
    "RANGE",
    "READ",
    "READONLY",
    "REALM",
    "RECOMPRESS",
    "RECURSIVE",
    "REFERENCES",
    "REFRESH",
    "REGEXP",
    "REMOVE",
    "REMOVE SAMPLE BY",
    "REMOVE TTL",
    "RENAME",
    "RENAME COLUMN",
    "RENAME DATABASE",
    "RENAME DICTIONARY",
    "RENAME TABLE",
    "RENAME TO",
    "REPLACE",
    "REPLACE PARTITION",
    "REPLICATED",
    "RESET",
    "RESET AUTHENTICATION METHODS TO NEW",
    "RESET SETTING",
    "RESOURCE",
    "RESPECT",
    "RESPECT NULLS",
    "RESTORE",
    "RESTRICT",
    "RESTRICTIVE",
    "RESUME",
    "REVOKE",
    "RIGHT",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "S",
    "S3",
    "SALT",
    "SAMPLE",
    "SAMPLE BY",
    "SAN",
    "SCHEME",
    "SCRAM_SHA256_HASH",
    "SCRAM_SHA256_PASSWORD",
    "SECOND",
    "SECONDS",
    "SELECT",
    "SEMI",
    "SEQUENTIAL",
    "SERVER",
    "SET",
    "SET DEFAULT",
    "SET DEFAULT ROLE",
    "SET FAKE TIME",
    "SET NULL",
    "SET ROLE",
    "SET ROLE DEFAULT",
    "SET TRANSACTION SNAPSHOT",
    "SETTING",
    "SETTINGS",
    "SHA256_HASH",
    "SHA256_PASSWORD",
    "SHOW",
    "SHOW ACCESS",
    "SHOW CREATE",
    "SHOW ENGINES",
    "SHOW FUNCTIONS",
    "SHOW GRANTS",
    "SHOW PRIVILEGES",
    "SHOW PROCESSLIST",
    "SHOW SETTING",
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SOURCE",
    "SPATIAL",
    "SQL",
    "SQL SECURITY",
    "SQL_TSI_DAY",
    "SQL_TSI_HOUR",
    "SQL_TSI_MICROSECOND",
    "SQL_TSI_MILLISECOND",
    "SQL_TSI_MINUTE",
    "SQL_TSI_MONTH",
    "SQL_TSI_NANOSECOND",
    "SQL_TSI_QUARTER",
    "SQL_TSI_SECOND",
    "SQL_TSI_WEEK",
    "SQL_TSI_YEAR",
    "SS",
    "SSH_KEY",
    "SSL_CERTIFICATE",
    "STALENESS",
    "START",
    "START TRANSACTION",
    "STATISTICS",
    "STEP",
    "STORAGE",
    "STRICT",
    "STRICTLY_ASCENDING",
    "SUBPARTITION",
    "SUBPARTITION BY",
    "SUBPARTITIONS",
    "SUSPEND",
    "SYNC",
    "SYNTAX",
    "SYSTEM",
    "TABLE",
    "TABLE OVERRIDE",
    "TABLES",
    "TAG",
    "TAGS",
    "TAGS INNER UUID",
    "TEMPORARY",
    "TEMPORARY TABLE",
    "TEST",
    "THEN",
    "TIMESTAMP",
    "TO",
    "TO DISK",
    "TO INNER UUID",
    "TO SHARD",
    "TO TABLE",
    "TO VOLUME",
    "TOP",
    "TOTALS",
    "TRACKING",
    "TRACKING ONLY",
    "TRAILING",
    "TRANSACTION",
    "TRIGGER",
    "TRUE",
    "TRUNCATE",
    "TTL",
    "TYPE",
    "TYPEOF",
    "UNBOUNDED",
    "UNDROP",
    "UNFREEZE",
    "UNION",
    "UNIQUE",
    "UNLOCK",
    "UNLOCK SNAPSHOT",
    "UNSET",
    "UNSET FAKE TIME",
    "UNSIGNED",
    "UPDATE",
    "URL",
    "USE",
    "USING",
    "UUID",
    "VALID",
    "VALID UNTIL",
    "VALUES",
    "VARYING",
    "VIEW",
    "VISIBLE",
    "WATCH",
    "WATERMARK",
    "WEEK",
    "WEEKS",
    "WHEN",
    "WHERE",
    "WINDOW",
    "WITH",
    "WITH ADMIN OPTION",
    "WITH CHECK",
    "WITH FILL",
    "WITH GRANT OPTION",
    "WITH IMPLICIT",
    "WITH NAME",
    "WITH REPLACE OPTION",
    "WITH TIES",
    "WITH_ITEMINDEX",
    "WK",
    "WORKER",
    "WORKER THREAD",
    "WORKLOAD",
    "WRITABLE",
    "WRITE",
    "WW",
    "YEAR",
    "YEARS",
    "YY",
    "YYYY",
    "ZKPATH"
  ],
  "dataTypes": [
    {
      "name": "AggregateFunction",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Array",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "BFloat16",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "BIGINT",
      "caseInsensitive": true,
      "aliasTo": "Int64"
    },
    {
      "name": "BIGINT SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int64"
    },
    {
      "name": "BIGINT UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt64"
    },
    {
      "name": "BINARY",
      "caseInsensitive": true,
      "aliasTo": "FixedString"
    },
    {
      "name": "BINARY LARGE OBJECT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "BINARY VARYING",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "BIT",
      "caseInsensitive": true,
      "aliasTo": "UInt64"
    },
    {
      "name": "BLOB",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "BYTE",
      "caseInsensitive": true,
      "aliasTo": "Int8"
    },
    {
      "name": "BYTEA",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "Bool",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "CHAR",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "CHAR LARGE OBJECT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "CHAR VARYING",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "CHARACTER",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "CHARACTER LARGE OBJECT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "CHARACTER VARYING",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "CLOB",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "DEC",
      "caseInsensitive": true,
      "aliasTo": "Decimal"
    },
    {
      "name": "DOUBLE",
      "caseInsensitive": true,
      "aliasTo": "Float64"
    },
    {
      "name": "DOUBLE PRECISION",
      "caseInsensitive": true,
      "aliasTo": "Float64"
    },
    {
      "name": "Date",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Date32",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "DateTime",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "DateTime32",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "DateTime64",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Decimal",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Decimal128",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Decimal256",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Decimal32",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Decimal64",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Dynamic",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "ENUM",
      "caseInsensitive": true,
      "aliasTo": "Enum"
    },
    {
      "name": "Enum",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Enum16",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Enum8",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "FIXED",
      "caseInsensitive": true,
      "aliasTo": "Decimal"
    },
    {
      "name": "FLOAT",
      "caseInsensitive": true,
      "aliasTo": "Float32"
    },
    {
      "name": "FixedString",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Float32",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Float64",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "GEOMETRY",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "INET4",
      "caseInsensitive": true,
      "aliasTo": "IPv4"
    },
    {
      "name": "INET6",
      "caseInsensitive": true,
      "aliasTo": "IPv6"
    },
    {
      "name": "INT",
      "caseInsensitive": true,
      "aliasTo": "Int32"
    },
    {
      "name": "INT SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int32"
    },
    {
      "name": "INT UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt32"
    },
    {
      "name": "INT1",
      "caseInsensitive": true,
      "aliasTo": "Int8"
    },
    {
      "name": "INT1 SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int8"
    },
    {
      "name": "INT1 UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt8"
    },
    {
      "name": "INTEGER",
      "caseInsensitive": true,
      "aliasTo": "Int32"
    },
    {
      "name": "INTEGER SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int32"
    },
    {
      "name": "INTEGER UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt32"
    },
    {
      "name": "IPv4",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IPv6",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Int128",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Int16",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Int256",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Int32",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Int64",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Int8",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalDay",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalHour",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalMicrosecond",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalMillisecond",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalMinute",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalMonth",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalNanosecond",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalQuarter",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalSecond",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalWeek",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "IntervalYear",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "JSON",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "LONGBLOB",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "LONGTEXT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "LineString",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "LowCardinality",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "MEDIUMBLOB",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "MEDIUMINT",
      "caseInsensitive": true,
      "aliasTo": "Int32"
    },
    {
      "name": "MEDIUMINT SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int32"
    },
    {
      "name": "MEDIUMINT UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt32"
    },
    {
      "name": "MEDIUMTEXT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "Map",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "MultiLineString",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "MultiPolygon",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "NATIONAL CHAR",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NATIONAL CHAR VARYING",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NATIONAL CHARACTER",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NATIONAL CHARACTER LARGE OBJECT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NATIONAL CHARACTER VARYING",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NCHAR",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NCHAR LARGE OBJECT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NCHAR VARYING",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "NUMERIC",
      "caseInsensitive": true,
      "aliasTo": "Decimal"
    },
    {
      "name": "NVARCHAR",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "Nested",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Nothing",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Nullable",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Object",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Point",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "Polygon",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "REAL",
      "caseInsensitive": true,
      "aliasTo": "Float32"
    },
    {
      "name": "Ring",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "SET",
      "caseInsensitive": true,
      "aliasTo": "UInt64"
    },
    {
      "name": "SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int64"
    },
    {
      "name": "SINGLE",
      "caseInsensitive": true,
      "aliasTo": "Float32"
    },
    {
      "name": "SMALLINT",
      "caseInsensitive": true,
      "aliasTo": "Int16"
    },
    {
      "name": "SMALLINT SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int16"
    },
    {
      "name": "SMALLINT UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt16"
    },
    {
      "name": "SimpleAggregateFunction",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "String",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "TEXT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "TIMESTAMP",
      "caseInsensitive": true,
      "aliasTo": "DateTime"
    },
    {
      "name": "TINYBLOB",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "TINYINT",
      "caseInsensitive": true,
      "aliasTo": "Int8"
    },
    {
      "name": "TINYINT SIGNED",
      "caseInsensitive": true,
      "aliasTo": "Int8"
    },
    {
      "name": "TINYINT UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt8"
    },
    {
      "name": "TINYTEXT",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "Time",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Time64",
      "caseInsensitive": true,
      "aliasTo": null
    },
    {
      "name": "Tuple",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UInt128",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UInt16",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UInt256",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UInt32",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UInt64",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UInt8",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "UNSIGNED",
      "caseInsensitive": true,
      "aliasTo": "UInt64"
    },
    {
      "name": "UUID",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "VARBINARY",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "VARCHAR",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "VARCHAR2",
      "caseInsensitive": true,
      "aliasTo": "String"
    },
    {
      "name": "Variant",
      "caseInsensitive": false,
      "aliasTo": null
    },
    {
      "name": "YEAR",
      "caseInsensitive": true,
      "aliasTo": "UInt16"
    },
    {
      "name": "bool",
      "caseInsensitive": true,
      "aliasTo": "Bool"
    },
    {
      "name": "boolean",
      "caseInsensitive": true,
      "aliasTo": "Bool"
    }
  ],
  "tableEngines": [
    {
      "name": "AggregatingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "AzureBlobStorage",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "AzureQueue",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Buffer",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "COSN",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "CoalescingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "CollapsingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "DeltaLake",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "DeltaLakeAzure",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "DeltaLakeLocal",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "DeltaLakeS3",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Dictionary",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Distributed",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "EmbeddedRocksDB",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "Executable",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "ExecutablePool",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "File",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "FileLog",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "FuzzJSON",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "FuzzQuery",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "GenerateRandom",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "GraphiteMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "HDFS",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Hive",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Hudi",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Iceberg",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "IcebergAzure",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "IcebergHDFS",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "IcebergLocal",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "IcebergS3",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "JDBC",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Join",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Kafka",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "KeeperMap",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "LiveView",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Log",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Loop",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "MaterializedPostgreSQL",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "MaterializedView",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Memory",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "Merge",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "MergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "MongoDB",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "MySQL",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "NATS",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Null",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "ODBC",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "OSS",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "PostgreSQL",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "RabbitMQ",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Redis",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplacingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedAggregatingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedCoalescingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedCollapsingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedGraphiteMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedReplacingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedSummingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "ReplicatedVersionedCollapsingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": true,
      "supportsDeduplication": true,
      "supportsParallelInsert": true
    },
    {
      "name": "S3",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": true,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "S3Queue",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "SQLite",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "Set",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "StripeLog",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "SummingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "TimeSeries",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "TinyLog",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "URL",
      "supportsSettings": true,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "VersionedCollapsingMergeTree",
      "supportsSettings": true,
      "supportsSkippingIndices": true,
      "supportsProjections": true,
      "supportsSortOrder": true,
      "supportsTTL": true,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": true
    },
    {
      "name": "View",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    },
    {
      "name": "WindowView",
      "supportsSettings": false,
      "supportsSkippingIndices": false,
      "supportsProjections": false,
      "supportsSortOrder": false,
      "supportsTTL": false,
      "supportsReplication": false,
      "supportsDeduplication": false,
      "supportsParallelInsert": false
    }
  ],
  "formats": [
    {
      "name": "Arrow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "ArrowStream",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Avro",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "AvroConfluent",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "BSONEachRow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CSV",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CSVWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CSVWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CapnProto",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CustomSeparated",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CustomSeparatedIgnoreSpaces",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "CustomSeparatedIgnoreSpacesWithNames",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "CustomSeparatedIgnoreSpacesWithNamesAndTypes",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "CustomSeparatedWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "CustomSeparatedWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "DWARF",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "Form",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "HiveText",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "JSON",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONAsObject",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "JSONAsString",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "JSONColumns",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONColumnsWithMetadata",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompact",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactColumns",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactEachRow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactEachRowWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactEachRowWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactEachRowWithProgress",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "JSONCompactStrings",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "JSONCompactStringsEachRow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactStringsEachRowWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactStringsEachRowWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONCompactStringsEachRowWithProgress",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "JSONEachRow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONEachRowWithProgress",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "JSONLines",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONObjectEachRow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONStrings",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "JSONStringsEachRow",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "JSONStringsEachRowWithProgress",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "LineAsString",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "LineAsStringWithNames",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "LineAsStringWithNamesAndTypes",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "Markdown",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "MsgPack",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "MySQLDump",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "MySQLWire",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "NDJSON",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Native",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Npy",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Null",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "ODBCDriver2",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "ORC",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "One",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "Parquet",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "ParquetMetadata",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "PostgreSQLWire",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "Pretty",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyCompact",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyCompactMonoBlock",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyCompactNoEscapes",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyCompactNoEscapesMonoBlock",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyJSONEachRow",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyJSONLines",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyMonoBlock",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyNDJSON",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyNoEscapes",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettyNoEscapesMonoBlock",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettySpace",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettySpaceMonoBlock",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettySpaceNoEscapes",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "PrettySpaceNoEscapesMonoBlock",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "Prometheus",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "Protobuf",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "ProtobufList",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "ProtobufSingle",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Raw",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "RawBLOB",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "RawWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "RawWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Regexp",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "RowBinary",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "RowBinaryWithDefaults",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "RowBinaryWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "RowBinaryWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "SQLInsert",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "TSKV",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TSV",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TSVRaw",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TSVRawWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TSVRawWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TSVWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TSVWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TabSeparated",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TabSeparatedRaw",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TabSeparatedRawWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TabSeparatedRawWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TabSeparatedWithNames",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TabSeparatedWithNamesAndTypes",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Template",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "TemplateIgnoreSpaces",
      "isInput": true,
      "isOutput": false
    },
    {
      "name": "Values",
      "isInput": true,
      "isOutput": true
    },
    {
      "name": "Vertical",
      "isInput": false,
      "isOutput": true
    },
    {
      "name": "XML",
      "isInput": false,
      "isOutput": true
    }
  ],
  "tableFunctions": [
    {
      "name": "azureBlobStorage",
      "description": "The table function can be used to read the data stored on Azure Blob Storage."
    },
    {
      "name": "azureBlobStorageCluster",
      "description": "The table function can be used to read the data stored on Azure Blob Storage in parallel for many nodes in a specified cluster."
    },
    {
      "name": "cluster",
      "description": ""
    },
    {
      "name": "clusterAllReplicas",
      "description": ""
    },
    {
      "name": "cosn",
      "description": "The table function can be used to read the data stored on COSN."
    },
    {
      "name": "deltaLake",
      "description": "The table function can be used to read the DeltaLake table stored on S3, alias of deltaLakeS3."
    },
    {
      "name": "deltaLakeAzure",
      "description": "The table function can be used to read the DeltaLake table stored on Azure object store."
    },
    {
      "name": "deltaLakeCluster",
      "description": "The table function can be used to read the DeltaLake table stored on object store in parallel for many nodes in a specified cluster."
    },
    {
      "name": "deltaLakeLocal",
      "description": "The table function can be used to read the DeltaLake table stored locally."
    },
    {
      "name": "deltaLakeS3",
      "description": "The table function can be used to read the DeltaLake table stored on S3."
    },
    {
      "name": "dictionary",
      "description": ""
    },
    {
      "name": "executable",
      "description": ""
    },
    {
      "name": "file",
      "description": ""
    },
    {
      "name": "fileCluster",
      "description": "This table function is used for distributed reading of files in cluster nodes filesystems."
    },
    {
      "name": "format",
      "description": "\nExtracts table structure from data and parses it according to specified input format.\nSyntax: `format(format_name, data)`.\nParameters:\n    - `format_name` - the format of the data.\n    - `data ` - String literal or constant expression that returns a string containing data in specified format.\nReturned value: A table with data parsed from `data` argument according specified format and extracted schema.\n"
    },
    {
      "name": "fuzzJSON",
      "description": "Perturbs a JSON string with random variations."
    },
    {
      "name": "fuzzQuery",
      "description": "Perturbs a query string with random variations."
    },
    {
      "name": "gcs",
      "description": "The table function can be used to read the data stored on GCS."
    },
    {
      "name": "generateRandom",
      "description": ""
    },
    {
      "name": "generateSeries",
      "description": ""
    },
    {
      "name": "generate_series",
      "description": ""
    },
    {
      "name": "hdfs",
      "description": "The table function can be used to read the data stored on HDFS virtual filesystem."
    },
    {
      "name": "hdfsCluster",
      "description": "The table function can be used to read the data stored on HDFS in parallel for many nodes in a specified cluster."
    },
    {
      "name": "hive",
      "description": ""
    },
    {
      "name": "hudi",
      "description": "The table function can be used to read the Hudi table stored on object store."
    },
    {
      "name": "hudiCluster",
      "description": "The table function can be used to read the Hudi table stored on object store in parallel for many nodes in a specified cluster."
    },
    {
      "name": "iceberg",
      "description": "The table function can be used to read the Iceberg table stored on S3 object store. Alias to icebergS3"
    },
    {
      "name": "icebergAzure",
      "description": "The table function can be used to read the Iceberg table stored on Azure object store."
    },
    {
      "name": "icebergAzureCluster",
      "description": "The table function can be used to read the Iceberg table stored on Azure object store in parallel for many nodes in a specified cluster."
    },
    {
      "name": "icebergHDFS",
      "description": "The table function can be used to read the Iceberg table stored on HDFS virtual filesystem."
    },
    {
      "name": "icebergHDFSCluster",
      "description": "The table function can be used to read the Iceberg table stored on HDFS virtual filesystem in parallel for many nodes in a specified cluster."
    },
    {
      "name": "icebergLocal",
      "description": "The table function can be used to read the Iceberg table stored locally."
    },
    {
      "name": "icebergS3",
      "description": "The table function can be used to read the Iceberg table stored on S3 object store."
    },
    {
      "name": "icebergS3Cluster",
      "description": "The table function can be used to read the Iceberg table stored on S3 object store in parallel for many nodes in a specified cluster."
    },
    {
      "name": "input",
      "description": ""
    },
    {
      "name": "jdbc",
      "description": ""
    },
    {
      "name": "loop",
      "description": "The table function can be used to continuously output query results in an infinite loop."
    },
    {
      "name": "merge",
      "description": "Creates a temporary Merge table. The structure will be derived from underlying tables by using a union of their columns and by deriving common types."
    },
    {
      "name": "mergeTreeIndex",
      "description": "Represents the contents of index and marks files of MergeTree tables. It can be used for introspection"
    },
    {
      "name": "mergeTreeProjection",
      "description": "Reading directly from MergeTree projection"
    },
    {
      "name": "mongodb",
      "description": "Allows get data from MongoDB collection."
    },
    {
      "name": "mysql",
      "description": ""
    },
    {
      "name": "null",
      "description": ""
    },
    {
      "name": "numbers",
      "description": ""
    },
    {
      "name": "numbers_mt",
      "description": ""
    },
    {
      "name": "odbc",
      "description": ""
    },
    {
      "name": "oss",
      "description": "The table function can be used to read the data stored on OSS."
    },
    {
      "name": "postgresql",
      "description": ""
    },
    {
      "name": "redis",
      "description": ""
    },
    {
      "name": "remote",
      "description": ""
    },
    {
      "name": "remoteSecure",
      "description": ""
    },
    {
      "name": "s3",
      "description": "The table function can be used to read the data stored on AWS S3."
    },
    {
      "name": "s3Cluster",
      "description": "The table function can be used to read the data stored on S3 in parallel for many nodes in a specified cluster."
    },
    {
      "name": "sqlite",
      "description": ""
    },
    {
      "name": "timeSeriesData",
      "description": "Provides direct access to the 'data' target table for a specified TimeSeries table."
    },
    {
      "name": "timeSeriesMetrics",
      "description": "Provides direct access to the 'metrics' target table for a specified TimeSeries table."
    },
    {
      "name": "timeSeriesTags",
      "description": "Provides direct access to the 'tags' target table for a specified TimeSeries table."
    },
    {
      "name": "url",
      "description": ""
    },
    {
      "name": "urlCluster",
      "description": ""
    },
    {
      "name": "values",
      "description": ""
    },
    {
      "name": "view",
      "description": ""
    },
    {
      "name": "viewExplain",
      "description": "\n                Returns result of EXPLAIN query.\n                The function should not be called directly but can be invoked via `SELECT * FROM (EXPLAIN <query>)`.\n                You can use this query to process the result of EXPLAIN further using SQL (e.g., in tests).\n                Example:\n                [example:1]\n                "
    },
    {
      "name": "viewIfPermitted",
      "description": ""
    },
    {
      "name": "zeros",
      "description": "\n                Generates a stream of zeros (a table with one column 'zero' of type 'UInt8') of specified size.\n                This table function is used in performance tests, where you want to spend as little time as possible to data generation while testing some other parts of queries.\n                In contrast to the `zeros_mt`, this table function is using single thread for data generation.\n                Example:\n                [example:1]\n                This query will test the speed of `randomPrintableASCII` function using single thread.\n                See also the `system.zeros_mt` table."
    },
    {
      "name": "zeros_mt",
      "description": "\n                Generates a stream of zeros (a table with one column 'zero' of type 'UInt8') of specified size.\n                This table function is used in performance tests, where you want to spend as little time as possible to data generation while testing some other parts of queries.\n                In contrast to the `zeros`, this table function is using multiple threads for data generation, according to the `max_threads` setting.\n                Example:\n                [example:1]\n                This query will test the speed of `randomPrintableASCII` function using multiple threads.\n                See also the `system.zeros` table."
    }
  ],
  "aggregateCombinators": [
    "ArgMax",
    "ArgMin",
    "Array",
    "Distinct",
    "ForEach",
    "If",
    "Map",
    "Merge",
    "OrDefault",
    "OrNull",
    "Resample",
    "SimpleState",
    "State"
  ],
  "settings": [
    {
      "name": "add_http_cors_header",
      "type": "Bool",
      "description": "Write add http CORS header."
    },
    {
      "name": "additional_result_filter",
      "type": "String",
      "description": "An additional filter expression to apply to the result of `SELECT` query.\nThis setting is not applied to any subquery.\n\n**Example**\n\n```sql\nINSERT INTO table_1 VALUES (1, 'a'), (2, 'bb'), (3, 'ccc'), (4, 'dddd');\nSElECT * FROM table_1;\n```\n```response\n┌─x─┬─y────┐\n│ 1 │ a    │\n│ 2 │ bb   │\n│ 3 │ ccc  │\n│ 4 │ dddd │\n└───┴──────┘\n```\n```sql\nSELECT *\nFROM table_1\nSETTINGS additional_result_filter = 'x != 2'\n```\n```response\n┌─x─┬─y────┐\n│ 1 │ a    │\n│ 3 │ ccc  │\n│ 4 │ dddd │\n└───┴──────┘\n```"
    },
    {
      "name": "additional_table_filters",
      "type": "Map",
      "description": "An additional filter expression that is applied after reading\nfrom the specified table.\n\n**Example**\n\n```sql\nINSERT INTO table_1 VALUES (1, 'a'), (2, 'bb'), (3, 'ccc'), (4, 'dddd');\nSELECT * FROM table_1;\n```\n```response\n┌─x─┬─y────┐\n│ 1 │ a    │\n│ 2 │ bb   │\n│ 3 │ ccc  │\n│ 4 │ dddd │\n└───┴──────┘\n```\n```sql\nSELECT *\nFROM table_1\nSETTINGS additional_table_filters = {'table_1': 'x != 2'}\n```\n```response\n┌─x─┬─y────┐\n│ 1 │ a    │\n│ 3 │ ccc  │\n│ 4 │ dddd │\n└───┴──────┘\n```"
    },
    {
      "name": "aggregate_functions_null_for_empty",
      "type": "Bool",
      "description": "Enables or disables rewriting all aggregate functions in a query, adding [-OrNull](/sql-reference/aggregate-functions/combinators#-ornull) suffix to them. Enable it for SQL standard compatibility.\nIt is implemented via query rewrite (similar to [count_distinct_implementation](#count_distinct_implementation) setting) to get consistent results for distributed queries.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\n**Example**\n\nConsider the following query with aggregate functions:\n```sql\nSELECT SUM(-1), MAX(0) FROM system.one WHERE 0;\n```\n\nWith `aggregate_functions_null_for_empty = 0` it would produce:\n```text\n┌─SUM(-1)─┬─MAX(0)─┐\n│       0 │      0 │\n└─────────┴────────┘\n```\n\nWith `aggregate_functions_null_for_empty = 1` the result would be:\n```text\n┌─SUMOrNull(-1)─┬─MAXOrNull(0)─┐\n│          NULL │         NULL │\n└───────────────┴──────────────┘\n```"
    },
    {
      "name": "aggregation_in_order_max_block_bytes",
      "type": "UInt64",
      "description": "Maximal size of block in bytes accumulated during aggregation in order of primary key. Lower block size allows to parallelize more final merge stage of aggregation."
    },
    {
      "name": "aggregation_memory_efficient_merge_threads",
      "type": "UInt64",
      "description": "Number of threads to use for merge intermediate aggregation results in memory efficient mode. When bigger, then more memory is consumed. 0 means - same as 'max_threads'."
    },
    {
      "name": "allow_aggregate_partitions_independently",
      "type": "Bool",
      "description": "Enable independent aggregation of partitions on separate threads when partition key suits group by key. Beneficial when number of partitions close to number of cores and partitions have roughly the same size"
    },
    {
      "name": "allow_archive_path_syntax",
      "type": "Bool",
      "description": "File/S3 engines/table function will parse paths with '::' as `<archive> :: <file>` if the archive has correct extension."
    },
    {
      "name": "allow_asynchronous_read_from_io_pool_for_merge_tree",
      "type": "Bool",
      "description": "Use background I/O pool to read from MergeTree tables. This setting may increase performance for I/O bound queries"
    },
    {
      "name": "allow_changing_replica_until_first_data_packet",
      "type": "Bool",
      "description": "If it's enabled, in hedged requests we can start new connection until receiving first data packet even if we have already made some progress\n(but progress haven't updated for `receive_data_timeout` timeout), otherwise we disable changing replica after the first time we made progress."
    },
    {
      "name": "allow_create_index_without_type",
      "type": "Bool",
      "description": "Allow CREATE INDEX query without TYPE. Query will be ignored. Made for SQL compatibility tests."
    },
    {
      "name": "allow_custom_error_code_in_throwif",
      "type": "Bool",
      "description": "Enable custom error code in function throwIf(). If true, thrown exceptions may have unexpected error codes."
    },
    {
      "name": "allow_ddl",
      "type": "Bool",
      "description": "If it is set to true, then a user is allowed to executed DDL queries."
    },
    {
      "name": "allow_deprecated_database_ordinary",
      "type": "Bool",
      "description": "Allow to create databases with deprecated Ordinary engine"
    },
    {
      "name": "allow_deprecated_error_prone_window_functions",
      "type": "Bool",
      "description": "Allow usage of deprecated error prone window functions (neighbor, runningAccumulate, runningDifferenceStartingWithFirstValue, runningDifference)"
    },
    {
      "name": "allow_deprecated_snowflake_conversion_functions",
      "type": "Bool",
      "description": "Functions `snowflakeToDateTime`, `snowflakeToDateTime64`, `dateTimeToSnowflake`, and `dateTime64ToSnowflake` are deprecated and disabled by default.\nPlease use functions `snowflakeIDToDateTime`, `snowflakeIDToDateTime64`, `dateTimeToSnowflakeID`, and `dateTime64ToSnowflakeID` instead.\n\nTo re-enable the deprecated functions (e.g., during a transition period), please set this setting to `true`."
    },
    {
      "name": "allow_deprecated_syntax_for_merge_tree",
      "type": "Bool",
      "description": "Allow to create *MergeTree tables with deprecated engine definition syntax"
    },
    {
      "name": "allow_distributed_ddl",
      "type": "Bool",
      "description": "If it is set to true, then a user is allowed to executed distributed DDL queries."
    },
    {
      "name": "allow_drop_detached",
      "type": "Bool",
      "description": "Allow ALTER TABLE ... DROP DETACHED PART[ITION] ... queries"
    },
    {
      "name": "allow_execute_multiif_columnar",
      "type": "Bool",
      "description": "Allow execute multiIf function columnar"
    },
    {
      "name": "allow_experimental_alter_materialized_view_structure",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_analyzer",
      "type": "Bool",
      "description": "Allow new query analyzer."
    },
    {
      "name": "allow_experimental_annoy_index",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_bfloat16_type",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_bigint_types",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_codecs",
      "type": "Bool",
      "description": "If it is set to true, allow to specify experimental compression codecs (but we don't have those yet and this option does nothing)."
    },
    {
      "name": "allow_experimental_correlated_subqueries",
      "type": "Bool",
      "description": "Allow to execute correlated subqueries."
    },
    {
      "name": "allow_experimental_database_atomic",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_database_glue_catalog",
      "type": "Bool",
      "description": "Allow experimental database engine DataLakeCatalog with catalog_type = 'glue'"
    },
    {
      "name": "allow_experimental_database_hms_catalog",
      "type": "Bool",
      "description": "Allow experimental database engine DataLakeCatalog with catalog_type = 'hms'"
    },
    {
      "name": "allow_experimental_database_iceberg",
      "type": "Bool",
      "description": "Allow experimental database engine DataLakeCatalog with catalog_type = 'iceberg'"
    },
    {
      "name": "allow_experimental_database_materialized_mysql",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_database_materialized_postgresql",
      "type": "Bool",
      "description": "Allow to create database with Engine=MaterializedPostgreSQL(...)."
    },
    {
      "name": "allow_experimental_database_replicated",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_database_unity_catalog",
      "type": "Bool",
      "description": "Allow experimental database engine DataLakeCatalog with catalog_type = 'unity'"
    },
    {
      "name": "allow_experimental_delta_kernel_rs",
      "type": "Bool",
      "description": "Allow experimental delta-kernel-rs implementation."
    },
    {
      "name": "allow_experimental_dynamic_type",
      "type": "Bool",
      "description": "Allows creation of [Dynamic](../../sql-reference/data-types/dynamic.md) data type."
    },
    {
      "name": "allow_experimental_full_text_index",
      "type": "Bool",
      "description": "If it is set to true, allow to use experimental full-text index."
    },
    {
      "name": "allow_experimental_funnel_functions",
      "type": "Bool",
      "description": "Enable experimental functions for funnel analysis."
    },
    {
      "name": "allow_experimental_geo_types",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_hash_functions",
      "type": "Bool",
      "description": "Enable experimental hash functions"
    },
    {
      "name": "allow_experimental_inverted_index",
      "type": "Bool",
      "description": "If it is set to true, allow to use experimental inverted index."
    },
    {
      "name": "allow_experimental_join_condition",
      "type": "Bool",
      "description": "Support join with inequal conditions which involve columns from both left and right table. e.g. `t1.y < t2.y`."
    },
    {
      "name": "allow_experimental_join_right_table_sorting",
      "type": "Bool",
      "description": "If it is set to true, and the conditions of `join_to_sort_minimum_perkey_rows` and `join_to_sort_maximum_table_rows` are met, rerange the right table by key to improve the performance in left or inner hash join."
    },
    {
      "name": "allow_experimental_json_type",
      "type": "Bool",
      "description": "Allows creation of [JSON](../../sql-reference/data-types/newjson.md) data type."
    },
    {
      "name": "allow_experimental_kafka_offsets_storage_in_keeper",
      "type": "Bool",
      "description": "Allow experimental feature to store Kafka related offsets in ClickHouse Keeper. When enabled a ClickHouse Keeper path and replica name can be specified to the Kafka table engine. As a result instead of the regular Kafka engine, a new type of storage engine will be used that stores the committed offsets primarily in ClickHouse Keeper"
    },
    {
      "name": "allow_experimental_kusto_dialect",
      "type": "Bool",
      "description": "Enable Kusto Query Language (KQL) - an alternative to SQL."
    },
    {
      "name": "allow_experimental_lightweight_delete",
      "type": "Bool",
      "description": "Enable lightweight DELETE mutations for mergetree tables."
    },
    {
      "name": "allow_experimental_lightweight_update",
      "type": "Bool",
      "description": "Allow to use lightweight updates."
    },
    {
      "name": "allow_experimental_live_view",
      "type": "Bool",
      "description": "Allows creation of a deprecated LIVE VIEW.\n\nPossible values:\n\n- 0 — Working with live views is disabled.\n- 1 — Working with live views is enabled."
    },
    {
      "name": "allow_experimental_map_type",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_materialized_postgresql_table",
      "type": "Bool",
      "description": "Allows to use the MaterializedPostgreSQL table engine. Disabled by default, because this feature is experimental"
    },
    {
      "name": "allow_experimental_nlp_functions",
      "type": "Bool",
      "description": "Enable experimental functions for natural language processing."
    },
    {
      "name": "allow_experimental_object_type",
      "type": "Bool",
      "description": "Allow the obsolete Object data type"
    },
    {
      "name": "allow_experimental_parallel_reading_from_replicas",
      "type": "UInt64",
      "description": "Use up to `max_parallel_replicas` the number of replicas from each shard for SELECT query execution. Reading is parallelized and coordinated dynamically. 0 - disabled, 1 - enabled, silently disable them in case of failure, 2 - enabled, throw an exception in case of failure"
    },
    {
      "name": "allow_experimental_projection_optimization",
      "type": "Bool",
      "description": "Enables or disables [projection](../../engines/table-engines/mergetree-family/mergetree.md/#projections) optimization when processing `SELECT` queries.\n\nPossible values:\n\n- 0 — Projection optimization disabled.\n- 1 — Projection optimization enabled."
    },
    {
      "name": "allow_experimental_prql_dialect",
      "type": "Bool",
      "description": "Enable PRQL - an alternative to SQL."
    },
    {
      "name": "allow_experimental_query_cache",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_query_deduplication",
      "type": "Bool",
      "description": "Experimental data deduplication for SELECT queries based on part UUIDs"
    },
    {
      "name": "allow_experimental_refreshable_materialized_view",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_s3queue",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_shared_merge_tree",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_shared_set_join",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_statistic",
      "type": "Bool",
      "description": "Allows defining columns with [statistics](../../engines/table-engines/mergetree-family/mergetree.md/#table_engine-mergetree-creating-a-table) and [manipulate statistics](../../engines/table-engines/mergetree-family/mergetree.md/#column-statistics)."
    },
    {
      "name": "allow_experimental_statistics",
      "type": "Bool",
      "description": "Allows defining columns with [statistics](../../engines/table-engines/mergetree-family/mergetree.md/#table_engine-mergetree-creating-a-table) and [manipulate statistics](../../engines/table-engines/mergetree-family/mergetree.md/#column-statistics)."
    },
    {
      "name": "allow_experimental_time_series_aggregate_functions",
      "type": "Bool",
      "description": "Experimental timeSeries* aggregate functions for Prometheus-like timeseries resampling, rate, delta calculation."
    },
    {
      "name": "allow_experimental_time_series_table",
      "type": "Bool",
      "description": "Allows creation of tables with the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine. Possible values:\n- 0 — the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine is disabled.\n- 1 — the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine is enabled."
    },
    {
      "name": "allow_experimental_time_time64_type",
      "type": "Bool",
      "description": "Allows creation of [Time](../../sql-reference/data-types/time.md) and [Time64](../../sql-reference/data-types/time64.md) data types."
    },
    {
      "name": "allow_experimental_ts_to_grid_aggregate_function",
      "type": "Bool",
      "description": "Experimental timeSeries* aggregate functions for Prometheus-like timeseries resampling, rate, delta calculation."
    },
    {
      "name": "allow_experimental_undrop_table_query",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_usearch_index",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_variant_type",
      "type": "Bool",
      "description": "Allows creation of [Variant](../../sql-reference/data-types/variant.md) data type."
    },
    {
      "name": "allow_experimental_vector_similarity_index",
      "type": "Bool",
      "description": "Allow experimental vector similarity index"
    },
    {
      "name": "allow_experimental_window_functions",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "allow_experimental_window_view",
      "type": "Bool",
      "description": "Enable WINDOW VIEW. Not mature enough."
    },
    {
      "name": "allow_general_join_planning",
      "type": "Bool",
      "description": "Allows a more general join planning algorithm that can handle more complex conditions, but only works with hash join. If hash join is not enabled, then the usual join planning algorithm is used regardless of the value of this setting."
    },
    {
      "name": "allow_get_client_http_header",
      "type": "Bool",
      "description": "Allow to use the function `getClientHTTPHeader` which lets to obtain a value of an the current HTTP request's header. It is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info. Note that the `X-ClickHouse-*` and `Authentication` headers are always restricted and cannot be obtained with this function."
    },
    {
      "name": "allow_hyperscan",
      "type": "Bool",
      "description": "Allow functions that use Hyperscan library. Disable to avoid potentially long compilation times and excessive resource usage."
    },
    {
      "name": "allow_introspection_functions",
      "type": "Bool",
      "description": "Enables or disables [introspection functions](../../sql-reference/functions/introspection.md) for query profiling.\n\nPossible values:\n\n- 1 — Introspection functions enabled.\n- 0 — Introspection functions disabled.\n\n**See Also**\n\n- [Sampling Query Profiler](../../operations/optimizing-performance/sampling-query-profiler.md)\n- System table [trace_log](/operations/system-tables/trace_log)"
    },
    {
      "name": "allow_materialized_view_with_bad_select",
      "type": "Bool",
      "description": "Allow CREATE MATERIALIZED VIEW with SELECT query that references nonexistent tables or columns. It must still be syntactically valid. Doesn't apply to refreshable MVs. Doesn't apply if the MV schema needs to be inferred from the SELECT query (i.e. if the CREATE has no column list and no TO table). Can be used for creating MV before its source table."
    },
    {
      "name": "allow_named_collection_override_by_default",
      "type": "Bool",
      "description": "Allow named collections' fields override by default."
    },
    {
      "name": "allow_non_metadata_alters",
      "type": "Bool",
      "description": "Allow to execute alters which affects not only tables metadata, but also data on disk"
    },
    {
      "name": "allow_nonconst_timezone_arguments",
      "type": "Bool",
      "description": "Allow non-const timezone arguments in certain time-related functions like toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*()"
    },
    {
      "name": "allow_nondeterministic_mutations",
      "type": "Bool",
      "description": "User-level setting that allows mutations on replicated tables to make use of non-deterministic functions such as `dictGet`.\n\nGiven that, for example, dictionaries, can be out of sync across nodes, mutations that pull values from them are disallowed on replicated tables by default. Enabling this setting allows this behavior, making it the user's responsibility to ensure that the data used is in sync across all nodes.\n\n**Example**\n\n```xml\n<profiles>\n    <default>\n        <allow_nondeterministic_mutations>1</allow_nondeterministic_mutations>\n\n        <!-- ... -->\n    </default>\n\n    <!-- ... -->\n\n</profiles>\n```"
    },
    {
      "name": "allow_nondeterministic_optimize_skip_unused_shards",
      "type": "Bool",
      "description": "Allow nondeterministic (like `rand` or `dictGet`, since later has some caveats with updates) functions in sharding key.\n\nPossible values:\n\n- 0 — Disallowed.\n- 1 — Allowed."
    },
    {
      "name": "allow_not_comparable_types_in_comparison_functions",
      "type": "Bool",
      "description": "Allows or restricts using not comparable types (like JSON/Object/AggregateFunction) in comparison functions `equal/less/greater/etc`."
    },
    {
      "name": "allow_not_comparable_types_in_order_by",
      "type": "Bool",
      "description": "Allows or restricts using not comparable types (like JSON/Object/AggregateFunction) in ORDER BY keys."
    },
    {
      "name": "allow_prefetched_read_pool_for_local_filesystem",
      "type": "Bool",
      "description": "Prefer prefetched threadpool if all parts are on local filesystem"
    },
    {
      "name": "allow_prefetched_read_pool_for_remote_filesystem",
      "type": "Bool",
      "description": "Prefer prefetched threadpool if all parts are on remote filesystem"
    },
    {
      "name": "allow_push_predicate_ast_for_distributed_subqueries",
      "type": "Bool",
      "description": "Allows push predicate on AST level for distributed subqueries with enabled anlyzer"
    },
    {
      "name": "allow_push_predicate_when_subquery_contains_with",
      "type": "Bool",
      "description": "Allows push predicate when subquery contains WITH clause"
    },
    {
      "name": "allow_reorder_prewhere_conditions",
      "type": "Bool",
      "description": "When moving conditions from WHERE to PREWHERE, allow reordering them to optimize filtering"
    },
    {
      "name": "allow_settings_after_format_in_insert",
      "type": "Bool",
      "description": "Control whether `SETTINGS` after `FORMAT` in `INSERT` queries is allowed or not. It is not recommended to use this, since this may interpret part of `SETTINGS` as values.\n\nExample:\n\n```sql\nINSERT INTO FUNCTION null('foo String') SETTINGS max_threads=1 VALUES ('bar');\n```\n\nBut the following query will work only with `allow_settings_after_format_in_insert`:\n\n```sql\nSET allow_settings_after_format_in_insert=1;\nINSERT INTO FUNCTION null('foo String') VALUES ('bar') SETTINGS max_threads=1;\n```\n\nPossible values:\n\n- 0 — Disallow.\n- 1 — Allow.\n\n:::note\nUse this setting only for backward compatibility if your use cases depend on old syntax.\n:::"
    },
    {
      "name": "allow_simdjson",
      "type": "Bool",
      "description": "Allow using simdjson library in 'JSON*' functions if AVX2 instructions are available. If disabled rapidjson will be used."
    },
    {
      "name": "allow_special_bool_values_inside_variant",
      "type": "Bool",
      "description": "Allows to parse Bool values inside Variant type from special text bool values like \"on\", \"off\", \"enable\", \"disable\", etc."
    },
    {
      "name": "allow_statistic_optimize",
      "type": "Bool",
      "description": "Allows using statistics to optimize queries"
    },
    {
      "name": "allow_statistics_optimize",
      "type": "Bool",
      "description": "Allows using statistics to optimize queries"
    },
    {
      "name": "allow_suspicious_codecs",
      "type": "Bool",
      "description": "If it is set to true, allow to specify meaningless compression codecs."
    },
    {
      "name": "allow_suspicious_fixed_string_types",
      "type": "Bool",
      "description": "In CREATE TABLE statement allows creating columns of type FixedString(n) with n > 256. FixedString with length >= 256 is suspicious and most likely indicates a misuse"
    },
    {
      "name": "allow_suspicious_indices",
      "type": "Bool",
      "description": "Reject primary/secondary indexes and sorting keys with identical expressions"
    },
    {
      "name": "allow_suspicious_low_cardinality_types",
      "type": "Bool",
      "description": "Allows or restricts using [LowCardinality](../../sql-reference/data-types/lowcardinality.md) with data types with fixed size of 8 bytes or less: numeric data types and `FixedString(8_bytes_or_less)`.\n\nFor small fixed values using of `LowCardinality` is usually inefficient, because ClickHouse stores a numeric index for each row. As a result:\n\n- Disk space usage can rise.\n- RAM consumption can be higher, depending on a dictionary size.\n- Some functions can work slower due to extra coding/encoding operations.\n\nMerge times in [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md)-engine tables can grow due to all the reasons described above.\n\nPossible values:\n\n- 1 — Usage of `LowCardinality` is not restricted.\n- 0 — Usage of `LowCardinality` is restricted."
    },
    {
      "name": "allow_suspicious_primary_key",
      "type": "Bool",
      "description": "Allow suspicious `PRIMARY KEY`/`ORDER BY` for MergeTree (i.e. SimpleAggregateFunction)."
    },
    {
      "name": "allow_suspicious_ttl_expressions",
      "type": "Bool",
      "description": "Reject TTL expressions that don't depend on any of table's columns. It indicates a user error most of the time."
    },
    {
      "name": "allow_suspicious_types_in_group_by",
      "type": "Bool",
      "description": "Allows or restricts using [Variant](../../sql-reference/data-types/variant.md) and [Dynamic](../../sql-reference/data-types/dynamic.md) types in GROUP BY keys."
    },
    {
      "name": "allow_suspicious_types_in_order_by",
      "type": "Bool",
      "description": "Allows or restricts using [Variant](../../sql-reference/data-types/variant.md) and [Dynamic](../../sql-reference/data-types/dynamic.md) types in ORDER BY keys."
    },
    {
      "name": "allow_suspicious_variant_types",
      "type": "Bool",
      "description": "In CREATE TABLE statement allows specifying Variant type with similar variant types (for example, with different numeric or date types). Enabling this setting may introduce some ambiguity when working with values with similar types."
    },
    {
      "name": "allow_unrestricted_reads_from_keeper",
      "type": "Bool",
      "description": "Allow unrestricted (without condition on path) reads from system.zookeeper table, can be handy, but is not safe for zookeeper"
    },
    {
      "name": "alter_move_to_space_execute_async",
      "type": "Bool",
      "description": "Execute ALTER TABLE MOVE ... TO [DISK|VOLUME] asynchronously"
    },
    {
      "name": "alter_partition_verbose_result",
      "type": "Bool",
      "description": "Enables or disables the display of information about the parts to which the manipulation operations with partitions and parts have been successfully applied.\nApplicable to [ATTACH PARTITION|PART](/sql-reference/statements/alter/partition#attach-partitionpart) and to [FREEZE PARTITION](/sql-reference/statements/alter/partition#freeze-partition).\n\nPossible values:\n\n- 0 — disable verbosity.\n- 1 — enable verbosity.\n\n**Example**\n\n```sql\nCREATE TABLE test(a Int64, d Date, s String) ENGINE = MergeTree PARTITION BY toYYYYMDECLARE(d) ORDER BY a;\nINSERT INTO test VALUES(1, '2021-01-01', '');\nINSERT INTO test VALUES(1, '2021-01-01', '');\nALTER TABLE test DETACH PARTITION ID '202101';\n\nALTER TABLE test ATTACH PARTITION ID '202101' SETTINGS alter_partition_verbose_result = 1;\n\n┌─command_type─────┬─partition_id─┬─part_name────┬─old_part_name─┐\n│ ATTACH PARTITION │ 202101       │ 202101_7_7_0 │ 202101_5_5_0  │\n│ ATTACH PARTITION │ 202101       │ 202101_8_8_0 │ 202101_6_6_0  │\n└──────────────────┴──────────────┴──────────────┴───────────────┘\n\nALTER TABLE test FREEZE SETTINGS alter_partition_verbose_result = 1;\n\n┌─command_type─┬─partition_id─┬─part_name────┬─backup_name─┬─backup_path───────────────────┬─part_backup_path────────────────────────────────────────────┐\n│ FREEZE ALL   │ 202101       │ 202101_7_7_0 │ 8           │ /var/lib/clickhouse/shadow/8/ │ /var/lib/clickhouse/shadow/8/data/default/test/202101_7_7_0 │\n│ FREEZE ALL   │ 202101       │ 202101_8_8_0 │ 8           │ /var/lib/clickhouse/shadow/8/ │ /var/lib/clickhouse/shadow/8/data/default/test/202101_8_8_0 │\n└──────────────┴──────────────┴──────────────┴─────────────┴───────────────────────────────┴─────────────────────────────────────────────────────────────┘\n```"
    },
    {
      "name": "alter_sync",
      "type": "UInt64",
      "description": "Allows to set up waiting for actions to be executed on replicas by [ALTER](../../sql-reference/statements/alter/index.md), [OPTIMIZE](../../sql-reference/statements/optimize.md) or [TRUNCATE](../../sql-reference/statements/truncate.md) queries.\n\nPossible values:\n\n- 0 — Do not wait.\n- 1 — Wait for own execution.\n- 2 — Wait for everyone.\n\nCloud default value: `0`.\n\n:::note\n`alter_sync` is applicable to `Replicated` tables only, it does nothing to alters of not `Replicated` tables.\n:::"
    },
    {
      "name": "alter_update_mode",
      "type": "AlterUpdateMode",
      "description": "A mode for `ALTER` queries that have the `UPDATE` commands.\n\nPossible values:\n- `heavy` - run regular mutation.\n- `lightweight` - run lightweight update if possible, run regular mutation otherwise.\n- `lightweight_force` - run lightweight update if possible, throw otherwise."
    },
    {
      "name": "analyze_index_with_space_filling_curves",
      "type": "Bool",
      "description": "If a table has a space-filling curve in its index, e.g. `ORDER BY mortonEncode(x, y)` or `ORDER BY hilbertEncode(x, y)`, and the query has conditions on its arguments, e.g. `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, use the space-filling curve for index analysis."
    },
    {
      "name": "analyzer_compatibility_join_using_top_level_identifier",
      "type": "Bool",
      "description": "Force to resolve identifier in JOIN USING from projection (for example, in `SELECT a + 1 AS b FROM t1 JOIN t2 USING (b)` join will be performed by `t1.a + 1 = t2.b`, rather then `t1.b = t2.b`)."
    },
    {
      "name": "annoy_index_search_k_nodes",
      "type": "Int64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "any_join_distinct_right_table_keys",
      "type": "Bool",
      "description": "Enables legacy ClickHouse server behaviour in `ANY INNER|LEFT JOIN` operations.\n\n:::note\nUse this setting only for backward compatibility if your use cases depend on legacy `JOIN` behaviour.\n:::\n\nWhen the legacy behaviour is enabled:\n\n- Results of `t1 ANY LEFT JOIN t2` and `t2 ANY RIGHT JOIN t1` operations are not equal because ClickHouse uses the logic with many-to-one left-to-right table keys mapping.\n- Results of `ANY INNER JOIN` operations contain all rows from the left table like the `SEMI LEFT JOIN` operations do.\n\nWhen the legacy behaviour is disabled:\n\n- Results of `t1 ANY LEFT JOIN t2` and `t2 ANY RIGHT JOIN t1` operations are equal because ClickHouse uses the logic which provides one-to-many keys mapping in `ANY RIGHT JOIN` operations.\n- Results of `ANY INNER JOIN` operations contain one row per key from both the left and right tables.\n\nPossible values:\n\n- 0 — Legacy behaviour is disabled.\n- 1 — Legacy behaviour is enabled.\n\nSee also:\n\n- [JOIN strictness](/sql-reference/statements/select/join#settings)"
    },
    {
      "name": "apply_deleted_mask",
      "type": "Bool",
      "description": "Enables filtering out rows deleted with lightweight DELETE. If disabled, a query will be able to read those rows. This is useful for debugging and \\\"undelete\\\" scenarios"
    },
    {
      "name": "apply_mutations_on_fly",
      "type": "Bool",
      "description": "If true, mutations (UPDATEs and DELETEs) which are not materialized in data part will be applied on SELECTs."
    },
    {
      "name": "apply_patch_parts",
      "type": "Bool",
      "description": "If true, patch parts (that represent lightweight updates) are applied on SELECTs."
    },
    {
      "name": "apply_settings_from_server",
      "type": "Bool",
      "description": "Whether the client should accept settings from server.\n\nThis only affects operations performed on the client side, in particular parsing the INSERT input data and formatting the query result. Most of query execution happens on the server and is not affected by this setting.\n\nNormally this setting should be set in user profile (users.xml or queries like `ALTER USER`), not through the client (client command line arguments, `SET` query, or `SETTINGS` section of `SELECT` query). Through the client it can be changed to false, but can't be changed to true (because the server won't send the settings if user profile has `apply_settings_from_server = false`).\n\nNote that initially (24.12) there was a server setting (`send_settings_to_client`), but latter it got replaced with this client setting, for better usability."
    },
    {
      "name": "asterisk_include_alias_columns",
      "type": "Bool",
      "description": "Include [ALIAS](../../sql-reference/statements/create/table.md/#alias) columns for wildcard query (`SELECT *`).\n\nPossible values:\n\n- 0 - disabled\n- 1 - enabled"
    },
    {
      "name": "asterisk_include_materialized_columns",
      "type": "Bool",
      "description": "Include [MATERIALIZED](/sql-reference/statements/create/view#materialized-view) columns for wildcard query (`SELECT *`).\n\nPossible values:\n\n- 0 - disabled\n- 1 - enabled"
    },
    {
      "name": "async_insert",
      "type": "Bool",
      "description": "If true, data from INSERT query is stored in queue and later flushed to table in background. If wait_for_async_insert is false, INSERT query is processed almost instantly, otherwise client will wait until data will be flushed to table"
    },
    {
      "name": "async_insert_busy_timeout_decrease_rate",
      "type": "Double",
      "description": "The exponential growth rate at which the adaptive asynchronous insert timeout decreases"
    },
    {
      "name": "async_insert_busy_timeout_increase_rate",
      "type": "Double",
      "description": "The exponential growth rate at which the adaptive asynchronous insert timeout increases"
    },
    {
      "name": "async_insert_busy_timeout_max_ms",
      "type": "Milliseconds",
      "description": "Maximum time to wait before dumping collected data per query since the first data appeared."
    },
    {
      "name": "async_insert_busy_timeout_min_ms",
      "type": "Milliseconds",
      "description": "If auto-adjusting is enabled through async_insert_use_adaptive_busy_timeout, minimum time to wait before dumping collected data per query since the first data appeared. It also serves as the initial value for the adaptive algorithm"
    },
    {
      "name": "async_insert_busy_timeout_ms",
      "type": "Milliseconds",
      "description": "Maximum time to wait before dumping collected data per query since the first data appeared."
    },
    {
      "name": "async_insert_cleanup_timeout_ms",
      "type": "Milliseconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "async_insert_deduplicate",
      "type": "Bool",
      "description": "For async INSERT queries in the replicated table, specifies that deduplication of inserting blocks should be performed"
    },
    {
      "name": "async_insert_max_data_size",
      "type": "UInt64",
      "description": "Maximum size in bytes of unparsed data collected per query before being inserted"
    },
    {
      "name": "async_insert_max_query_number",
      "type": "UInt64",
      "description": "Maximum number of insert queries before being inserted"
    },
    {
      "name": "async_insert_poll_timeout_ms",
      "type": "Milliseconds",
      "description": "Timeout for polling data from asynchronous insert queue"
    },
    {
      "name": "async_insert_stale_timeout_ms",
      "type": "Milliseconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "async_insert_threads",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "async_insert_use_adaptive_busy_timeout",
      "type": "Bool",
      "description": "If it is set to true, use adaptive busy timeout for asynchronous inserts"
    },
    {
      "name": "async_query_sending_for_remote",
      "type": "Bool",
      "description": "Enables asynchronous connection creation and query sending while executing remote query.\n\nEnabled by default."
    },
    {
      "name": "async_socket_for_remote",
      "type": "Bool",
      "description": "Enables asynchronous read from socket while executing remote query.\n\nEnabled by default."
    },
    {
      "name": "azure_allow_parallel_part_upload",
      "type": "Bool",
      "description": "Use multiple threads for azure multipart upload."
    },
    {
      "name": "azure_check_objects_after_upload",
      "type": "Bool",
      "description": "Check each uploaded object in azure blob storage to be sure that upload was successful"
    },
    {
      "name": "azure_create_new_file_on_insert",
      "type": "Bool",
      "description": "Enables or disables creating a new file on each insert in azure engine tables"
    },
    {
      "name": "azure_ignore_file_doesnt_exist",
      "type": "Bool",
      "description": "Ignore absence of file if it does not exist when reading certain keys.\n\nPossible values:\n- 1 — `SELECT` returns empty result.\n- 0 — `SELECT` throws an exception."
    },
    {
      "name": "azure_list_object_keys_size",
      "type": "UInt64",
      "description": "Maximum number of files that could be returned in batch by ListObject request"
    },
    {
      "name": "azure_max_blocks_in_multipart_upload",
      "type": "UInt64",
      "description": "Maximum number of blocks in multipart upload for Azure."
    },
    {
      "name": "azure_max_inflight_parts_for_one_file",
      "type": "UInt64",
      "description": "The maximum number of a concurrent loaded parts in multipart upload request. 0 means unlimited."
    },
    {
      "name": "azure_max_single_part_copy_size",
      "type": "UInt64",
      "description": "The maximum size of object to copy using single part copy to Azure blob storage."
    },
    {
      "name": "azure_max_single_part_upload_size",
      "type": "UInt64",
      "description": "The maximum size of object to upload using singlepart upload to Azure blob storage."
    },
    {
      "name": "azure_max_single_read_retries",
      "type": "UInt64",
      "description": "The maximum number of retries during single Azure blob storage read."
    },
    {
      "name": "azure_max_unexpected_write_error_retries",
      "type": "UInt64",
      "description": "The maximum number of retries in case of unexpected errors during Azure blob storage write"
    },
    {
      "name": "azure_max_upload_part_size",
      "type": "UInt64",
      "description": "The maximum size of part to upload during multipart upload to Azure blob storage."
    },
    {
      "name": "azure_min_upload_part_size",
      "type": "UInt64",
      "description": "The minimum size of part to upload during multipart upload to Azure blob storage."
    },
    {
      "name": "azure_sdk_max_retries",
      "type": "UInt64",
      "description": "Maximum number of retries in azure sdk"
    },
    {
      "name": "azure_sdk_retry_initial_backoff_ms",
      "type": "UInt64",
      "description": "Minimal backoff between retries in azure sdk"
    },
    {
      "name": "azure_sdk_retry_max_backoff_ms",
      "type": "UInt64",
      "description": "Maximal backoff between retries in azure sdk"
    },
    {
      "name": "azure_skip_empty_files",
      "type": "Bool",
      "description": "Enables or disables skipping empty files in S3 engine.\n\nPossible values:\n- 0 — `SELECT` throws an exception if empty file is not compatible with requested format.\n- 1 — `SELECT` returns empty result for empty file."
    },
    {
      "name": "azure_strict_upload_part_size",
      "type": "UInt64",
      "description": "The exact size of part to upload during multipart upload to Azure blob storage."
    },
    {
      "name": "azure_throw_on_zero_files_match",
      "type": "Bool",
      "description": "Throw an error if matched zero files according to glob expansion rules.\n\nPossible values:\n- 1 — `SELECT` throws an exception.\n- 0 — `SELECT` returns empty result."
    },
    {
      "name": "azure_truncate_on_insert",
      "type": "Bool",
      "description": "Enables or disables truncate before insert in azure engine tables."
    },
    {
      "name": "azure_upload_part_size_multiply_factor",
      "type": "UInt64",
      "description": "Multiply azure_min_upload_part_size by this factor each time azure_multiply_parts_count_threshold parts were uploaded from a single write to Azure blob storage."
    },
    {
      "name": "azure_upload_part_size_multiply_parts_count_threshold",
      "type": "UInt64",
      "description": "Each time this number of parts was uploaded to Azure blob storage, azure_min_upload_part_size is multiplied by azure_upload_part_size_multiply_factor."
    },
    {
      "name": "background_buffer_flush_schedule_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_common_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_distributed_schedule_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_fetches_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_merges_mutations_concurrency_ratio",
      "type": "Float",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_message_broker_schedule_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_move_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "background_schedule_pool_size",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "backup_restore_batch_size_for_keeper_multi",
      "type": "UInt64",
      "description": "Maximum size of batch for multi request to [Zoo]Keeper during backup or restore"
    },
    {
      "name": "backup_restore_batch_size_for_keeper_multiread",
      "type": "UInt64",
      "description": "Maximum size of batch for multiread request to [Zoo]Keeper during backup or restore"
    },
    {
      "name": "backup_restore_failure_after_host_disconnected_for_seconds",
      "type": "UInt64",
      "description": "If a host during a BACKUP ON CLUSTER or RESTORE ON CLUSTER operation doesn't recreate its ephemeral 'alive' node in ZooKeeper for this amount of time then the whole backup or restore is considered as failed.\nThis value should be bigger than any reasonable time for a host to reconnect to ZooKeeper after a failure.\nZero means unlimited."
    },
    {
      "name": "backup_restore_finish_timeout_after_error_sec",
      "type": "UInt64",
      "description": "How long the initiator should wait for other host to react to the 'error' node and stop their work on the current BACKUP ON CLUSTER or RESTORE ON CLUSTER operation."
    },
    {
      "name": "backup_restore_keeper_fault_injection_probability",
      "type": "Float",
      "description": "Approximate probability of failure for a keeper request during backup or restore. Valid value is in interval [0.0f, 1.0f]"
    },
    {
      "name": "backup_restore_keeper_fault_injection_seed",
      "type": "UInt64",
      "description": "0 - random seed, otherwise the setting value"
    },
    {
      "name": "backup_restore_keeper_max_retries",
      "type": "UInt64",
      "description": "Max retries for [Zoo]Keeper operations in the middle of a BACKUP or RESTORE operation.\nShould be big enough so the whole operation won't fail because of a temporary [Zoo]Keeper failure."
    },
    {
      "name": "backup_restore_keeper_max_retries_while_handling_error",
      "type": "UInt64",
      "description": "Max retries for [Zoo]Keeper operations while handling an error of a BACKUP ON CLUSTER or RESTORE ON CLUSTER operation."
    },
    {
      "name": "backup_restore_keeper_max_retries_while_initializing",
      "type": "UInt64",
      "description": "Max retries for [Zoo]Keeper operations during the initialization of a BACKUP ON CLUSTER or RESTORE ON CLUSTER operation."
    },
    {
      "name": "backup_restore_keeper_retry_initial_backoff_ms",
      "type": "UInt64",
      "description": "Initial backoff timeout for [Zoo]Keeper operations during backup or restore"
    },
    {
      "name": "backup_restore_keeper_retry_max_backoff_ms",
      "type": "UInt64",
      "description": "Max backoff timeout for [Zoo]Keeper operations during backup or restore"
    },
    {
      "name": "backup_restore_keeper_value_max_size",
      "type": "UInt64",
      "description": "Maximum size of data of a [Zoo]Keeper's node during backup"
    },
    {
      "name": "backup_restore_s3_retry_attempts",
      "type": "UInt64",
      "description": "Setting for Aws::Client::RetryStrategy, Aws::Client does retries itself, 0 means no retries. It takes place only for backup/restore."
    },
    {
      "name": "backup_slow_all_threads_after_retryable_s3_error",
      "type": "Bool",
      "description": "When set to `true`, all threads executing S3 requests to the same endpoint are slowed down\nafter any single S3 request encounters a retryable S3 error, such as 'Slow Down'.\nWhen set to `false`, each thread handles s3 request backoff independently of the others."
    },
    {
      "name": "backup_threads",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "bool_false_representation",
      "type": "String",
      "description": "Text to represent false bool value in TSV/CSV/Vertical/Pretty formats."
    },
    {
      "name": "bool_true_representation",
      "type": "String",
      "description": "Text to represent true bool value in TSV/CSV/Vertical/Pretty formats."
    },
    {
      "name": "cache_warmer_threads",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Number of background threads for speculatively downloading new data parts into file cache, when [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch) is enabled. Zero to disable."
    },
    {
      "name": "calculate_text_stack_trace",
      "type": "Bool",
      "description": "Calculate text stack trace in case of exceptions during query execution. This is the default. It requires symbol lookups that may slow down fuzzing tests when a huge amount of wrong queries are executed. In normal cases, you should not disable this option."
    },
    {
      "name": "cancel_http_readonly_queries_on_client_close",
      "type": "Bool",
      "description": "Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response.\n\nCloud default value: `1`."
    },
    {
      "name": "cast_ipv4_ipv6_default_on_conversion_error",
      "type": "Bool",
      "description": "CAST operator into IPv4, CAST operator into IPV6 type, toIPv4, toIPv6 functions will return default value instead of throwing exception on conversion error."
    },
    {
      "name": "cast_keep_nullable",
      "type": "Bool",
      "description": "Enables or disables keeping of the `Nullable` data type in [CAST](/sql-reference/functions/type-conversion-functions#cast) operations.\n\nWhen the setting is enabled and the argument of `CAST` function is `Nullable`, the result is also transformed to `Nullable` type. When the setting is disabled, the result always has the destination type exactly.\n\nPossible values:\n\n- 0 — The `CAST` result has exactly the destination type specified.\n- 1 — If the argument type is `Nullable`, the `CAST` result is transformed to `Nullable(DestinationDataType)`.\n\n**Examples**\n\nThe following query results in the destination data type exactly:\n\n```sql\nSET cast_keep_nullable = 0;\nSELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);\n```\n\nResult:\n\n```text\n┌─x─┬─toTypeName(CAST(toNullable(toInt32(0)), 'Int32'))─┐\n│ 0 │ Int32                                             │\n└───┴───────────────────────────────────────────────────┘\n```\n\nThe following query results in the `Nullable` modification on the destination data type:\n\n```sql\nSET cast_keep_nullable = 1;\nSELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);\n```\n\nResult:\n\n```text\n┌─x─┬─toTypeName(CAST(toNullable(toInt32(0)), 'Int32'))─┐\n│ 0 │ Nullable(Int32)                                   │\n└───┴───────────────────────────────────────────────────┘\n```\n\n**See Also**\n\n- [CAST](/sql-reference/functions/type-conversion-functions#cast) function"
    },
    {
      "name": "cast_string_to_date_time_mode",
      "type": "DateTimeInputFormat",
      "description": "Allows choosing a parser of the text representation of date and time during cast from String.\n\nPossible values:\n\n- `'best_effort'` — Enables extended parsing.\n\n    ClickHouse can parse the basic `YYYY-MM-DD HH:MM:SS` format and all [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time formats. For example, `'2018-06-08T01:02:03.000Z'`.\n\n- `'best_effort_us'` — Similar to `best_effort` (see the difference in [parseDateTimeBestEffortUS](../../sql-reference/functions/type-conversion-functions#parsedatetimebesteffortus)\n\n- `'basic'` — Use basic parser.\n\n    ClickHouse can parse only the basic `YYYY-MM-DD HH:MM:SS` or `YYYY-MM-DD` format. For example, `2019-08-20 10:18:56` or `2019-08-20`.\n\nSee also:\n\n- [DateTime data type.](../../sql-reference/data-types/datetime.md)\n- [Functions for working with dates and times.](../../sql-reference/functions/date-time-functions.md)"
    },
    {
      "name": "cast_string_to_dynamic_use_inference",
      "type": "Bool",
      "description": "Use types inference during String to Dynamic conversion"
    },
    {
      "name": "cast_string_to_variant_use_inference",
      "type": "Bool",
      "description": "Use types inference during String to Variant conversion."
    },
    {
      "name": "check_query_single_value_result",
      "type": "Bool",
      "description": "Defines the level of detail for the [CHECK TABLE](/sql-reference/statements/check-table) query result for `MergeTree` family engines .\n\nPossible values:\n\n- 0 — the query shows a check status for every individual data part of a table.\n- 1 — the query shows the general table check status."
    },
    {
      "name": "check_referential_table_dependencies",
      "type": "Bool",
      "description": "Check that DDL query (such as DROP TABLE or RENAME) will not break referential dependencies"
    },
    {
      "name": "check_table_dependencies",
      "type": "Bool",
      "description": "Check that DDL query (such as DROP TABLE or RENAME) will not break dependencies"
    },
    {
      "name": "checksum_on_read",
      "type": "Bool",
      "description": "Validate checksums on reading. It is enabled by default and should be always enabled in production. Please do not expect any benefits in disabling this setting. It may only be used for experiments and benchmarks. The setting is only applicable for tables of MergeTree family. Checksums are always validated for other table engines and when receiving data over the network."
    },
    {
      "name": "cloud_mode",
      "type": "Bool",
      "description": "Cloud mode"
    },
    {
      "name": "cloud_mode_database_engine",
      "type": "UInt64",
      "description": "The database engine allowed in Cloud. 1 - rewrite DDLs to use Replicated database, 2 - rewrite DDLs to use Shared database"
    },
    {
      "name": "cloud_mode_engine",
      "type": "UInt64",
      "description": "The engine family allowed in Cloud.\n\n- 0 - allow everything\n- 1 - rewrite DDLs to use *ReplicatedMergeTree\n- 2 - rewrite DDLs to use SharedMergeTree\n- 3 - rewrite DDLs to use SharedMergeTree except when explicitly passed remote disk is specified\n\nUInt64 to minimize public part"
    },
    {
      "name": "cluster_for_parallel_replicas",
      "type": "String",
      "description": "Cluster for a shard in which current server is located"
    },
    {
      "name": "collect_hash_table_stats_during_aggregation",
      "type": "Bool",
      "description": "Enable collecting hash table statistics to optimize memory allocation"
    },
    {
      "name": "collect_hash_table_stats_during_joins",
      "type": "Bool",
      "description": "Enable collecting hash table statistics to optimize memory allocation"
    },
    {
      "name": "column_names_for_schema_inference",
      "type": "String",
      "description": "The list of column names to use in schema inference for formats without column names. The format: 'column1,column2,column3,...'"
    },
    {
      "name": "compatibility",
      "type": "String",
      "description": "The `compatibility` setting causes ClickHouse to use the default settings of a previous version of ClickHouse, where the previous version is provided as the setting.\n\nIf settings are set to non-default values, then those settings are honored (only settings that have not been modified are affected by the `compatibility` setting).\n\nThis setting takes a ClickHouse version number as a string, like `22.3`, `22.8`. An empty value means that this setting is disabled.\n\nDisabled by default.\n\n:::note\nIn ClickHouse Cloud the compatibility setting must be set by ClickHouse Cloud support.  Please [open a case](https://clickhouse.cloud/support) to have it set.\n:::"
    },
    {
      "name": "compatibility_ignore_auto_increment_in_create_table",
      "type": "Bool",
      "description": "Ignore AUTO_INCREMENT keyword in column declaration if true, otherwise return error. It simplifies migration from MySQL"
    },
    {
      "name": "compatibility_ignore_collation_in_create_table",
      "type": "Bool",
      "description": "Compatibility ignore collation in create table"
    },
    {
      "name": "compile_aggregate_expressions",
      "type": "Bool",
      "description": "Enables or disables JIT-compilation of aggregate functions to native code. Enabling this setting can improve the performance.\n\nPossible values:\n\n- 0 — Aggregation is done without JIT compilation.\n- 1 — Aggregation is done using JIT compilation.\n\n**See Also**\n\n- [min_count_to_compile_aggregate_expression](#min_count_to_compile_aggregate_expression)"
    },
    {
      "name": "compile_expressions",
      "type": "Bool",
      "description": "Compile some scalar functions and operators to native code."
    },
    {
      "name": "compile_sort_description",
      "type": "Bool",
      "description": "Compile sort description to native code."
    },
    {
      "name": "connect_timeout",
      "type": "Seconds",
      "description": "Connection timeout if there are no replicas."
    },
    {
      "name": "connect_timeout_with_failover_ms",
      "type": "Milliseconds",
      "description": "The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the 'shard' and 'replica' sections are used in the cluster definition.\nIf unsuccessful, several attempts are made to connect to various replicas."
    },
    {
      "name": "connect_timeout_with_failover_secure_ms",
      "type": "Milliseconds",
      "description": "Connection timeout for selecting first healthy replica (for secure connections)."
    },
    {
      "name": "connection_pool_max_wait_ms",
      "type": "Milliseconds",
      "description": "The wait time in milliseconds for a connection when the connection pool is full.\n\nPossible values:\n\n- Positive integer.\n- 0 — Infinite timeout."
    },
    {
      "name": "connections_with_failover_max_tries",
      "type": "UInt64",
      "description": "The maximum number of connection attempts with each replica for the Distributed table engine."
    },
    {
      "name": "convert_query_to_cnf",
      "type": "Bool",
      "description": "When set to `true`, a `SELECT` query will be converted to conjuctive normal form (CNF). There are scenarios where rewriting a query in CNF may execute faster (view this [Github issue](https://github.com/ClickHouse/ClickHouse/issues/11749) for an explanation).\n\nFor example, notice how the following `SELECT` query is not modified (the default behavior):\n\n```sql\nEXPLAIN SYNTAX\nSELECT *\nFROM\n(\n    SELECT number AS x\n    FROM numbers(20)\n) AS a\nWHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))\nSETTINGS convert_query_to_cnf = false;\n```\n\nThe result is:\n\n```response\n┌─explain────────────────────────────────────────────────────────┐\n│ SELECT x                                                       │\n│ FROM                                                           │\n│ (                                                              │\n│     SELECT number AS x                                         │\n│     FROM numbers(20)                                           │\n│     WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15)) │\n│ ) AS a                                                         │\n│ WHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))     │\n│ SETTINGS convert_query_to_cnf = 0                              │\n└────────────────────────────────────────────────────────────────┘\n```\n\nLet's set `convert_query_to_cnf` to `true` and see what changes:\n\n```sql\nEXPLAIN SYNTAX\nSELECT *\nFROM\n(\n    SELECT number AS x\n    FROM numbers(20)\n) AS a\nWHERE ((x >= 1) AND (x <= 5)) OR ((x >= 10) AND (x <= 15))\nSETTINGS convert_query_to_cnf = true;\n```\n\nNotice the `WHERE` clause is rewritten in CNF, but the result set is the identical - the Boolean logic is unchanged:\n\n```response\n┌─explain───────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ SELECT x                                                                                                              │\n│ FROM                                                                                                                  │\n│ (                                                                                                                     │\n│     SELECT number AS x                                                                                                │\n│     FROM numbers(20)                                                                                                  │\n│     WHERE ((x <= 15) OR (x <= 5)) AND ((x <= 15) OR (x >= 1)) AND ((x >= 10) OR (x <= 5)) AND ((x >= 10) OR (x >= 1)) │\n│ ) AS a                                                                                                                │\n│ WHERE ((x >= 10) OR (x >= 1)) AND ((x >= 10) OR (x <= 5)) AND ((x <= 15) OR (x >= 1)) AND ((x <= 15) OR (x <= 5))     │\n│ SETTINGS convert_query_to_cnf = 1                                                                                     │\n└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\nPossible values: true, false"
    },
    {
      "name": "count_distinct_implementation",
      "type": "String",
      "description": "Specifies which of the `uniq*` functions should be used to perform the [COUNT(DISTINCT ...)](/sql-reference/aggregate-functions/reference/count) construction.\n\nPossible values:\n\n- [uniq](/sql-reference/aggregate-functions/reference/uniq)\n- [uniqCombined](/sql-reference/aggregate-functions/reference/uniqcombined)\n- [uniqCombined64](/sql-reference/aggregate-functions/reference/uniqcombined64)\n- [uniqHLL12](/sql-reference/aggregate-functions/reference/uniqhll12)\n- [uniqExact](/sql-reference/aggregate-functions/reference/uniqexact)"
    },
    {
      "name": "count_distinct_optimization",
      "type": "Bool",
      "description": "Rewrite count distinct to subquery of group by"
    },
    {
      "name": "count_matches_stop_at_empty_match",
      "type": "Bool",
      "description": "Stop counting once a pattern matches zero-length in the `countMatches` function."
    },
    {
      "name": "create_if_not_exists",
      "type": "Bool",
      "description": "Enable `IF NOT EXISTS` for `CREATE` statement by default. If either this setting or `IF NOT EXISTS` is specified and a table with the provided name already exists, no exception will be thrown."
    },
    {
      "name": "create_index_ignore_unique",
      "type": "Bool",
      "description": "Ignore UNIQUE keyword in CREATE UNIQUE INDEX. Made for SQL compatibility tests."
    },
    {
      "name": "create_replicated_merge_tree_fault_injection_probability",
      "type": "Float",
      "description": "The probability of a fault injection during table creation after creating metadata in ZooKeeper"
    },
    {
      "name": "create_table_empty_primary_key_by_default",
      "type": "Bool",
      "description": "Allow to create *MergeTree tables with empty primary key when ORDER BY and PRIMARY KEY not specified"
    },
    {
      "name": "cross_join_min_bytes_to_compress",
      "type": "UInt64",
      "description": "Minimal size of block to compress in CROSS JOIN. Zero value means - disable this threshold. This block is compressed when any of the two thresholds (by rows or by bytes) are reached."
    },
    {
      "name": "cross_join_min_rows_to_compress",
      "type": "UInt64",
      "description": "Minimal count of rows to compress block in CROSS JOIN. Zero value means - disable this threshold. This block is compressed when any of the two thresholds (by rows or by bytes) are reached."
    },
    {
      "name": "cross_to_inner_join_rewrite",
      "type": "UInt64",
      "description": "Use inner join instead of comma/cross join if there are joining expressions in the WHERE section. Values: 0 - no rewrite, 1 - apply if possible for comma/cross, 2 - force rewrite all comma joins, cross - if possible"
    },
    {
      "name": "data_type_default_nullable",
      "type": "Bool",
      "description": "Allows data types without explicit modifiers [NULL or NOT NULL](/sql-reference/statements/create/table#null-or-not-null-modifiers) in column definition will be [Nullable](/sql-reference/data-types/nullable).\n\nPossible values:\n\n- 1 — The data types in column definitions are set to `Nullable` by default.\n- 0 — The data types in column definitions are set to not `Nullable` by default."
    },
    {
      "name": "database_atomic_wait_for_drop_and_detach_synchronously",
      "type": "Bool",
      "description": "Adds a modifier `SYNC` to all `DROP` and `DETACH` queries.\n\nPossible values:\n\n- 0 — Queries will be executed with delay.\n- 1 — Queries will be executed without delay."
    },
    {
      "name": "database_replicated_allow_explicit_uuid",
      "type": "UInt64",
      "description": "0 - Don't allow to explicitly specify UUIDs for tables in Replicated databases. 1 - Allow. 2 - Allow, but ignore the specified UUID and generate a random one instead."
    },
    {
      "name": "database_replicated_allow_heavy_create",
      "type": "Bool",
      "description": "Allow long-running DDL queries (CREATE AS SELECT and POPULATE) in Replicated database engine. Note that it can block DDL queue for a long time."
    },
    {
      "name": "database_replicated_allow_only_replicated_engine",
      "type": "Bool",
      "description": "Allow to create only Replicated tables in database with engine Replicated"
    },
    {
      "name": "database_replicated_allow_replicated_engine_arguments",
      "type": "UInt64",
      "description": "0 - Don't allow to explicitly specify ZooKeeper path and replica name for *MergeTree tables in Replicated databases. 1 - Allow. 2 - Allow, but ignore the specified path and use default one instead. 3 - Allow and don't log a warning."
    },
    {
      "name": "database_replicated_always_detach_permanently",
      "type": "Bool",
      "description": "Execute DETACH TABLE as DETACH TABLE PERMANENTLY if database engine is Replicated"
    },
    {
      "name": "database_replicated_ddl_output",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "database_replicated_enforce_synchronous_settings",
      "type": "Bool",
      "description": "Enforces synchronous waiting for some queries (see also database_atomic_wait_for_drop_and_detach_synchronously, mutations_sync, alter_sync). Not recommended to enable these settings."
    },
    {
      "name": "database_replicated_initial_query_timeout_sec",
      "type": "UInt64",
      "description": "Sets how long initial DDL query should wait for Replicated database to process previous DDL queue entries in seconds.\n\nPossible values:\n\n- Positive integer.\n- 0 — Unlimited."
    },
    {
      "name": "date_time_64_output_format_cut_trailing_zeros_align_to_groups_of_thousands",
      "type": "Bool",
      "description": "Dynamically trim the trailing zeros of datetime64 values to adjust the output scale to [0, 3, 6],\ncorresponding to 'seconds', 'milliseconds', and 'microseconds'"
    },
    {
      "name": "date_time_input_format",
      "type": "DateTimeInputFormat",
      "description": "Allows choosing a parser of the text representation of date and time.\n\nThe setting does not apply to [date and time functions](../../sql-reference/functions/date-time-functions.md).\n\nPossible values:\n\n- `'best_effort'` — Enables extended parsing.\n\n    ClickHouse can parse the basic `YYYY-MM-DD HH:MM:SS` format and all [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time formats. For example, `'2018-06-08T01:02:03.000Z'`.\n\n- `'best_effort_us'` — Similar to `best_effort` (see the difference in [parseDateTimeBestEffortUS](../../sql-reference/functions/type-conversion-functions#parsedatetimebesteffortus)\n\n- `'basic'` — Use basic parser.\n\n    ClickHouse can parse only the basic `YYYY-MM-DD HH:MM:SS` or `YYYY-MM-DD` format. For example, `2019-08-20 10:18:56` or `2019-08-20`.\n\nCloud default value: `'best_effort'`.\n\nSee also:\n\n- [DateTime data type.](../../sql-reference/data-types/datetime.md)\n- [Functions for working with dates and times.](../../sql-reference/functions/date-time-functions.md)"
    },
    {
      "name": "date_time_output_format",
      "type": "DateTimeOutputFormat",
      "description": "Allows choosing different output formats of the text representation of date and time.\n\nPossible values:\n\n- `simple` - Simple output format.\n\n    ClickHouse output date and time `YYYY-MM-DD hh:mm:ss` format. For example, `2019-08-20 10:18:56`. The calculation is performed according to the data type's time zone (if present) or server time zone.\n\n- `iso` - ISO output format.\n\n    ClickHouse output date and time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) `YYYY-MM-DDThh:mm:ssZ` format. For example, `2019-08-20T10:18:56Z`. Note that output is in UTC (`Z` means UTC).\n\n- `unix_timestamp` - Unix timestamp output format.\n\n    ClickHouse output date and time in [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) format. For example `1566285536`.\n\nSee also:\n\n- [DateTime data type.](../../sql-reference/data-types/datetime.md)\n- [Functions for working with dates and times.](../../sql-reference/functions/date-time-functions.md)"
    },
    {
      "name": "date_time_overflow_behavior",
      "type": "DateTimeOverflowBehavior",
      "description": "Defines the behavior when [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md), [DateTime64](../../sql-reference/data-types/datetime64.md) or integers are converted into Date, Date32, DateTime or DateTime64 but the value cannot be represented in the result type.\n\nPossible values:\n\n- `ignore` — Silently ignore overflows. Result are undefined.\n- `throw` — Throw an exception in case of overflow.\n- `saturate` — Saturate the result. If the value is smaller than the smallest value that can be represented by the target type, the result is chosen as the smallest representable value. If the value is bigger than the largest value that can be represented by the target type, the result is chosen as the largest representable value.\n\nDefault value: `ignore`."
    },
    {
      "name": "decimal_check_overflow",
      "type": "Bool",
      "description": "Check overflow of decimal arithmetic/comparison operations"
    },
    {
      "name": "deduplicate_blocks_in_dependent_materialized_views",
      "type": "Bool",
      "description": "Enables or disables the deduplication check for materialized views that receive data from Replicated\\* tables.\n\nPossible values:\n\n      0 — Disabled.\n      1 — Enabled.\n\nUsage\n\nBy default, deduplication is not performed for materialized views but is done upstream, in the source table.\nIf an INSERTed block is skipped due to deduplication in the source table, there will be no insertion into attached materialized views. This behaviour exists to enable the insertion of highly aggregated data into materialized views, for cases where inserted blocks are the same after materialized view aggregation but derived from different INSERTs into the source table.\nAt the same time, this behaviour \"breaks\" `INSERT` idempotency. If an `INSERT` into the main table was successful and `INSERT` into a materialized view failed (e.g. because of communication failure with ClickHouse Keeper) a client will get an error and can retry the operation. However, the materialized view won't receive the second insert because it will be discarded by deduplication in the main (source) table. The setting `deduplicate_blocks_in_dependent_materialized_views` allows for changing this behaviour. On retry, a materialized view will receive the repeat insert and will perform a deduplication check by itself,\nignoring check result for the source table, and will insert rows lost because of the first failure."
    },
    {
      "name": "default_database_engine",
      "type": "DefaultDatabaseEngine",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "default_materialized_view_sql_security",
      "type": "SQLSecurityType",
      "description": "Allows to set a default value for SQL SECURITY option when creating a materialized view. [More about SQL security](../../sql-reference/statements/create/view.md/#sql_security).\n\nThe default value is `DEFINER`."
    },
    {
      "name": "default_max_bytes_in_join",
      "type": "UInt64",
      "description": "Maximum size of right-side table if limit is required but `max_bytes_in_join` is not set."
    },
    {
      "name": "default_normal_view_sql_security",
      "type": "SQLSecurityType",
      "description": "Allows to set default `SQL SECURITY` option while creating a normal view. [More about SQL security](../../sql-reference/statements/create/view.md/#sql_security).\n\nThe default value is `INVOKER`."
    },
    {
      "name": "default_table_engine",
      "type": "DefaultTableEngine",
      "description": "Default table engine to use when `ENGINE` is not set in a `CREATE` statement.\n\nPossible values:\n\n- a string representing any valid table engine name\n\nCloud default value: `SharedMergeTree`.\n\n**Example**\n\nQuery:\n\n```sql\nSET default_table_engine = 'Log';\n\nSELECT name, value, changed FROM system.settings WHERE name = 'default_table_engine';\n```\n\nResult:\n\n```response\n┌─name─────────────────┬─value─┬─changed─┐\n│ default_table_engine │ Log   │       1 │\n└──────────────────────┴───────┴─────────┘\n```\n\nIn this example, any new table that does not specify an `Engine` will use the `Log` table engine:\n\nQuery:\n\n```sql\nCREATE TABLE my_table (\n    x UInt32,\n    y UInt32\n);\n\nSHOW CREATE TABLE my_table;\n```\n\nResult:\n\n```response\n┌─statement────────────────────────────────────────────────────────────────┐\n│ CREATE TABLE default.my_table\n(\n    `x` UInt32,\n    `y` UInt32\n)\nENGINE = Log\n└──────────────────────────────────────────────────────────────────────────┘\n```"
    },
    {
      "name": "default_temporary_table_engine",
      "type": "DefaultTableEngine",
      "description": "Same as [default_table_engine](#default_table_engine) but for temporary tables.\n\nIn this example, any new temporary table that does not specify an `Engine` will use the `Log` table engine:\n\nQuery:\n\n```sql\nSET default_temporary_table_engine = 'Log';\n\nCREATE TEMPORARY TABLE my_table (\n    x UInt32,\n    y UInt32\n);\n\nSHOW CREATE TEMPORARY TABLE my_table;\n```\n\nResult:\n\n```response\n┌─statement────────────────────────────────────────────────────────────────┐\n│ CREATE TEMPORARY TABLE default.my_table\n(\n    `x` UInt32,\n    `y` UInt32\n)\nENGINE = Log\n└──────────────────────────────────────────────────────────────────────────┘\n```"
    },
    {
      "name": "default_view_definer",
      "type": "String",
      "description": "Allows to set default `DEFINER` option while creating a view. [More about SQL security](../../sql-reference/statements/create/view.md/#sql_security).\n\nThe default value is `CURRENT_USER`."
    },
    {
      "name": "describe_compact_output",
      "type": "Bool",
      "description": "If true, include only column names and types into result of DESCRIBE query"
    },
    {
      "name": "describe_extend_object_types",
      "type": "Bool",
      "description": "Deduce concrete type of columns of type Object in DESCRIBE query"
    },
    {
      "name": "describe_include_subcolumns",
      "type": "Bool",
      "description": "Enables describing subcolumns for a [DESCRIBE](../../sql-reference/statements/describe-table.md) query. For example, members of a [Tuple](../../sql-reference/data-types/tuple.md) or subcolumns of a [Map](/sql-reference/data-types/map#reading-subcolumns-of-map), [Nullable](../../sql-reference/data-types/nullable.md/#finding-null) or an [Array](../../sql-reference/data-types/array.md/#array-size) data type.\n\nPossible values:\n\n- 0 — Subcolumns are not included in `DESCRIBE` queries.\n- 1 — Subcolumns are included in `DESCRIBE` queries.\n\n**Example**\n\nSee an example for the [DESCRIBE](../../sql-reference/statements/describe-table.md) statement."
    },
    {
      "name": "describe_include_virtual_columns",
      "type": "Bool",
      "description": "If true, virtual columns of table will be included into result of DESCRIBE query"
    },
    {
      "name": "dialect",
      "type": "Dialect",
      "description": "Which dialect will be used to parse query"
    },
    {
      "name": "dictionary_use_async_executor",
      "type": "Bool",
      "description": "Execute a pipeline for reading dictionary source in several threads. It's supported only by dictionaries with local CLICKHOUSE source."
    },
    {
      "name": "dictionary_validate_primary_key_type",
      "type": "Bool",
      "description": "Validate primary key type for dictionaries. By default id type for simple layouts will be implicitly converted to UInt64."
    },
    {
      "name": "distinct_overflow_mode",
      "type": "OverflowMode",
      "description": "Sets what happens when the amount of data exceeds one of the limits.\n\nPossible values:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result, as if the\nsource data ran out."
    },
    {
      "name": "distributed_aggregation_memory_efficient",
      "type": "Bool",
      "description": "Is the memory-saving mode of distributed aggregation enabled."
    },
    {
      "name": "distributed_background_insert_batch",
      "type": "Bool",
      "description": "Enables/disables inserted data sending in batches.\n\nWhen batch sending is enabled, the [Distributed](../../engines/table-engines/special/distributed.md) table engine tries to send multiple files of inserted data in one operation instead of sending them separately. Batch sending improves cluster performance by better-utilizing server and network resources.\n\nPossible values:\n\n- 1 — Enabled.\n- 0 — Disabled."
    },
    {
      "name": "distributed_background_insert_max_sleep_time_ms",
      "type": "Milliseconds",
      "description": "Maximum interval for the [Distributed](../../engines/table-engines/special/distributed.md) table engine to send data. Limits exponential growth of the interval set in the [distributed_background_insert_sleep_time_ms](#distributed_background_insert_sleep_time_ms) setting.\n\nPossible values:\n\n- A positive integer number of milliseconds."
    },
    {
      "name": "distributed_background_insert_sleep_time_ms",
      "type": "Milliseconds",
      "description": "Base interval for the [Distributed](../../engines/table-engines/special/distributed.md) table engine to send data. The actual interval grows exponentially in the event of errors.\n\nPossible values:\n\n- A positive integer number of milliseconds."
    },
    {
      "name": "distributed_background_insert_split_batch_on_failure",
      "type": "Bool",
      "description": "Enables/disables splitting batches on failures.\n\nSometimes sending particular batch to the remote shard may fail, because of some complex pipeline after (i.e. `MATERIALIZED VIEW` with `GROUP BY`) due to `Memory limit exceeded` or similar errors. In this case, retrying will not help (and this will stuck distributed sends for the table) but sending files from that batch one by one may succeed INSERT.\n\nSo installing this setting to `1` will disable batching for such batches (i.e. temporary disables `distributed_background_insert_batch` for failed batches).\n\nPossible values:\n\n- 1 — Enabled.\n- 0 — Disabled.\n\n:::note\nThis setting also affects broken batches (that may appears because of abnormal server (machine) termination and no `fsync_after_insert`/`fsync_directories` for [Distributed](../../engines/table-engines/special/distributed.md) table engine).\n:::\n\n:::note\nYou should not rely on automatic batch splitting, since this may hurt performance.\n:::"
    },
    {
      "name": "distributed_background_insert_timeout",
      "type": "UInt64",
      "description": "Timeout for insert query into distributed. Setting is used only with insert_distributed_sync enabled. Zero value means no timeout."
    },
    {
      "name": "distributed_cache_bypass_connection_pool",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Allow to bypass distributed cache connection pool"
    },
    {
      "name": "distributed_cache_connect_max_tries",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Number of tries to connect to distributed cache if unsuccessful"
    },
    {
      "name": "distributed_cache_credentials_refresh_period_seconds",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. A period of credentials refresh."
    },
    {
      "name": "distributed_cache_data_packet_ack_window",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. A window for sending ACK for DataPacket sequence in a single distributed cache read request"
    },
    {
      "name": "distributed_cache_discard_connection_if_unread_data",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Discard connection if some data is unread."
    },
    {
      "name": "distributed_cache_fetch_metrics_only_from_current_az",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Fetch metrics only from current availability zone in system.distributed_cache_metrics, system.distributed_cache_events"
    },
    {
      "name": "distributed_cache_log_mode",
      "type": "DistributedCacheLogMode",
      "description": "Only has an effect in ClickHouse Cloud. Mode for writing to system.distributed_cache_log"
    },
    {
      "name": "distributed_cache_max_unacked_inflight_packets",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. A maximum number of unacknowledged in-flight packets in a single distributed cache read request"
    },
    {
      "name": "distributed_cache_min_bytes_for_seek",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Minimum number of bytes to do seek in distributed cache."
    },
    {
      "name": "distributed_cache_pool_behaviour_on_limit",
      "type": "DistributedCachePoolBehaviourOnLimit",
      "description": "Only has an effect in ClickHouse Cloud. Identifies behaviour of distributed cache connection on pool limit reached"
    },
    {
      "name": "distributed_cache_read_alignment",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. A setting for testing purposes, do not change it"
    },
    {
      "name": "distributed_cache_read_only_from_current_az",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Allow to read only from current availability zone. If disabled, will read from all cache servers in all availability zones."
    },
    {
      "name": "distributed_cache_read_request_max_tries",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Number of tries to do distributed cache request if unsuccessful"
    },
    {
      "name": "distributed_cache_receive_response_wait_milliseconds",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Wait time in milliseconds to receive data for request from distributed cache"
    },
    {
      "name": "distributed_cache_receive_timeout_milliseconds",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Wait time in milliseconds to receive any kind of response from distributed cache"
    },
    {
      "name": "distributed_cache_throw_on_error",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Rethrow exception happened during communication with distributed cache or exception received from distributed cache. Otherwise fallback to skipping distributed cache on error"
    },
    {
      "name": "distributed_cache_wait_connection_from_pool_milliseconds",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Wait time in milliseconds to receive connection from connection pool if distributed_cache_pool_behaviour_on_limit is wait"
    },
    {
      "name": "distributed_connections_pool_size",
      "type": "UInt64",
      "description": "The maximum number of simultaneous connections with remote servers for distributed processing of all queries to a single Distributed table. We recommend setting a value no less than the number of servers in the cluster."
    },
    {
      "name": "distributed_ddl_entry_format_version",
      "type": "UInt64",
      "description": "Compatibility version of distributed DDL (ON CLUSTER) queries"
    },
    {
      "name": "distributed_ddl_output_mode",
      "type": "DistributedDDLOutputMode",
      "description": "Sets format of distributed DDL query result.\n\nPossible values:\n\n- `throw` — Returns result set with query execution status for all hosts where query is finished. If query has failed on some hosts, then it will rethrow the first exception. If query is not finished yet on some hosts and [distributed_ddl_task_timeout](#distributed_ddl_task_timeout) exceeded, then it throws `TIMEOUT_EXCEEDED` exception.\n- `none` — Is similar to throw, but distributed DDL query returns no result set.\n- `null_status_on_timeout` — Returns `NULL` as execution status in some rows of result set instead of throwing `TIMEOUT_EXCEEDED` if query is not finished on the corresponding hosts.\n- `never_throw` — Do not throw `TIMEOUT_EXCEEDED` and do not rethrow exceptions if query has failed on some hosts.\n- `none_only_active` - similar to `none`, but doesn't wait for inactive replicas of the `Replicated` database. Note: with this mode it's impossible to figure out that the query was not executed on some replica and will be executed in background.\n- `null_status_on_timeout_only_active` — similar to `null_status_on_timeout`, but doesn't wait for inactive replicas of the `Replicated` database\n- `throw_only_active` — similar to `throw`, but doesn't wait for inactive replicas of the `Replicated` database\n\nCloud default value: `none`."
    },
    {
      "name": "distributed_ddl_task_timeout",
      "type": "Int64",
      "description": "Sets timeout for DDL query responses from all hosts in cluster. If a DDL request has not been performed on all hosts, a response will contain a timeout error and a request will be executed in an async mode. Negative value means infinite.\n\nPossible values:\n\n- Positive integer.\n- 0 — Async mode.\n- Negative integer — infinite timeout."
    },
    {
      "name": "distributed_directory_monitor_batch_inserts",
      "type": "Bool",
      "description": "Enables/disables inserted data sending in batches.\n\nWhen batch sending is enabled, the [Distributed](../../engines/table-engines/special/distributed.md) table engine tries to send multiple files of inserted data in one operation instead of sending them separately. Batch sending improves cluster performance by better-utilizing server and network resources.\n\nPossible values:\n\n- 1 — Enabled.\n- 0 — Disabled."
    },
    {
      "name": "distributed_directory_monitor_max_sleep_time_ms",
      "type": "Milliseconds",
      "description": "Maximum interval for the [Distributed](../../engines/table-engines/special/distributed.md) table engine to send data. Limits exponential growth of the interval set in the [distributed_background_insert_sleep_time_ms](#distributed_background_insert_sleep_time_ms) setting.\n\nPossible values:\n\n- A positive integer number of milliseconds."
    },
    {
      "name": "distributed_directory_monitor_sleep_time_ms",
      "type": "Milliseconds",
      "description": "Base interval for the [Distributed](../../engines/table-engines/special/distributed.md) table engine to send data. The actual interval grows exponentially in the event of errors.\n\nPossible values:\n\n- A positive integer number of milliseconds."
    },
    {
      "name": "distributed_directory_monitor_split_batch_on_failure",
      "type": "Bool",
      "description": "Enables/disables splitting batches on failures.\n\nSometimes sending particular batch to the remote shard may fail, because of some complex pipeline after (i.e. `MATERIALIZED VIEW` with `GROUP BY`) due to `Memory limit exceeded` or similar errors. In this case, retrying will not help (and this will stuck distributed sends for the table) but sending files from that batch one by one may succeed INSERT.\n\nSo installing this setting to `1` will disable batching for such batches (i.e. temporary disables `distributed_background_insert_batch` for failed batches).\n\nPossible values:\n\n- 1 — Enabled.\n- 0 — Disabled.\n\n:::note\nThis setting also affects broken batches (that may appears because of abnormal server (machine) termination and no `fsync_after_insert`/`fsync_directories` for [Distributed](../../engines/table-engines/special/distributed.md) table engine).\n:::\n\n:::note\nYou should not rely on automatic batch splitting, since this may hurt performance.\n:::"
    },
    {
      "name": "distributed_foreground_insert",
      "type": "Bool",
      "description": "Enables or disables synchronous data insertion into a [Distributed](/engines/table-engines/special/distributed) table.\n\nBy default, when inserting data into a `Distributed` table, the ClickHouse server sends data to cluster nodes in background mode. When `distributed_foreground_insert=1`, the data is processed synchronously, and the `INSERT` operation succeeds only after all the data is saved on all shards (at least one replica for each shard if `internal_replication` is true).\n\nPossible values:\n\n- 0 — Data is inserted in background mode.\n- 1 — Data is inserted in synchronous mode.\n\nCloud default value: `1`.\n\n**See Also**\n\n- [Distributed Table Engine](/engines/table-engines/special/distributed)\n- [Managing Distributed Tables](/sql-reference/statements/system#managing-distributed-tables)"
    },
    {
      "name": "distributed_group_by_no_merge",
      "type": "UInt64",
      "description": "Do not merge aggregation states from different servers for distributed query processing, you can use this in case it is for certain that there are different keys on different shards\n\nPossible values:\n\n- `0` — Disabled (final query processing is done on the initiator node).\n- `1` - Do not merge aggregation states from different servers for distributed query processing (query completely processed on the shard, initiator only proxy the data), can be used in case it is for certain that there are different keys on different shards.\n- `2` - Same as `1` but applies `ORDER BY` and `LIMIT` (it is not possible when the query processed completely on the remote node, like for `distributed_group_by_no_merge=1`) on the initiator (can be used for queries with `ORDER BY` and/or `LIMIT`).\n\n**Example**\n\n```sql\nSELECT *\nFROM remote('127.0.0.{2,3}', system.one)\nGROUP BY dummy\nLIMIT 1\nSETTINGS distributed_group_by_no_merge = 1\nFORMAT PrettyCompactMonoBlock\n\n┌─dummy─┐\n│     0 │\n│     0 │\n└───────┘\n```\n\n```sql\nSELECT *\nFROM remote('127.0.0.{2,3}', system.one)\nGROUP BY dummy\nLIMIT 1\nSETTINGS distributed_group_by_no_merge = 2\nFORMAT PrettyCompactMonoBlock\n\n┌─dummy─┐\n│     0 │\n└───────┘\n```"
    },
    {
      "name": "distributed_insert_skip_read_only_replicas",
      "type": "Bool",
      "description": "Enables skipping read-only replicas for INSERT queries into Distributed.\n\nPossible values:\n\n- 0 — INSERT was as usual, if it will go to read-only replica it will fail\n- 1 — Initiator will skip read-only replicas before sending data to shards."
    },
    {
      "name": "distributed_plan_default_reader_bucket_count",
      "type": "UInt64",
      "description": "Default number of tasks for parallel reading in distributed query. Tasks are spread across between replicas."
    },
    {
      "name": "distributed_plan_default_shuffle_join_bucket_count",
      "type": "UInt64",
      "description": "Default number of buckets for distributed shuffle-hash-join."
    },
    {
      "name": "distributed_plan_execute_locally",
      "type": "Bool",
      "description": "Run all tasks of a distributed query plan locally. Useful for testing and debugging."
    },
    {
      "name": "distributed_plan_force_exchange_kind",
      "type": "String",
      "description": "Force specified kind of Exchange operators between distributed query stages.\n\nPossible values:\n\n - '' - do not force any kind of Exchange operators, let the optimizer choose,\n - 'Persisted' - use temporary files in object storage,\n - 'Streaming' - stream exchange data over network."
    },
    {
      "name": "distributed_plan_optimize_exchanges",
      "type": "Bool",
      "description": "Removes unnecessary exchanges in distributed query plan. Disable it for debugging."
    },
    {
      "name": "distributed_product_mode",
      "type": "DistributedProductMode",
      "description": "Changes the behaviour of [distributed subqueries](../../sql-reference/operators/in.md).\n\nClickHouse applies this setting when the query contains the product of distributed tables, i.e. when the query for a distributed table contains a non-GLOBAL subquery for the distributed table.\n\nRestrictions:\n\n- Only applied for IN and JOIN subqueries.\n- Only if the FROM section uses a distributed table containing more than one shard.\n- If the subquery concerns a distributed table containing more than one shard.\n- Not used for a table-valued [remote](../../sql-reference/table-functions/remote.md) function.\n\nPossible values:\n\n- `deny` — Default value. Prohibits using these types of subqueries (returns the \"Double-distributed in/JOIN subqueries is denied\" exception).\n- `local` — Replaces the database and table in the subquery with local ones for the destination server (shard), leaving the normal `IN`/`JOIN.`\n- `global` — Replaces the `IN`/`JOIN` query with `GLOBAL IN`/`GLOBAL JOIN.`\n- `allow` — Allows the use of these types of subqueries."
    },
    {
      "name": "distributed_push_down_limit",
      "type": "UInt64",
      "description": "Enables or disables [LIMIT](#limit) applying on each shard separately.\n\nThis will allow to avoid:\n- Sending extra rows over network;\n- Processing rows behind the limit on the initiator.\n\nStarting from 21.9 version you cannot get inaccurate results anymore, since `distributed_push_down_limit` changes query execution only if at least one of the conditions met:\n- [distributed_group_by_no_merge](#distributed_group_by_no_merge) > 0.\n- Query **does not have** `GROUP BY`/`DISTINCT`/`LIMIT BY`, but it has `ORDER BY`/`LIMIT`.\n- Query **has** `GROUP BY`/`DISTINCT`/`LIMIT BY` with `ORDER BY`/`LIMIT` and:\n    - [optimize_skip_unused_shards](#optimize_skip_unused_shards) is enabled.\n    - [optimize_distributed_group_by_sharding_key](#optimize_distributed_group_by_sharding_key) is enabled.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nSee also:\n\n- [distributed_group_by_no_merge](#distributed_group_by_no_merge)\n- [optimize_skip_unused_shards](#optimize_skip_unused_shards)\n- [optimize_distributed_group_by_sharding_key](#optimize_distributed_group_by_sharding_key)"
    },
    {
      "name": "distributed_replica_error_cap",
      "type": "UInt64",
      "description": "- Type: unsigned int\n- Default value: 1000\n\nThe error count of each replica is capped at this value, preventing a single replica from accumulating too many errors.\n\nSee also:\n\n- [load_balancing](#load_balancing-round_robin)\n- [Table engine Distributed](../../engines/table-engines/special/distributed.md)\n- [distributed_replica_error_half_life](#distributed_replica_error_half_life)\n- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)"
    },
    {
      "name": "distributed_replica_error_half_life",
      "type": "Seconds",
      "description": "- Type: seconds\n- Default value: 60 seconds\n\nControls how fast errors in distributed tables are zeroed. If a replica is unavailable for some time, accumulates 5 errors, and distributed_replica_error_half_life is set to 1 second, then the replica is considered normal 3 seconds after the last error.\n\nSee also:\n\n- [load_balancing](#load_balancing-round_robin)\n- [Table engine Distributed](../../engines/table-engines/special/distributed.md)\n- [distributed_replica_error_cap](#distributed_replica_error_cap)\n- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)"
    },
    {
      "name": "distributed_replica_max_ignored_errors",
      "type": "UInt64",
      "description": "- Type: unsigned int\n- Default value: 0\n\nThe number of errors that will be ignored while choosing replicas (according to `load_balancing` algorithm).\n\nSee also:\n\n- [load_balancing](#load_balancing-round_robin)\n- [Table engine Distributed](../../engines/table-engines/special/distributed.md)\n- [distributed_replica_error_cap](#distributed_replica_error_cap)\n- [distributed_replica_error_half_life](#distributed_replica_error_half_life)"
    },
    {
      "name": "do_not_merge_across_partitions_select_final",
      "type": "Bool",
      "description": "Merge parts only in one partition in select final"
    },
    {
      "name": "drain_timeout",
      "type": "Seconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "empty_result_for_aggregation_by_constant_keys_on_empty_set",
      "type": "Bool",
      "description": "Return empty result when aggregating by constant keys on empty set."
    },
    {
      "name": "empty_result_for_aggregation_by_empty_set",
      "type": "Bool",
      "description": "Return empty result when aggregating without keys on empty set."
    },
    {
      "name": "enable_adaptive_memory_spill_scheduler",
      "type": "Bool",
      "description": "Trigger processor to spill data into external storage adpatively. grace join is supported at present."
    },
    {
      "name": "enable_analyzer",
      "type": "Bool",
      "description": "Allow new query analyzer."
    },
    {
      "name": "enable_blob_storage_log",
      "type": "Bool",
      "description": "Write information about blob storage operations to system.blob_storage_log table"
    },
    {
      "name": "enable_debug_queries",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "enable_deflate_qpl_codec",
      "type": "Bool",
      "description": "If turned on, the DEFLATE_QPL codec may be used to compress columns."
    },
    {
      "name": "enable_dynamic_type",
      "type": "Bool",
      "description": "Allows creation of [Dynamic](../../sql-reference/data-types/dynamic.md) data type."
    },
    {
      "name": "enable_early_constant_folding",
      "type": "Bool",
      "description": "Enable query optimization where we analyze function and subqueries results and rewrite query if there are constants there"
    },
    {
      "name": "enable_extended_results_for_datetime_functions",
      "type": "Bool",
      "description": "Enables or disables returning results of type `Date32` with extended range (compared to type `Date`)\nor `DateTime64` with extended range (compared to type `DateTime`).\n\nPossible values:\n\n- `0` — Functions return `Date` or `DateTime` for all types of arguments.\n- `1` — Functions return `Date32` or `DateTime64` for `Date32` or `DateTime64` arguments and `Date` or `DateTime` otherwise.\n\nThe table below shows the behavior of this setting for various date-time functions.\n\n| Function | `enable_extended_results_for_datetime_functions = 0` | `enable_extended_results_for_datetime_functions = 1` |\n|----------|---------------------------------------------------|---------------------------------------------------|\n| `toStartOfYear` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfISOYear` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfQuarter` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfMonth` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfWeek` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toLastDayOfWeek` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toLastDayOfMonth` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toMonday` | Returns `Date` or `DateTime` | Returns `Date`/`DateTime` for `Date`/`DateTime` input<br/>Returns `Date32`/`DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfDay` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfHour` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfFifteenMinutes` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfTenMinutes` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfFiveMinutes` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |\n| `toStartOfMinute` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |\n| `timeSlot` | Returns `DateTime`<br/>*Note: Wrong results for values outside 1970-2149 range* | Returns `DateTime` for `Date`/`DateTime` input<br/>Returns `DateTime64` for `Date32`/`DateTime64` input |"
    },
    {
      "name": "enable_filesystem_cache",
      "type": "Bool",
      "description": "Use cache for remote filesystem. This setting does not turn on/off cache for disks (must be done via disk config), but allows to bypass cache for some queries if intended"
    },
    {
      "name": "enable_filesystem_cache_log",
      "type": "Bool",
      "description": "Allows to record the filesystem caching log for each query"
    },
    {
      "name": "enable_filesystem_cache_on_write_operations",
      "type": "Bool",
      "description": "Write into cache on write operations. To actually work this setting requires be added to disk config too"
    },
    {
      "name": "enable_filesystem_read_prefetches_log",
      "type": "Bool",
      "description": "Log to system.filesystem prefetch_log during query. Should be used only for testing or debugging, not recommended to be turned on by default"
    },
    {
      "name": "enable_global_with_statement",
      "type": "Bool",
      "description": "Propagate WITH statements to UNION queries and all subqueries"
    },
    {
      "name": "enable_hdfs_pread",
      "type": "Bool",
      "description": "Enable or disables pread for HDFS files. By default, `hdfsPread` is used. If disabled, `hdfsRead` and `hdfsSeek` will be used to read hdfs files."
    },
    {
      "name": "enable_http_compression",
      "type": "Bool",
      "description": "Enables or disables data compression in the response to an HTTP request.\n\nFor more information, read the [HTTP interface description](../../interfaces/http.md).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "enable_job_stack_trace",
      "type": "Bool",
      "description": "Output stack trace of a job creator when job results in exception. Disabled by default to avoid performance overhead."
    },
    {
      "name": "enable_json_type",
      "type": "Bool",
      "description": "Allows creation of [JSON](../../sql-reference/data-types/newjson.md) data type."
    },
    {
      "name": "enable_lightweight_delete",
      "type": "Bool",
      "description": "Enable lightweight DELETE mutations for mergetree tables."
    },
    {
      "name": "enable_memory_bound_merging_of_aggregation_results",
      "type": "Bool",
      "description": "Enable memory bound merging strategy for aggregation."
    },
    {
      "name": "enable_multiple_prewhere_read_steps",
      "type": "Bool",
      "description": "Move more conditions from WHERE to PREWHERE and do reads from disk and filtering in multiple steps if there are multiple conditions combined with AND"
    },
    {
      "name": "enable_named_columns_in_function_tuple",
      "type": "Bool",
      "description": "Generate named tuples in function tuple() when all names are unique and can be treated as unquoted identifiers."
    },
    {
      "name": "enable_optimize_predicate_expression",
      "type": "Bool",
      "description": "Turns on predicate pushdown in `SELECT` queries.\n\nPredicate pushdown may significantly reduce network traffic for distributed queries.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nUsage\n\nConsider the following queries:\n\n1.  `SELECT count() FROM test_table WHERE date = '2018-10-10'`\n2.  `SELECT count() FROM (SELECT * FROM test_table) WHERE date = '2018-10-10'`\n\nIf `enable_optimize_predicate_expression = 1`, then the execution time of these queries is equal because ClickHouse applies `WHERE` to the subquery when processing it.\n\nIf `enable_optimize_predicate_expression = 0`, then the execution time of the second query is much longer because the `WHERE` clause applies to all the data after the subquery finishes."
    },
    {
      "name": "enable_optimize_predicate_expression_to_final_subquery",
      "type": "Bool",
      "description": "Allow push predicate to final subquery."
    },
    {
      "name": "enable_order_by_all",
      "type": "Bool",
      "description": "Enables or disables sorting with `ORDER BY ALL` syntax, see [ORDER BY](../../sql-reference/statements/select/order-by.md).\n\nPossible values:\n\n- 0 — Disable ORDER BY ALL.\n- 1 — Enable ORDER BY ALL.\n\n**Example**\n\nQuery:\n\n```sql\nCREATE TABLE TAB(C1 Int, C2 Int, ALL Int) ENGINE=Memory();\n\nINSERT INTO TAB VALUES (10, 20, 30), (20, 20, 10), (30, 10, 20);\n\nSELECT * FROM TAB ORDER BY ALL; -- returns an error that ALL is ambiguous\n\nSELECT * FROM TAB ORDER BY ALL SETTINGS enable_order_by_all = 0;\n```\n\nResult:\n\n```text\n┌─C1─┬─C2─┬─ALL─┐\n│ 20 │ 20 │  10 │\n│ 30 │ 10 │  20 │\n│ 10 │ 20 │  30 │\n└────┴────┴─────┘\n```"
    },
    {
      "name": "enable_parallel_blocks_marshalling",
      "type": "Bool",
      "description": "Affects only distributed queries. If enabled, blocks will be (de)serialized and (de)compressed on pipeline threads (i.e. with higher parallelism that what we have by default) before/after sending to the initiator."
    },
    {
      "name": "enable_parallel_replicas",
      "type": "UInt64",
      "description": "Use up to `max_parallel_replicas` the number of replicas from each shard for SELECT query execution. Reading is parallelized and coordinated dynamically. 0 - disabled, 1 - enabled, silently disable them in case of failure, 2 - enabled, throw an exception in case of failure"
    },
    {
      "name": "enable_parsing_to_custom_serialization",
      "type": "Bool",
      "description": "If true then data can be parsed directly to columns with custom serialization (e.g. Sparse) according to hints for serialization got from the table."
    },
    {
      "name": "enable_positional_arguments",
      "type": "Bool",
      "description": "Enables or disables supporting positional arguments for [GROUP BY](/sql-reference/statements/select/group-by), [LIMIT BY](../../sql-reference/statements/select/limit-by.md), [ORDER BY](../../sql-reference/statements/select/order-by.md) statements.\n\nPossible values:\n\n- 0 — Positional arguments aren't supported.\n- 1 — Positional arguments are supported: column numbers can use instead of column names.\n\n**Example**\n\nQuery:\n\n```sql\nCREATE TABLE positional_arguments(one Int, two Int, three Int) ENGINE=Memory();\n\nINSERT INTO positional_arguments VALUES (10, 20, 30), (20, 20, 10), (30, 10, 20);\n\nSELECT * FROM positional_arguments ORDER BY 2,3;\n```\n\nResult:\n\n```text\n┌─one─┬─two─┬─three─┐\n│  30 │  10 │   20  │\n│  20 │  20 │   10  │\n│  10 │  20 │   30  │\n└─────┴─────┴───────┘\n```"
    },
    {
      "name": "enable_reads_from_query_cache",
      "type": "Bool",
      "description": "If turned on, results of `SELECT` queries are retrieved from the [query cache](../query-cache.md).\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "enable_s3_requests_logging",
      "type": "Bool",
      "description": "Enable very explicit logging of S3 requests. Makes sense for debug only."
    },
    {
      "name": "enable_scalar_subquery_optimization",
      "type": "Bool",
      "description": "If it is set to true, prevent scalar subqueries from (de)serializing large scalar values and possibly avoid running the same subquery more than once."
    },
    {
      "name": "enable_scopes_for_with_statement",
      "type": "Bool",
      "description": "If disabled, declarations in parent WITH cluases will behave the same scope as they declared in the current scope.\n\nNote that this is a compatibility setting for new analyzer to allow running some invalid queries that old analyzer could execute."
    },
    {
      "name": "enable_shared_storage_snapshot_in_query",
      "type": "Bool",
      "description": "If enabled, all subqueries within a single query will share the same StorageSnapshot for each table.\nThis ensures a consistent view of the data across the entire query, even if the same table is accessed multiple times.\n\nThis is required for queries where internal consistency of data parts is important. Example:\n\n```sql\nSELECT\n    count()\nFROM events\nWHERE (_part, _part_offset) IN (\n    SELECT _part, _part_offset\n    FROM events\n    WHERE user_id = 42\n)\n```\n\nWithout this setting, the outer and inner queries may operate on different data snapshots, leading to incorrect results.\n\n:::note\nEnabling this setting disables the optimization which removes unnecessary data parts from snapshots once the planning stage is complete.\nAs a result, long-running queries may hold onto obsolete parts for their entire duration, delaying part cleanup and increasing storage pressure.\n\nThis setting currently applies only to tables from the MergeTree family.\n:::\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "enable_sharing_sets_for_mutations",
      "type": "Bool",
      "description": "Allow sharing set objects build for IN subqueries between different tasks of the same mutation. This reduces memory usage and CPU consumption"
    },
    {
      "name": "enable_software_prefetch_in_aggregation",
      "type": "Bool",
      "description": "Enable use of software prefetch in aggregation"
    },
    {
      "name": "enable_time_time64_type",
      "type": "Bool",
      "description": "Allows creation of [Time](../../sql-reference/data-types/time.md) and [Time64](../../sql-reference/data-types/time64.md) data types."
    },
    {
      "name": "enable_unaligned_array_join",
      "type": "Bool",
      "description": "Allow ARRAY JOIN with multiple arrays that have different sizes. When this settings is enabled, arrays will be resized to the longest one."
    },
    {
      "name": "enable_url_encoding",
      "type": "Bool",
      "description": "Allows to enable/disable decoding/encoding path in uri in [URL](../../engines/table-engines/special/url.md) engine tables.\n\nDisabled by default."
    },
    {
      "name": "enable_variant_type",
      "type": "Bool",
      "description": "Allows creation of [Variant](../../sql-reference/data-types/variant.md) data type."
    },
    {
      "name": "enable_vertical_final",
      "type": "Bool",
      "description": "If enable, remove duplicated rows during FINAL by marking rows as deleted and filtering them later instead of merging rows"
    },
    {
      "name": "enable_writes_to_query_cache",
      "type": "Bool",
      "description": "If turned on, results of `SELECT` queries are stored in the [query cache](../query-cache.md).\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "enable_zstd_qat_codec",
      "type": "Bool",
      "description": "If turned on, the ZSTD_QAT codec may be used to compress columns."
    },
    {
      "name": "enforce_strict_identifier_format",
      "type": "Bool",
      "description": "If enabled, only allow identifiers containing alphanumeric characters and underscores."
    },
    {
      "name": "engine_file_allow_create_multiple_files",
      "type": "Bool",
      "description": "Enables or disables creating a new file on each insert in file engine tables if the format has the suffix (`JSON`, `ORC`, `Parquet`, etc.). If enabled, on each insert a new file will be created with a name following this pattern:\n\n`data.Parquet` -> `data.1.Parquet` -> `data.2.Parquet`, etc.\n\nPossible values:\n- 0 — `INSERT` query appends new data to the end of the file.\n- 1 — `INSERT` query creates a new file."
    },
    {
      "name": "engine_file_empty_if_not_exists",
      "type": "Bool",
      "description": "Allows to select data from a file engine table without file.\n\nPossible values:\n- 0 — `SELECT` throws exception.\n- 1 — `SELECT` returns empty result."
    },
    {
      "name": "engine_file_skip_empty_files",
      "type": "Bool",
      "description": "Enables or disables skipping empty files in [File](../../engines/table-engines/special/file.md) engine tables.\n\nPossible values:\n- 0 — `SELECT` throws an exception if empty file is not compatible with requested format.\n- 1 — `SELECT` returns empty result for empty file."
    },
    {
      "name": "engine_file_truncate_on_insert",
      "type": "Bool",
      "description": "Enables or disables truncate before insert in [File](../../engines/table-engines/special/file.md) engine tables.\n\nPossible values:\n- 0 — `INSERT` query appends new data to the end of the file.\n- 1 — `INSERT` query replaces existing content of the file with the new data."
    },
    {
      "name": "engine_url_skip_empty_files",
      "type": "Bool",
      "description": "Enables or disables skipping empty files in [URL](../../engines/table-engines/special/url.md) engine tables.\n\nPossible values:\n- 0 — `SELECT` throws an exception if empty file is not compatible with requested format.\n- 1 — `SELECT` returns empty result for empty file."
    },
    {
      "name": "errors_output_format",
      "type": "String",
      "description": "Method to write Errors to text output."
    },
    {
      "name": "exact_rows_before_limit",
      "type": "Bool",
      "description": "When enabled, ClickHouse will provide exact value for rows_before_limit_at_least statistic, but with the cost that the data before limit will have to be read completely"
    },
    {
      "name": "except_default_mode",
      "type": "SetOperationMode",
      "description": "Set default mode in EXCEPT query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception."
    },
    {
      "name": "external_storage_connect_timeout_sec",
      "type": "UInt64",
      "description": "Connect timeout in seconds. Now supported only for MySQL"
    },
    {
      "name": "external_storage_max_read_bytes",
      "type": "UInt64",
      "description": "Limit maximum number of bytes when table with external engine should flush history data. Now supported only for MySQL table engine, database engine, and dictionary. If equal to 0, this setting is disabled"
    },
    {
      "name": "external_storage_max_read_rows",
      "type": "UInt64",
      "description": "Limit maximum number of rows when table with external engine should flush history data. Now supported only for MySQL table engine, database engine, and dictionary. If equal to 0, this setting is disabled"
    },
    {
      "name": "external_storage_rw_timeout_sec",
      "type": "UInt64",
      "description": "Read/write timeout in seconds. Now supported only for MySQL"
    },
    {
      "name": "external_table_functions_use_nulls",
      "type": "Bool",
      "description": "Defines how [mysql](../../sql-reference/table-functions/mysql.md), [postgresql](../../sql-reference/table-functions/postgresql.md) and [odbc](../../sql-reference/table-functions/odbc.md) table functions use Nullable columns.\n\nPossible values:\n\n- 0 — The table function explicitly uses Nullable columns.\n- 1 — The table function implicitly uses Nullable columns.\n\n**Usage**\n\nIf the setting is set to `0`, the table function does not make Nullable columns and inserts default values instead of NULL. This is also applicable for NULL values inside arrays."
    },
    {
      "name": "external_table_strict_query",
      "type": "Bool",
      "description": "If it is set to true, transforming expression to local filter is forbidden for queries to external tables."
    },
    {
      "name": "extract_key_value_pairs_max_pairs_per_row",
      "type": "UInt64",
      "description": "Max number of pairs that can be produced by the `extractKeyValuePairs` function. Used as a safeguard against consuming too much memory."
    },
    {
      "name": "extract_kvp_max_pairs_per_row",
      "type": "UInt64",
      "description": "Max number of pairs that can be produced by the `extractKeyValuePairs` function. Used as a safeguard against consuming too much memory."
    },
    {
      "name": "extremes",
      "type": "Bool",
      "description": "Whether to count extreme values (the minimums and maximums in columns of a query result). Accepts 0 or 1. By default, 0 (disabled).\nFor more information, see the section \"Extreme values\"."
    },
    {
      "name": "fallback_to_stale_replicas_for_distributed_queries",
      "type": "Bool",
      "description": "Forces a query to an out-of-date replica if updated data is not available. See [Replication](../../engines/table-engines/mergetree-family/replication.md).\n\nClickHouse selects the most relevant from the outdated replicas of the table.\n\nUsed when performing `SELECT` from a distributed table that points to replicated tables.\n\nBy default, 1 (enabled)."
    },
    {
      "name": "filesystem_cache_boundary_alignment",
      "type": "UInt64",
      "description": "Filesystem cache boundary alignment. This setting is applied only for non-disk read (e.g. for cache of remote table engines / table functions, but not for storage configuration of MergeTree tables). Value 0 means no alignment."
    },
    {
      "name": "filesystem_cache_enable_background_download_during_fetch",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Wait time to lock cache for space reservation in filesystem cache"
    },
    {
      "name": "filesystem_cache_enable_background_download_for_metadata_files_in_packed_storage",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Wait time to lock cache for space reservation in filesystem cache"
    },
    {
      "name": "filesystem_cache_max_download_size",
      "type": "UInt64",
      "description": "Max remote filesystem cache size that can be downloaded by a single query"
    },
    {
      "name": "filesystem_cache_name",
      "type": "String",
      "description": "Filesystem cache name to use for stateless table engines or data lakes"
    },
    {
      "name": "filesystem_cache_prefer_bigger_buffer_size",
      "type": "Bool",
      "description": "Prefer bigger buffer size if filesystem cache is enabled to avoid writing small file segments which deteriorate cache performance. On the other hand, enabling this setting might increase memory usage."
    },
    {
      "name": "filesystem_cache_reserve_space_wait_lock_timeout_milliseconds",
      "type": "UInt64",
      "description": "Wait time to lock cache for space reservation in filesystem cache"
    },
    {
      "name": "filesystem_cache_segments_batch_size",
      "type": "UInt64",
      "description": "Limit on size of a single batch of file segments that a read buffer can request from cache. Too low value will lead to excessive requests to cache, too large may slow down eviction from cache"
    },
    {
      "name": "filesystem_cache_skip_download_if_exceeds_per_query_cache_write_limit",
      "type": "Bool",
      "description": "Skip download from remote filesystem if exceeds query cache size"
    },
    {
      "name": "filesystem_prefetch_max_memory_usage",
      "type": "NonZeroUInt64",
      "description": "Maximum memory usage for prefetches."
    },
    {
      "name": "filesystem_prefetch_min_bytes_for_single_read_task",
      "type": "UInt64",
      "description": "Min bytes to read per task."
    },
    {
      "name": "filesystem_prefetch_step_bytes",
      "type": "UInt64",
      "description": "Prefetch step in bytes. Zero means `auto` - approximately the best prefetch step will be auto deduced, but might not be 100% the best. The actual value might be different because of setting filesystem_prefetch_min_bytes_for_single_read_task"
    },
    {
      "name": "filesystem_prefetch_step_marks",
      "type": "UInt64",
      "description": "Prefetch step in marks. Zero means `auto` - approximately the best prefetch step will be auto deduced, but might not be 100% the best. The actual value might be different because of setting filesystem_prefetch_min_bytes_for_single_read_task"
    },
    {
      "name": "filesystem_prefetches_limit",
      "type": "UInt64",
      "description": "Maximum number of prefetches. Zero means unlimited. A setting `filesystem_prefetches_max_memory_usage` is more recommended if you want to limit the number of prefetches"
    },
    {
      "name": "final",
      "type": "Bool",
      "description": "Automatically applies [FINAL](../../sql-reference/statements/select/from.md/#final-modifier) modifier to all tables in a query, to tables where [FINAL](../../sql-reference/statements/select/from.md/#final-modifier) is applicable, including joined tables and tables in sub-queries, and\ndistributed tables.\n\nPossible values:\n\n- 0 - disabled\n- 1 - enabled\n\nExample:\n\n```sql\nCREATE TABLE test\n(\n    key Int64,\n    some String\n)\nENGINE = ReplacingMergeTree\nORDER BY key;\n\nINSERT INTO test FORMAT Values (1, 'first');\nINSERT INTO test FORMAT Values (1, 'second');\n\nSELECT * FROM test;\n┌─key─┬─some───┐\n│   1 │ second │\n└─────┴────────┘\n┌─key─┬─some──┐\n│   1 │ first │\n└─────┴───────┘\n\nSELECT * FROM test SETTINGS final = 1;\n┌─key─┬─some───┐\n│   1 │ second │\n└─────┴────────┘\n\nSET final = 1;\nSELECT * FROM test;\n┌─key─┬─some───┐\n│   1 │ second │\n└─────┴────────┘\n```"
    },
    {
      "name": "flatten_nested",
      "type": "Bool",
      "description": "Sets the data format of a [nested](../../sql-reference/data-types/nested-data-structures/index.md) columns.\n\nPossible values:\n\n- 1 — Nested column is flattened to separate arrays.\n- 0 — Nested column stays a single array of tuples.\n\n**Usage**\n\nIf the setting is set to `0`, it is possible to use an arbitrary level of nesting.\n\n**Examples**\n\nQuery:\n\n```sql\nSET flatten_nested = 1;\nCREATE TABLE t_nest (`n` Nested(a UInt32, b UInt32)) ENGINE = MergeTree ORDER BY tuple();\n\nSHOW CREATE TABLE t_nest;\n```\n\nResult:\n\n```text\n┌─statement───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ CREATE TABLE default.t_nest\n(\n    `n.a` Array(UInt32),\n    `n.b` Array(UInt32)\n)\nENGINE = MergeTree\nORDER BY tuple()\nSETTINGS index_granularity = 8192 │\n└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\nQuery:\n\n```sql\nSET flatten_nested = 0;\n\nCREATE TABLE t_nest (`n` Nested(a UInt32, b UInt32)) ENGINE = MergeTree ORDER BY tuple();\n\nSHOW CREATE TABLE t_nest;\n```\n\nResult:\n\n```text\n┌─statement──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ CREATE TABLE default.t_nest\n(\n    `n` Nested(a UInt32, b UInt32)\n)\nENGINE = MergeTree\nORDER BY tuple()\nSETTINGS index_granularity = 8192 │\n└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```"
    },
    {
      "name": "force_aggregate_partitions_independently",
      "type": "Bool",
      "description": "Force the use of optimization when it is applicable, but heuristics decided not to use it"
    },
    {
      "name": "force_aggregation_in_order",
      "type": "Bool",
      "description": "The setting is used by the server itself to support distributed queries. Do not change it manually, because it will break normal operations. (Forces use of aggregation in order on remote nodes during distributed aggregation)."
    },
    {
      "name": "force_data_skipping_indices",
      "type": "String",
      "description": "Disables query execution if passed data skipping indices wasn't used.\n\nConsider the following example:\n\n```sql\nCREATE TABLE data\n(\n    key Int,\n    d1 Int,\n    d1_null Nullable(Int),\n    INDEX d1_idx d1 TYPE minmax GRANULARITY 1,\n    INDEX d1_null_idx assumeNotNull(d1_null) TYPE minmax GRANULARITY 1\n)\nEngine=MergeTree()\nORDER BY key;\n\nSELECT * FROM data_01515;\nSELECT * FROM data_01515 SETTINGS force_data_skipping_indices=''; -- query will produce CANNOT_PARSE_TEXT error.\nSELECT * FROM data_01515 SETTINGS force_data_skipping_indices='d1_idx'; -- query will produce INDEX_NOT_USED error.\nSELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='d1_idx'; -- Ok.\nSELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='`d1_idx`'; -- Ok (example of full featured parser).\nSELECT * FROM data_01515 WHERE d1 = 0 SETTINGS force_data_skipping_indices='`d1_idx`, d1_null_idx'; -- query will produce INDEX_NOT_USED error, since d1_null_idx is not used.\nSELECT * FROM data_01515 WHERE d1 = 0 AND assumeNotNull(d1_null) = 0 SETTINGS force_data_skipping_indices='`d1_idx`, d1_null_idx'; -- Ok.\n```"
    },
    {
      "name": "force_grouping_standard_compatibility",
      "type": "Bool",
      "description": "Make GROUPING function to return 1 when argument is not used as an aggregation key"
    },
    {
      "name": "force_index_by_date",
      "type": "Bool",
      "description": "Disables query execution if the index can't be used by date.\n\nWorks with tables in the MergeTree family.\n\nIf `force_index_by_date=1`, ClickHouse checks whether the query has a date key condition that can be used for restricting data ranges. If there is no suitable condition, it throws an exception. However, it does not check whether the condition reduces the amount of data to read. For example, the condition `Date != ' 2000-01-01 '` is acceptable even when it matches all the data in the table (i.e., running the query requires a full scan). For more information about ranges of data in MergeTree tables, see [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md)."
    },
    {
      "name": "force_optimize_projection",
      "type": "Bool",
      "description": "Enables or disables the obligatory use of [projections](../../engines/table-engines/mergetree-family/mergetree.md/#projections) in `SELECT` queries, when projection optimization is enabled (see [optimize_use_projections](#optimize_use_projections) setting).\n\nPossible values:\n\n- 0 — Projection optimization is not obligatory.\n- 1 — Projection optimization is obligatory."
    },
    {
      "name": "force_optimize_projection_name",
      "type": "String",
      "description": "If it is set to a non-empty string, check that this projection is used in the query at least once.\n\nPossible values:\n\n- string: name of projection that used in a query"
    },
    {
      "name": "force_optimize_skip_unused_shards",
      "type": "UInt64",
      "description": "Enables or disables query execution if [optimize_skip_unused_shards](#optimize_skip_unused_shards) is enabled and skipping of unused shards is not possible. If the skipping is not possible and the setting is enabled, an exception will be thrown.\n\nPossible values:\n\n- 0 — Disabled. ClickHouse does not throw an exception.\n- 1 — Enabled. Query execution is disabled only if the table has a sharding key.\n- 2 — Enabled. Query execution is disabled regardless of whether a sharding key is defined for the table."
    },
    {
      "name": "force_optimize_skip_unused_shards_nesting",
      "type": "UInt64",
      "description": "Controls [`force_optimize_skip_unused_shards`](#force_optimize_skip_unused_shards) (hence still requires [`force_optimize_skip_unused_shards`](#force_optimize_skip_unused_shards)) depends on the nesting level of the distributed query (case when you have `Distributed` table that look into another `Distributed` table).\n\nPossible values:\n\n- 0 - Disabled, `force_optimize_skip_unused_shards` works always.\n- 1 — Enables `force_optimize_skip_unused_shards` only for the first level.\n- 2 — Enables `force_optimize_skip_unused_shards` up to the second level."
    },
    {
      "name": "force_primary_key",
      "type": "Bool",
      "description": "Disables query execution if indexing by the primary key is not possible.\n\nWorks with tables in the MergeTree family.\n\nIf `force_primary_key=1`, ClickHouse checks to see if the query has a primary key condition that can be used for restricting data ranges. If there is no suitable condition, it throws an exception. However, it does not check whether the condition reduces the amount of data to read. For more information about data ranges in MergeTree tables, see [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md)."
    },
    {
      "name": "force_remove_data_recursively_on_drop",
      "type": "Bool",
      "description": "Recursively remove data on DROP query. Avoids 'Directory not empty' error, but may silently remove detached data"
    },
    {
      "name": "format_avro_schema_registry_url",
      "type": "URI",
      "description": "For AvroConfluent format: Confluent Schema Registry URL."
    },
    {
      "name": "format_binary_max_array_size",
      "type": "UInt64",
      "description": "The maximum allowed size for Array in RowBinary format. It prevents allocating large amount of memory in case of corrupted data. 0 means there is no limit"
    },
    {
      "name": "format_binary_max_string_size",
      "type": "UInt64",
      "description": "The maximum allowed size for String in RowBinary format. It prevents allocating large amount of memory in case of corrupted data. 0 means there is no limit"
    },
    {
      "name": "format_capn_proto_enum_comparising_mode",
      "type": "CapnProtoEnumComparingMode",
      "description": "How to map ClickHouse Enum and CapnProto Enum"
    },
    {
      "name": "format_capn_proto_use_autogenerated_schema",
      "type": "Bool",
      "description": "Use autogenerated CapnProto schema when format_schema is not set"
    },
    {
      "name": "format_csv_allow_double_quotes",
      "type": "Bool",
      "description": "If it is set to true, allow strings in double quotes."
    },
    {
      "name": "format_csv_allow_single_quotes",
      "type": "Bool",
      "description": "If it is set to true, allow strings in single quotes."
    },
    {
      "name": "format_csv_delimiter",
      "type": "Char",
      "description": "The character to be considered as a delimiter in CSV data. If setting with a string, a string has to have a length of 1."
    },
    {
      "name": "format_csv_null_representation",
      "type": "String",
      "description": "Custom NULL representation in CSV format"
    },
    {
      "name": "format_custom_escaping_rule",
      "type": "EscapingRule",
      "description": "Field escaping rule (for CustomSeparated format)"
    },
    {
      "name": "format_custom_field_delimiter",
      "type": "String",
      "description": "Delimiter between fields (for CustomSeparated format)"
    },
    {
      "name": "format_custom_result_after_delimiter",
      "type": "String",
      "description": "Suffix after result set (for CustomSeparated format)"
    },
    {
      "name": "format_custom_result_before_delimiter",
      "type": "String",
      "description": "Prefix before result set (for CustomSeparated format)"
    },
    {
      "name": "format_custom_row_after_delimiter",
      "type": "String",
      "description": "Delimiter after field of the last column (for CustomSeparated format)"
    },
    {
      "name": "format_custom_row_before_delimiter",
      "type": "String",
      "description": "Delimiter before field of the first column (for CustomSeparated format)"
    },
    {
      "name": "format_custom_row_between_delimiter",
      "type": "String",
      "description": "Delimiter between rows (for CustomSeparated format)"
    },
    {
      "name": "format_display_secrets_in_show_and_select",
      "type": "Bool",
      "description": "Enables or disables showing secrets in `SHOW` and `SELECT` queries for tables, databases,\ntable functions, and dictionaries.\n\nUser wishing to see secrets must also have\n[`display_secrets_in_show_and_select` server setting](../server-configuration-parameters/settings#display_secrets_in_show_and_select)\nturned on and a\n[`displaySecretsInShowAndSelect`](/sql-reference/statements/grant#displaysecretsinshowandselect) privilege.\n\nPossible values:\n\n-   0 — Disabled.\n-   1 — Enabled."
    },
    {
      "name": "format_json_object_each_row_column_for_object_name",
      "type": "String",
      "description": "The name of column that will be used for storing/writing object names in [JSONObjectEachRow](/interfaces/formats/JSONObjectEachRow) format.\nColumn type should be String. If value is empty, default names `row_{i}`will be used for object names."
    },
    {
      "name": "format_protobuf_use_autogenerated_schema",
      "type": "Bool",
      "description": "Use autogenerated Protobuf when format_schema is not set"
    },
    {
      "name": "format_regexp",
      "type": "String",
      "description": "Regular expression (for Regexp format)"
    },
    {
      "name": "format_regexp_escaping_rule",
      "type": "EscapingRule",
      "description": "Field escaping rule (for Regexp format)"
    },
    {
      "name": "format_regexp_skip_unmatched",
      "type": "Bool",
      "description": "Skip lines unmatched by regular expression (for Regexp format)"
    },
    {
      "name": "format_schema",
      "type": "String",
      "description": "This parameter is useful when you are using formats that require a schema definition, such as [Cap'n Proto](https://capnproto.org/) or [Protobuf](https://developers.google.com/protocol-buffers/). The value depends on the format."
    },
    {
      "name": "format_schema_message_name",
      "type": "String",
      "description": "Define the name of the required message in the schema defined in `format_schema`.\nTo maintain compatibility with the legacy format_schema format (`file_name:message_name`):\n- If `format_schema_message_name` is not specified, the message name is inferred from the `message_name` part of the legacy `format_schema` value.\n- If `format_schema_message_name` is specified while using the legacy format, an error will be raised."
    },
    {
      "name": "format_schema_source",
      "type": "String",
      "description": "Define the source of `format_schema`.\nPossible values:\n- 'file' (default):: The `format_schema` is the name of a schema file located in the `format_schemas` directory.\n- 'string': The `format_schema` is the literal content of the schema.\n- 'query': The `format_schema` is a query to retrieve the schema.\nWhen `format_schema_source` is set to 'query', the following conditions apply:\n- The query must return exactly one value: a single row with a single string column.\n- The result of the query is treated as the schema content.\n- This result is cached locally in the `format_schemas` directory.\n- You can clear the local cache using the command: `SYSTEM DROP FORMAT SCHEMA CACHE FOR Files`.\n- Once cached, identical queries are not executed to fetch the schema again until the cache is explicitly cleared\n- In addition to local cache files, Protobuf messages are also cached in memory. Even after clearing the local cache files, the in-memory cache must be cleared using `SYSTEM DROP FORMAT SCHEMA CACHE [FOR Protobuf]` to fully refresh the schema.\n- Run the query `SYSTEM DROP FORMAT SCHEMA CACHE` to clear the cache for both cache files and Protobuf messages schemas at once."
    },
    {
      "name": "format_template_resultset",
      "type": "String",
      "description": "Path to file which contains format string for result set (for Template format)"
    },
    {
      "name": "format_template_resultset_format",
      "type": "String",
      "description": "Format string for result set (for Template format)"
    },
    {
      "name": "format_template_row",
      "type": "String",
      "description": "Path to file which contains format string for rows (for Template format)"
    },
    {
      "name": "format_template_row_format",
      "type": "String",
      "description": "Format string for rows (for Template format)"
    },
    {
      "name": "format_template_rows_between_delimiter",
      "type": "String",
      "description": "Delimiter between rows (for Template format)"
    },
    {
      "name": "format_tsv_null_representation",
      "type": "String",
      "description": "Custom NULL representation in TSV format"
    },
    {
      "name": "formatdatetime_e_with_space_padding",
      "type": "Bool",
      "description": "Formatter '%e' in function 'formatDateTime' prints single-digit days with a leading space, e.g. ' 2' instead of '2'.\n    "
    },
    {
      "name": "formatdatetime_f_prints_scale_number_of_digits",
      "type": "Bool",
      "description": "Formatter '%f' in function 'formatDateTime' prints only the scale amount of digits for a DateTime64 instead of fixed 6 digits."
    },
    {
      "name": "formatdatetime_f_prints_single_zero",
      "type": "Bool",
      "description": "Formatter '%f' in function 'formatDateTime' prints a single zero instead of six zeros if the formatted value has no fractional seconds."
    },
    {
      "name": "formatdatetime_format_without_leading_zeros",
      "type": "Bool",
      "description": "Formatters '%c', '%l' and '%k' in function 'formatDateTime' print months and hours without leading zeros."
    },
    {
      "name": "formatdatetime_parsedatetime_m_is_month_name",
      "type": "Bool",
      "description": "Formatter '%M' in functions 'formatDateTime' and 'parseDateTime' print/parse the month name instead of minutes."
    },
    {
      "name": "fsync_metadata",
      "type": "Bool",
      "description": "Enables or disables [fsync](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html) when writing `.sql` files. Enabled by default.\n\nIt makes sense to disable it if the server has millions of tiny tables that are constantly being created and destroyed."
    },
    {
      "name": "function_date_trunc_return_type_behavior",
      "type": "UInt64",
      "description": "Allows to change the behaviour of the result type of `dateTrunc` function.\n\nPossible values:\n- 0 - When the second argument is `DateTime64/Date32` the return type will be `DateTime64/Date32` regardless of the time unit in the first argument.\n- 1 - For `Date32` the result is always `Date`. For `DateTime64` the result is `DateTime` for time units `second` and higher."
    },
    {
      "name": "function_implementation",
      "type": "String",
      "description": "Choose function implementation for specific target or variant (experimental). If empty enable all of them."
    },
    {
      "name": "function_json_value_return_type_allow_complex",
      "type": "Bool",
      "description": "Control whether allow to return complex type (such as: struct, array, map) for json_value function.\n\n```sql\nSELECT JSON_VALUE('{\"hello\":{\"world\":\"!\"}}', '$.hello') settings function_json_value_return_type_allow_complex=true\n\n┌─JSON_VALUE('{\"hello\":{\"world\":\"!\"}}', '$.hello')─┐\n│ {\"world\":\"!\"}                                    │\n└──────────────────────────────────────────────────┘\n\n1 row in set. Elapsed: 0.001 sec.\n```\n\nPossible values:\n\n- true — Allow.\n- false — Disallow."
    },
    {
      "name": "function_json_value_return_type_allow_nullable",
      "type": "Bool",
      "description": "Control whether allow to return `NULL` when value is not exist for JSON_VALUE function.\n\n```sql\nSELECT JSON_VALUE('{\"hello\":\"world\"}', '$.b') settings function_json_value_return_type_allow_nullable=true;\n\n┌─JSON_VALUE('{\"hello\":\"world\"}', '$.b')─┐\n│ ᴺᵁᴸᴸ                                   │\n└────────────────────────────────────────┘\n\n1 row in set. Elapsed: 0.001 sec.\n```\n\nPossible values:\n\n- true — Allow.\n- false — Disallow."
    },
    {
      "name": "function_locate_has_mysql_compatible_argument_order",
      "type": "Bool",
      "description": "Controls the order of arguments in function [locate](../../sql-reference/functions/string-search-functions.md/#locate).\n\nPossible values:\n\n- 0 — Function `locate` accepts arguments `(haystack, needle[, start_pos])`.\n- 1 — Function `locate` accepts arguments `(needle, haystack, [, start_pos])` (MySQL-compatible behavior)"
    },
    {
      "name": "function_range_max_elements_in_block",
      "type": "UInt64",
      "description": "Sets the safety threshold for data volume generated by function [range](/sql-reference/functions/array-functions#range). Defines the maximum number of values generated by function per block of data (sum of array sizes for every row in a block).\n\nPossible values:\n\n- Positive integer.\n\n**See Also**\n\n- [`max_block_size`](#max_block_size)\n- [`min_insert_block_size_rows`](#min_insert_block_size_rows)"
    },
    {
      "name": "function_sleep_max_microseconds_per_block",
      "type": "UInt64",
      "description": "Maximum number of microseconds the function `sleep` is allowed to sleep for each block. If a user called it with a larger value, it throws an exception. It is a safety threshold."
    },
    {
      "name": "function_visible_width_behavior",
      "type": "UInt64",
      "description": "The version of `visibleWidth` behavior. 0 - only count the number of code points; 1 - correctly count zero-width and combining characters, count full-width characters as two, estimate the tab width, count delete characters."
    },
    {
      "name": "geo_distance_returns_float64_on_float64_arguments",
      "type": "Bool",
      "description": "If all four arguments to `geoDistance`, `greatCircleDistance`, `greatCircleAngle` functions are Float64, return Float64 and use double precision for internal calculations. In previous ClickHouse versions, the functions always returned Float32."
    },
    {
      "name": "geotoh3_argument_order",
      "type": "GeoToH3ArgumentOrder",
      "description": "Function 'geoToH3' accepts (lon, lat) if set to 'lon_lat' and (lat, lon) if set to 'lat_lon'."
    },
    {
      "name": "glob_expansion_max_elements",
      "type": "UInt64",
      "description": "Maximum number of allowed addresses (For external storages, table functions, etc)."
    },
    {
      "name": "grace_hash_join_initial_buckets",
      "type": "NonZeroUInt64",
      "description": "Initial number of grace hash join buckets"
    },
    {
      "name": "grace_hash_join_max_buckets",
      "type": "NonZeroUInt64",
      "description": "Limit on the number of grace hash join buckets"
    },
    {
      "name": "group_by_overflow_mode",
      "type": "OverflowModeGroupBy",
      "description": "Sets what happens when the number of unique keys for aggregation exceeds the limit:\n- `throw`: throw an exception\n- `break`: stop executing the query and return the partial result\n- `any`: continue aggregation for the keys that got into the set, but do not add new keys to the set.\n\nUsing the 'any' value lets you run an approximation of GROUP BY. The quality of\nthis approximation depends on the statistical nature of the data."
    },
    {
      "name": "group_by_two_level_threshold",
      "type": "UInt64",
      "description": "From what number of keys, a two-level aggregation starts. 0 - the threshold is not set."
    },
    {
      "name": "group_by_two_level_threshold_bytes",
      "type": "UInt64",
      "description": "From what size of the aggregation state in bytes, a two-level aggregation begins to be used. 0 - the threshold is not set. Two-level aggregation is used when at least one of the thresholds is triggered."
    },
    {
      "name": "group_by_use_nulls",
      "type": "Bool",
      "description": "Changes the way the [GROUP BY clause](/sql-reference/statements/select/group-by) treats the types of aggregation keys.\nWhen the `ROLLUP`, `CUBE`, or `GROUPING SETS` specifiers are used, some aggregation keys may not be used to produce some result rows.\nColumns for these keys are filled with either default value or `NULL` in corresponding rows depending on this setting.\n\nPossible values:\n\n- 0 — The default value for the aggregation key type is used to produce missing values.\n- 1 — ClickHouse executes `GROUP BY` the same way as the SQL standard says. The types of aggregation keys are converted to [Nullable](/sql-reference/data-types/nullable). Columns for corresponding aggregation keys are filled with [NULL](/sql-reference/syntax#null) for rows that didn't use it.\n\nSee also:\n\n- [GROUP BY clause](/sql-reference/statements/select/group-by)"
    },
    {
      "name": "h3togeo_lon_lat_result_order",
      "type": "Bool",
      "description": "Function 'h3ToGeo' returns (lon, lat) if true, otherwise (lat, lon)."
    },
    {
      "name": "handle_kafka_error_mode",
      "type": "StreamingHandleErrorMode",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "handshake_timeout_ms",
      "type": "Milliseconds",
      "description": "Timeout in milliseconds for receiving Hello packet from replicas during handshake."
    },
    {
      "name": "hdfs_create_new_file_on_insert",
      "type": "Bool",
      "description": "Enables or disables creating a new file on each insert in HDFS engine tables. If enabled, on each insert a new HDFS file will be created with the name, similar to this pattern:\n\ninitial: `data.Parquet.gz` -> `data.1.Parquet.gz` -> `data.2.Parquet.gz`, etc.\n\nPossible values:\n- 0 — `INSERT` query appends new data to the end of the file.\n- 1 — `INSERT` query creates a new file."
    },
    {
      "name": "hdfs_ignore_file_doesnt_exist",
      "type": "Bool",
      "description": "Ignore absence of file if it does not exist when reading certain keys.\n\nPossible values:\n- 1 — `SELECT` returns empty result.\n- 0 — `SELECT` throws an exception."
    },
    {
      "name": "hdfs_replication",
      "type": "UInt64",
      "description": "The actual number of replications can be specified when the hdfs file is created."
    },
    {
      "name": "hdfs_skip_empty_files",
      "type": "Bool",
      "description": "Enables or disables skipping empty files in [HDFS](../../engines/table-engines/integrations/hdfs.md) engine tables.\n\nPossible values:\n- 0 — `SELECT` throws an exception if empty file is not compatible with requested format.\n- 1 — `SELECT` returns empty result for empty file."
    },
    {
      "name": "hdfs_throw_on_zero_files_match",
      "type": "Bool",
      "description": "Throw an error if matched zero files according to glob expansion rules.\n\nPossible values:\n- 1 — `SELECT` throws an exception.\n- 0 — `SELECT` returns empty result."
    },
    {
      "name": "hdfs_truncate_on_insert",
      "type": "Bool",
      "description": "Enables or disables truncation before an insert in hdfs engine tables. If disabled, an exception will be thrown on an attempt to insert if a file in HDFS already exists.\n\nPossible values:\n- 0 — `INSERT` query appends new data to the end of the file.\n- 1 — `INSERT` query replaces existing content of the file with the new data."
    },
    {
      "name": "hedged_connection_timeout_ms",
      "type": "Milliseconds",
      "description": "Connection timeout for establishing connection with replica for Hedged requests"
    },
    {
      "name": "hnsw_candidate_list_size_for_search",
      "type": "UInt64",
      "description": "The size of the dynamic candidate list when searching the vector similarity index, also known as 'ef_search'."
    },
    {
      "name": "hsts_max_age",
      "type": "UInt64",
      "description": "Expired time for HSTS. 0 means disable HSTS."
    },
    {
      "name": "http_connection_timeout",
      "type": "Seconds",
      "description": "HTTP connection timeout (in seconds).\n\nPossible values:\n\n- Any positive integer.\n- 0 - Disabled (infinite timeout)."
    },
    {
      "name": "http_headers_progress_interval_ms",
      "type": "UInt64",
      "description": "Do not send HTTP headers X-ClickHouse-Progress more frequently than at each specified interval."
    },
    {
      "name": "http_make_head_request",
      "type": "Bool",
      "description": "The `http_make_head_request` setting allows the execution of a `HEAD` request while reading data from HTTP to retrieve information about the file to be read, such as its size. Since it's enabled by default, it may be desirable to disable this setting in cases where the server does not support `HEAD` requests."
    },
    {
      "name": "http_max_chunk_size",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "http_max_field_name_size",
      "type": "UInt64",
      "description": "Maximum length of field name in HTTP header"
    },
    {
      "name": "http_max_field_value_size",
      "type": "UInt64",
      "description": "Maximum length of field value in HTTP header"
    },
    {
      "name": "http_max_fields",
      "type": "UInt64",
      "description": "Maximum number of fields in HTTP header"
    },
    {
      "name": "http_max_multipart_form_data_size",
      "type": "UInt64",
      "description": "Limit on size of multipart/form-data content. This setting cannot be parsed from URL parameters and should be set in a user profile. Note that content is parsed and external tables are created in memory before the start of query execution. And this is the only limit that has an effect on that stage (limits on max memory usage and max execution time have no effect while reading HTTP form data)."
    },
    {
      "name": "http_max_request_param_data_size",
      "type": "UInt64",
      "description": "Limit on size of request data used as a query parameter in predefined HTTP requests."
    },
    {
      "name": "http_max_tries",
      "type": "UInt64",
      "description": "Max attempts to read via http."
    },
    {
      "name": "http_max_uri_size",
      "type": "UInt64",
      "description": "Sets the maximum URI length of an HTTP request.\n\nPossible values:\n\n- Positive integer."
    },
    {
      "name": "http_native_compression_disable_checksumming_on_decompress",
      "type": "Bool",
      "description": "Enables or disables checksum verification when decompressing the HTTP POST data from the client. Used only for ClickHouse native compression format (not used with `gzip` or `deflate`).\n\nFor more information, read the [HTTP interface description](../../interfaces/http.md).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "http_receive_timeout",
      "type": "Seconds",
      "description": "HTTP receive timeout (in seconds).\n\nPossible values:\n\n- Any positive integer.\n- 0 - Disabled (infinite timeout)."
    },
    {
      "name": "http_response_buffer_size",
      "type": "UInt64",
      "description": "The number of bytes to buffer in the server memory before sending a HTTP response to the client or flushing to disk (when http_wait_end_of_query is enabled)."
    },
    {
      "name": "http_response_headers",
      "type": "Map",
      "description": "Allows to add or override HTTP headers which the server will return in the response with a successful query result.\nThis only affects the HTTP interface.\n\nIf the header is already set by default, the provided value will override it.\nIf the header was not set by default, it will be added to the list of headers.\nHeaders that are set by the server by default and not overridden by this setting, will remain.\n\nThe setting allows you to set a header to a constant value. Currently there is no way to set a header to a dynamically calculated value.\n\nNeither names or values can contain ASCII control characters.\n\nIf you implement a UI application which allows users to modify settings but at the same time makes decisions based on the returned headers, it is recommended to restrict this setting to readonly.\n\nExample: `SET http_response_headers = '{\"Content-Type\": \"image/png\"}'`"
    },
    {
      "name": "http_retry_initial_backoff_ms",
      "type": "UInt64",
      "description": "Min milliseconds for backoff, when retrying read via http"
    },
    {
      "name": "http_retry_max_backoff_ms",
      "type": "UInt64",
      "description": "Max milliseconds for backoff, when retrying read via http"
    },
    {
      "name": "http_send_timeout",
      "type": "Seconds",
      "description": "HTTP send timeout (in seconds).\n\nPossible values:\n\n- Any positive integer.\n- 0 - Disabled (infinite timeout).\n\n:::note\nIt's applicable only to the default profile. A server reboot is required for the changes to take effect.\n:::"
    },
    {
      "name": "http_skip_not_found_url_for_globs",
      "type": "Bool",
      "description": "Skip URLs for globs with HTTP_NOT_FOUND error"
    },
    {
      "name": "http_wait_end_of_query",
      "type": "Bool",
      "description": "Enable HTTP response buffering on the server-side."
    },
    {
      "name": "http_write_exception_in_output_format",
      "type": "Bool",
      "description": "Write exception in output format to produce valid output. Works with JSON and XML formats."
    },
    {
      "name": "http_zlib_compression_level",
      "type": "Int64",
      "description": "Sets the level of data compression in the response to an HTTP request if [enable_http_compression = 1](#enable_http_compression).\n\nPossible values: Numbers from 1 to 9."
    },
    {
      "name": "iceberg_engine_ignore_schema_evolution",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "iceberg_snapshot_id",
      "type": "Int64",
      "description": "Query Iceberg table using the specific snapshot id."
    },
    {
      "name": "iceberg_timestamp_ms",
      "type": "Int64",
      "description": "Query Iceberg table using the snapshot that was current at a specific timestamp."
    },
    {
      "name": "idle_connection_timeout",
      "type": "UInt64",
      "description": "Timeout to close idle TCP connections after specified number of seconds.\n\nPossible values:\n\n- Positive integer (0 - close immediately, after 0 seconds)."
    },
    {
      "name": "ignore_cold_parts_seconds",
      "type": "Int64",
      "description": "Only has an effect in ClickHouse Cloud. Exclude new data parts from SELECT queries until they're either pre-warmed (see [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch)) or this many seconds old. Only for Replicated-/SharedMergeTree."
    },
    {
      "name": "ignore_data_skipping_indices",
      "type": "String",
      "description": "Ignores the skipping indexes specified if used by the query.\n\nConsider the following example:\n\n```sql\nCREATE TABLE data\n(\n    key Int,\n    x Int,\n    y Int,\n    INDEX x_idx x TYPE minmax GRANULARITY 1,\n    INDEX y_idx y TYPE minmax GRANULARITY 1,\n    INDEX xy_idx (x,y) TYPE minmax GRANULARITY 1\n)\nEngine=MergeTree()\nORDER BY key;\n\nINSERT INTO data VALUES (1, 2, 3);\n\nSELECT * FROM data;\nSELECT * FROM data SETTINGS ignore_data_skipping_indices=''; -- query will produce CANNOT_PARSE_TEXT error.\nSELECT * FROM data SETTINGS ignore_data_skipping_indices='x_idx'; -- Ok.\nSELECT * FROM data SETTINGS ignore_data_skipping_indices='na_idx'; -- Ok.\n\nSELECT * FROM data WHERE x = 1 AND y = 1 SETTINGS ignore_data_skipping_indices='xy_idx',force_data_skipping_indices='xy_idx' ; -- query will produce INDEX_NOT_USED error, since xy_idx is explicitly ignored.\nSELECT * FROM data WHERE x = 1 AND y = 2 SETTINGS ignore_data_skipping_indices='xy_idx';\n```\n\nThe query without ignoring any indexes:\n```sql\nEXPLAIN indexes = 1 SELECT * FROM data WHERE x = 1 AND y = 2;\n\nExpression ((Projection + Before ORDER BY))\n  Filter (WHERE)\n    ReadFromMergeTree (default.data)\n    Indexes:\n      PrimaryKey\n        Condition: true\n        Parts: 1/1\n        Granules: 1/1\n      Skip\n        Name: x_idx\n        Description: minmax GRANULARITY 1\n        Parts: 0/1\n        Granules: 0/1\n      Skip\n        Name: y_idx\n        Description: minmax GRANULARITY 1\n        Parts: 0/0\n        Granules: 0/0\n      Skip\n        Name: xy_idx\n        Description: minmax GRANULARITY 1\n        Parts: 0/0\n        Granules: 0/0\n```\n\nIgnoring the `xy_idx` index:\n```sql\nEXPLAIN indexes = 1 SELECT * FROM data WHERE x = 1 AND y = 2 SETTINGS ignore_data_skipping_indices='xy_idx';\n\nExpression ((Projection + Before ORDER BY))\n  Filter (WHERE)\n    ReadFromMergeTree (default.data)\n    Indexes:\n      PrimaryKey\n        Condition: true\n        Parts: 1/1\n        Granules: 1/1\n      Skip\n        Name: x_idx\n        Description: minmax GRANULARITY 1\n        Parts: 0/1\n        Granules: 0/1\n      Skip\n        Name: y_idx\n        Description: minmax GRANULARITY 1\n        Parts: 0/0\n        Granules: 0/0\n```\n\nWorks with tables in the MergeTree family."
    },
    {
      "name": "ignore_drop_queries_probability",
      "type": "Float",
      "description": "If enabled, server will ignore all DROP table queries with specified probability (for Memory and JOIN engines it will replcase DROP to TRUNCATE). Used for testing purposes"
    },
    {
      "name": "ignore_materialized_views_with_dropped_target_table",
      "type": "Bool",
      "description": "Ignore MVs with dropped target table during pushing to views"
    },
    {
      "name": "ignore_on_cluster_for_replicated_access_entities_queries",
      "type": "Bool",
      "description": "Ignore ON CLUSTER clause for replicated access entities management queries."
    },
    {
      "name": "ignore_on_cluster_for_replicated_named_collections_queries",
      "type": "Bool",
      "description": "Ignore ON CLUSTER clause for replicated named collections management queries."
    },
    {
      "name": "ignore_on_cluster_for_replicated_udf_queries",
      "type": "Bool",
      "description": "Ignore ON CLUSTER clause for replicated UDF management queries."
    },
    {
      "name": "implicit_select",
      "type": "Bool",
      "description": "Allow writing simple SELECT queries without the leading SELECT keyword, which makes it simple for calculator-style usage, e.g. `1 + 2` becomes a valid query.\n\nIn `clickhouse-local` it is enabled by default and can be explicitly disabled."
    },
    {
      "name": "implicit_table_at_top_level",
      "type": "String",
      "description": "If not empty, queries without FROM at the top level will read from this table instead of system.one.\n\nThis is used in clickhouse-local for input data processing.\nThe setting could be set explicitly by a user but is not intended for this type of usage.\n\nSubqueries are not affected by this setting (neither scalar, FROM, or IN subqueries).\nSELECTs at the top level of UNION, INTERSECT, EXCEPT chains are treated uniformly and affected by this setting, regardless of their grouping in parentheses.\nIt is unspecified how this setting affects views and distributed queries.\n\nThe setting accepts a table name (then the table is resolved from the current database) or a qualified name in the form of 'database.table'.\nBoth database and table names have to be unquoted - only simple identifiers are allowed."
    },
    {
      "name": "implicit_transaction",
      "type": "Bool",
      "description": "If enabled and not already inside a transaction, wraps the query inside a full transaction (begin + commit or rollback)"
    },
    {
      "name": "input_format_allow_errors_num",
      "type": "UInt64",
      "description": "Sets the maximum number of acceptable errors when reading from text formats (CSV, TSV, etc.).\n\nThe default value is 0.\n\nAlways pair it with `input_format_allow_errors_ratio`.\n\nIf an error occurred while reading rows but the error counter is still less than `input_format_allow_errors_num`, ClickHouse ignores the row and moves on to the next one.\n\nIf both `input_format_allow_errors_num` and `input_format_allow_errors_ratio` are exceeded, ClickHouse throws an exception."
    },
    {
      "name": "input_format_allow_errors_ratio",
      "type": "Float",
      "description": "Sets the maximum percentage of errors allowed when reading from text formats (CSV, TSV, etc.).\nThe percentage of errors is set as a floating-point number between 0 and 1.\n\nThe default value is 0.\n\nAlways pair it with `input_format_allow_errors_num`.\n\nIf an error occurred while reading rows but the error counter is still less than `input_format_allow_errors_ratio`, ClickHouse ignores the row and moves on to the next one.\n\nIf both `input_format_allow_errors_num` and `input_format_allow_errors_ratio` are exceeded, ClickHouse throws an exception."
    },
    {
      "name": "input_format_allow_seeks",
      "type": "Bool",
      "description": "Allow seeks while reading in ORC/Parquet/Arrow input formats.\n\nEnabled by default."
    },
    {
      "name": "input_format_arrow_allow_missing_columns",
      "type": "Bool",
      "description": "Allow missing columns while reading Arrow input formats"
    },
    {
      "name": "input_format_arrow_case_insensitive_column_matching",
      "type": "Bool",
      "description": "Ignore case when matching Arrow columns with CH columns."
    },
    {
      "name": "input_format_arrow_import_nested",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "input_format_arrow_skip_columns_with_unsupported_types_in_schema_inference",
      "type": "Bool",
      "description": "Skip columns with unsupported types while schema inference for format Arrow"
    },
    {
      "name": "input_format_avro_allow_missing_fields",
      "type": "Bool",
      "description": "For Avro/AvroConfluent format: when field is not found in schema use default value instead of error"
    },
    {
      "name": "input_format_avro_null_as_default",
      "type": "Bool",
      "description": "For Avro/AvroConfluent format: insert default in case of null and non Nullable column"
    },
    {
      "name": "input_format_binary_decode_types_in_binary_format",
      "type": "Bool",
      "description": "Read data types in binary format instead of type names in RowBinaryWithNamesAndTypes input format"
    },
    {
      "name": "input_format_binary_read_json_as_string",
      "type": "Bool",
      "description": "Read values of [JSON](../../sql-reference/data-types/newjson.md) data type as JSON [String](../../sql-reference/data-types/string.md) values in RowBinary input format."
    },
    {
      "name": "input_format_bson_skip_fields_with_unsupported_types_in_schema_inference",
      "type": "Bool",
      "description": "Skip fields with unsupported types while schema inference for format BSON."
    },
    {
      "name": "input_format_capn_proto_skip_fields_with_unsupported_types_in_schema_inference",
      "type": "Bool",
      "description": "Skip columns with unsupported types while schema inference for format CapnProto"
    },
    {
      "name": "input_format_csv_allow_cr_end_of_line",
      "type": "Bool",
      "description": "If it is set true, \\\\r will be allowed at end of line not followed by \\\\n"
    },
    {
      "name": "input_format_csv_allow_variable_number_of_columns",
      "type": "Bool",
      "description": "Ignore extra columns in CSV input (if file has more columns than expected) and treat missing fields in CSV input as default values"
    },
    {
      "name": "input_format_csv_allow_whitespace_or_tab_as_delimiter",
      "type": "Bool",
      "description": "Allow to use spaces and tabs(\\\\t) as field delimiter in the CSV strings"
    },
    {
      "name": "input_format_csv_arrays_as_nested_csv",
      "type": "Bool",
      "description": "When reading Array from CSV, expect that its elements were serialized in nested CSV and then put into string. Example: \\\"[\\\"\\\"Hello\\\"\\\", \\\"\\\"world\\\"\\\", \\\"\\\"42\\\"\\\"\\\"\\\" TV\\\"\\\"]\\\". Braces around array can be omitted."
    },
    {
      "name": "input_format_csv_deserialize_separate_columns_into_tuple",
      "type": "Bool",
      "description": "If it set to true, then separate columns written in CSV format can be deserialized to Tuple column."
    },
    {
      "name": "input_format_csv_detect_header",
      "type": "Bool",
      "description": "Automatically detect header with names and types in CSV format"
    },
    {
      "name": "input_format_csv_empty_as_default",
      "type": "Bool",
      "description": "Treat empty fields in CSV input as default values."
    },
    {
      "name": "input_format_csv_enum_as_number",
      "type": "Bool",
      "description": "Treat inserted enum values in CSV formats as enum indices"
    },
    {
      "name": "input_format_csv_skip_first_lines",
      "type": "UInt64",
      "description": "Skip specified number of lines at the beginning of data in CSV format"
    },
    {
      "name": "input_format_csv_skip_trailing_empty_lines",
      "type": "Bool",
      "description": "Skip trailing empty lines in CSV format"
    },
    {
      "name": "input_format_csv_trim_whitespaces",
      "type": "Bool",
      "description": "Trims spaces and tabs (\\\\t) characters at the beginning and end in CSV strings"
    },
    {
      "name": "input_format_csv_try_infer_numbers_from_strings",
      "type": "Bool",
      "description": "If enabled, during schema inference ClickHouse will try to infer numbers from string fields.\nIt can be useful if CSV data contains quoted UInt64 numbers.\n\nDisabled by default."
    },
    {
      "name": "input_format_csv_try_infer_strings_from_quoted_tuples",
      "type": "Bool",
      "description": "Interpret quoted tuples in the input data as a value of type String."
    },
    {
      "name": "input_format_csv_use_best_effort_in_schema_inference",
      "type": "Bool",
      "description": "Use some tweaks and heuristics to infer schema in CSV format"
    },
    {
      "name": "input_format_csv_use_default_on_bad_values",
      "type": "Bool",
      "description": "Allow to set default value to column when CSV field deserialization failed on bad value"
    },
    {
      "name": "input_format_custom_allow_variable_number_of_columns",
      "type": "Bool",
      "description": "Ignore extra columns in CustomSeparated input (if file has more columns than expected) and treat missing fields in CustomSeparated input as default values"
    },
    {
      "name": "input_format_custom_detect_header",
      "type": "Bool",
      "description": "Automatically detect header with names and types in CustomSeparated format"
    },
    {
      "name": "input_format_custom_skip_trailing_empty_lines",
      "type": "Bool",
      "description": "Skip trailing empty lines in CustomSeparated format"
    },
    {
      "name": "input_format_defaults_for_omitted_fields",
      "type": "Bool",
      "description": "When performing `INSERT` queries, replace omitted input column values with default values of the respective columns. This option applies to [JSONEachRow](/interfaces/formats/JSONEachRow) (and other JSON formats), [CSV](/interfaces/formats/CSV), [TabSeparated](/interfaces/formats/TabSeparated), [TSKV](/interfaces/formats/TSKV), [Parquet](/interfaces/formats/Parquet), [Arrow](/interfaces/formats/Arrow), [Avro](/interfaces/formats/Avro), [ORC](/interfaces/formats/ORC), [Native](/interfaces/formats/Native) formats and formats with `WithNames`/`WithNamesAndTypes` suffixes.\n\n:::note\nWhen this option is enabled, extended table metadata are sent from server to client. It consumes additional computing resources on the server and can reduce performance.\n:::\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "input_format_force_null_for_omitted_fields",
      "type": "Bool",
      "description": "Force initialize omitted fields with null values"
    },
    {
      "name": "input_format_hive_text_allow_variable_number_of_columns",
      "type": "Bool",
      "description": "Ignore extra columns in Hive Text input (if file has more columns than expected) and treat missing fields in Hive Text input as default values"
    },
    {
      "name": "input_format_hive_text_collection_items_delimiter",
      "type": "Char",
      "description": "Delimiter between collection(array or map) items in Hive Text File"
    },
    {
      "name": "input_format_hive_text_fields_delimiter",
      "type": "Char",
      "description": "Delimiter between fields in Hive Text File"
    },
    {
      "name": "input_format_hive_text_map_keys_delimiter",
      "type": "Char",
      "description": "Delimiter between a pair of map key/values in Hive Text File"
    },
    {
      "name": "input_format_import_nested_json",
      "type": "Bool",
      "description": "Enables or disables the insertion of JSON data with nested objects.\n\nSupported formats:\n\n- [JSONEachRow](/interfaces/formats/JSONEachRow)\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nSee also:\n\n- [Usage of Nested Structures](/integrations/data-formats/json/other-formats#accessing-nested-json-objects) with the `JSONEachRow` format."
    },
    {
      "name": "input_format_ipv4_default_on_conversion_error",
      "type": "Bool",
      "description": "Deserialization of IPv4 will use default values instead of throwing exception on conversion error.\n\nDisabled by default."
    },
    {
      "name": "input_format_ipv6_default_on_conversion_error",
      "type": "Bool",
      "description": "Deserialization of IPV6 will use default values instead of throwing exception on conversion error.\n\nDisabled by default."
    },
    {
      "name": "input_format_json_compact_allow_variable_number_of_columns",
      "type": "Bool",
      "description": "Allow variable number of columns in rows in JSONCompact/JSONCompactEachRow input formats.\nIgnore extra columns in rows with more columns than expected and treat missing columns as default values.\n\nDisabled by default."
    },
    {
      "name": "input_format_json_defaults_for_missing_elements_in_named_tuple",
      "type": "Bool",
      "description": "Insert default values for missing elements in JSON object while parsing named tuple.\nThis setting works only when setting `input_format_json_named_tuples_as_objects` is enabled.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_empty_as_default",
      "type": "Bool",
      "description": "When enabled, replace empty input fields in JSON with default values. For complex default expressions `input_format_defaults_for_omitted_fields` must be enabled too.\n\nPossible values:\n\n+ 0 — Disable.\n+ 1 — Enable."
    },
    {
      "name": "input_format_json_ignore_unknown_keys_in_named_tuple",
      "type": "Bool",
      "description": "Ignore unknown keys in json object for named tuples.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_ignore_unnecessary_fields",
      "type": "Bool",
      "description": "Ignore unnecessary fields and not parse them. Enabling this may not throw exceptions on json strings of invalid format or with duplicated fields"
    },
    {
      "name": "input_format_json_infer_incomplete_types_as_strings",
      "type": "Bool",
      "description": "Allow to use String type for JSON keys that contain only `Null`/`{}`/`[]` in data sample during schema inference.\nIn JSON formats any value can be read as String, and we can avoid errors like `Cannot determine type for column 'column_name' by first 25000 rows of data, most likely this column contains only Nulls or empty Arrays/Maps` during schema inference\nby using String type for keys with unknown types.\n\nExample:\n\n```sql\nSET input_format_json_infer_incomplete_types_as_strings = 1, input_format_json_try_infer_named_tuples_from_objects = 1;\nDESCRIBE format(JSONEachRow, '{\"obj\" : {\"a\" : [1,2,3], \"b\" : \"hello\", \"c\" : null, \"d\" : {}, \"e\" : []}}');\nSELECT * FROM format(JSONEachRow, '{\"obj\" : {\"a\" : [1,2,3], \"b\" : \"hello\", \"c\" : null, \"d\" : {}, \"e\" : []}}');\n```\n\nResult:\n```\n┌─name─┬─type───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─default_type─┬─default_expression─┬─comment─┬─codec_expression─┬─ttl_expression─┐\n│ obj  │ Tuple(a Array(Nullable(Int64)), b Nullable(String), c Nullable(String), d Nullable(String), e Array(Nullable(String))) │              │                    │         │                  │                │\n└──────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────┘\n\n┌─obj────────────────────────────┐\n│ ([1,2,3],'hello',NULL,'{}',[]) │\n└────────────────────────────────┘\n```\n\nEnabled by default."
    },
    {
      "name": "input_format_json_max_depth",
      "type": "UInt64",
      "description": "Maximum depth of a field in JSON. This is not a strict limit, it does not have to be applied precisely."
    },
    {
      "name": "input_format_json_named_tuples_as_objects",
      "type": "Bool",
      "description": "Parse named tuple columns as JSON objects.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_read_arrays_as_strings",
      "type": "Bool",
      "description": "Allow parsing JSON arrays as strings in JSON input formats.\n\nExample:\n\n```sql\nSET input_format_json_read_arrays_as_strings = 1;\nSELECT arr, toTypeName(arr), JSONExtractArrayRaw(arr)[3] from format(JSONEachRow, 'arr String', '{\"arr\" : [1, \"Hello\", [1,2,3]]}');\n```\n\nResult:\n```\n┌─arr───────────────────┬─toTypeName(arr)─┬─arrayElement(JSONExtractArrayRaw(arr), 3)─┐\n│ [1, \"Hello\", [1,2,3]] │ String          │ [1,2,3]                                   │\n└───────────────────────┴─────────────────┴───────────────────────────────────────────┘\n```\n\nEnabled by default."
    },
    {
      "name": "input_format_json_read_bools_as_numbers",
      "type": "Bool",
      "description": "Allow parsing bools as numbers in JSON input formats.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_read_bools_as_strings",
      "type": "Bool",
      "description": "Allow parsing bools as strings in JSON input formats.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_read_numbers_as_strings",
      "type": "Bool",
      "description": "Allow parsing numbers as strings in JSON input formats.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_read_objects_as_strings",
      "type": "Bool",
      "description": "Allow parsing JSON objects as strings in JSON input formats.\n\nExample:\n\n```sql\nSET input_format_json_read_objects_as_strings = 1;\nCREATE TABLE test (id UInt64, obj String, date Date) ENGINE=Memory();\nINSERT INTO test FORMAT JSONEachRow {\"id\" : 1, \"obj\" : {\"a\" : 1, \"b\" : \"Hello\"}, \"date\" : \"2020-01-01\"};\nSELECT * FROM test;\n```\n\nResult:\n\n```\n┌─id─┬─obj──────────────────────┬───────date─┐\n│  1 │ {\"a\" : 1, \"b\" : \"Hello\"} │ 2020-01-01 │\n└────┴──────────────────────────┴────────────┘\n```\n\nEnabled by default."
    },
    {
      "name": "input_format_json_throw_on_bad_escape_sequence",
      "type": "Bool",
      "description": "Throw an exception if JSON string contains bad escape sequence in JSON input formats. If disabled, bad escape sequences will remain as is in the data.\n\nEnabled by default."
    },
    {
      "name": "input_format_json_try_infer_named_tuples_from_objects",
      "type": "Bool",
      "description": "If enabled, during schema inference ClickHouse will try to infer named Tuple from JSON objects.\nThe resulting named Tuple will contain all elements from all corresponding JSON objects from sample data.\n\nExample:\n\n```sql\nSET input_format_json_try_infer_named_tuples_from_objects = 1;\nDESC format(JSONEachRow, '{\"obj\" : {\"a\" : 42, \"b\" : \"Hello\"}}, {\"obj\" : {\"a\" : 43, \"c\" : [1, 2, 3]}}, {\"obj\" : {\"d\" : {\"e\" : 42}}}')\n```\n\nResult:\n\n```\n┌─name─┬─type───────────────────────────────────────────────────────────────────────────────────────────────┬─default_type─┬─default_expression─┬─comment─┬─codec_expression─┬─ttl_expression─┐\n│ obj  │ Tuple(a Nullable(Int64), b Nullable(String), c Array(Nullable(Int64)), d Tuple(e Nullable(Int64))) │              │                    │         │                  │                │\n└──────┴────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────┘\n```\n\nEnabled by default."
    },
    {
      "name": "input_format_json_try_infer_numbers_from_strings",
      "type": "Bool",
      "description": "If enabled, during schema inference ClickHouse will try to infer numbers from string fields.\nIt can be useful if JSON data contains quoted UInt64 numbers.\n\nDisabled by default."
    },
    {
      "name": "input_format_json_use_string_type_for_ambiguous_paths_in_named_tuples_inference_from_objects",
      "type": "Bool",
      "description": "Use String type instead of an exception in case of ambiguous paths in JSON objects during named tuples inference"
    },
    {
      "name": "input_format_json_validate_types_from_metadata",
      "type": "Bool",
      "description": "For JSON/JSONCompact/JSONColumnsWithMetadata input formats, if this setting is set to 1,\nthe types from metadata in input data will be compared with the types of the corresponding columns from the table.\n\nEnabled by default."
    },
    {
      "name": "input_format_max_block_size_bytes",
      "type": "UInt64",
      "description": "Limits the size of the blocks formed during data parsing in input formats in bytes. Used in row based input formats when block is formed on ClickHouse side.\n0 means no limit in bytes."
    },
    {
      "name": "input_format_max_bytes_to_read_for_schema_inference",
      "type": "UInt64",
      "description": "The maximum amount of data in bytes to read for automatic schema inference."
    },
    {
      "name": "input_format_max_rows_to_read_for_schema_inference",
      "type": "UInt64",
      "description": "The maximum rows of data to read for automatic schema inference."
    },
    {
      "name": "input_format_msgpack_number_of_columns",
      "type": "UInt64",
      "description": "The number of columns in inserted MsgPack data. Used for automatic schema inference from data."
    },
    {
      "name": "input_format_mysql_dump_map_column_names",
      "type": "Bool",
      "description": "Match columns from table in MySQL dump and columns from ClickHouse table by names"
    },
    {
      "name": "input_format_mysql_dump_table_name",
      "type": "String",
      "description": "Name of the table in MySQL dump from which to read data"
    },
    {
      "name": "input_format_native_allow_types_conversion",
      "type": "Bool",
      "description": "Allow data types conversion in Native input format"
    },
    {
      "name": "input_format_native_decode_types_in_binary_format",
      "type": "Bool",
      "description": "Read data types in binary format instead of type names in Native input format"
    },
    {
      "name": "input_format_null_as_default",
      "type": "Bool",
      "description": "Enables or disables the initialization of [NULL](/sql-reference/syntax#literals) fields with [default values](/sql-reference/statements/create/table#default_values), if data type of these fields is not [nullable](/sql-reference/data-types/nullable).\nIf column type is not nullable and this setting is disabled, then inserting `NULL` causes an exception. If column type is nullable, then `NULL` values are inserted as is, regardless of this setting.\n\nThis setting is applicable for most input formats.\n\nFor complex default expressions `input_format_defaults_for_omitted_fields` must be enabled too.\n\nPossible values:\n\n- 0 — Inserting `NULL` into a not nullable column causes an exception.\n- 1 — `NULL` fields are initialized with default column values."
    },
    {
      "name": "input_format_orc_allow_missing_columns",
      "type": "Bool",
      "description": "Allow missing columns while reading ORC input formats"
    },
    {
      "name": "input_format_orc_case_insensitive_column_matching",
      "type": "Bool",
      "description": "Ignore case when matching ORC columns with CH columns."
    },
    {
      "name": "input_format_orc_dictionary_as_low_cardinality",
      "type": "Bool",
      "description": "Treat ORC dictionary encoded columns as LowCardinality columns while reading ORC files."
    },
    {
      "name": "input_format_orc_filter_push_down",
      "type": "Bool",
      "description": "When reading ORC files, skip whole stripes or row groups based on the WHERE/PREWHERE expressions, min/max statistics or bloom filter in the ORC metadata."
    },
    {
      "name": "input_format_orc_import_nested",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "input_format_orc_reader_time_zone_name",
      "type": "String",
      "description": "The time zone name for ORC row reader, the default ORC row reader's time zone is GMT."
    },
    {
      "name": "input_format_orc_row_batch_size",
      "type": "Int64",
      "description": "Batch size when reading ORC stripes."
    },
    {
      "name": "input_format_orc_skip_columns_with_unsupported_types_in_schema_inference",
      "type": "Bool",
      "description": "Skip columns with unsupported types while schema inference for format ORC"
    },
    {
      "name": "input_format_orc_use_fast_decoder",
      "type": "Bool",
      "description": "Use a faster ORC decoder implementation."
    },
    {
      "name": "input_format_parallel_parsing",
      "type": "Bool",
      "description": "Enables or disables order-preserving parallel parsing of data formats. Supported only for [TSV](../../interfaces/formats.md/#tabseparated), [TSKV](../../interfaces/formats.md/#tskv), [CSV](../../interfaces/formats.md/#csv) and [JSONEachRow](../../interfaces/formats.md/#jsoneachrow) formats.\n\nPossible values:\n\n- 1 — Enabled.\n- 0 — Disabled."
    },
    {
      "name": "input_format_parquet_allow_geoparquet_parser",
      "type": "Bool",
      "description": "Use geo column parser to convert Array(UInt8) into Point/Linestring/Polygon/MultiLineString/MultiPolygon types"
    },
    {
      "name": "input_format_parquet_allow_missing_columns",
      "type": "Bool",
      "description": "Allow missing columns while reading Parquet input formats"
    },
    {
      "name": "input_format_parquet_bloom_filter_push_down",
      "type": "Bool",
      "description": "When reading Parquet files, skip whole row groups based on the WHERE expressions and bloom filter in the Parquet metadata."
    },
    {
      "name": "input_format_parquet_case_insensitive_column_matching",
      "type": "Bool",
      "description": "Ignore case when matching Parquet columns with CH columns."
    },
    {
      "name": "input_format_parquet_enable_json_parsing",
      "type": "Bool",
      "description": "  When reading Parquet files, parse JSON columns as ClickHouse JSON Column.\n  "
    },
    {
      "name": "input_format_parquet_enable_row_group_prefetch",
      "type": "Bool",
      "description": "Enable row group prefetching during parquet parsing. Currently, only single-threaded parsing can prefetch."
    },
    {
      "name": "input_format_parquet_filter_push_down",
      "type": "Bool",
      "description": "When reading Parquet files, skip whole row groups based on the WHERE/PREWHERE expressions and min/max statistics in the Parquet metadata."
    },
    {
      "name": "input_format_parquet_import_nested",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "input_format_parquet_local_file_min_bytes_for_seek",
      "type": "UInt64",
      "description": "Min bytes required for local read (file) to do seek, instead of read with ignore in Parquet input format"
    },
    {
      "name": "input_format_parquet_max_block_size",
      "type": "NonZeroUInt64",
      "description": "Max block size for parquet reader."
    },
    {
      "name": "input_format_parquet_prefer_block_bytes",
      "type": "UInt64",
      "description": "Average block bytes output by parquet reader"
    },
    {
      "name": "input_format_parquet_preserve_order",
      "type": "Bool",
      "description": "Avoid reordering rows when reading from Parquet files. Usually makes it much slower."
    },
    {
      "name": "input_format_parquet_skip_columns_with_unsupported_types_in_schema_inference",
      "type": "Bool",
      "description": "Skip columns with unsupported types while schema inference for format Parquet"
    },
    {
      "name": "input_format_parquet_use_native_reader",
      "type": "Bool",
      "description": "When reading Parquet files, to use native reader instead of arrow reader."
    },
    {
      "name": "input_format_protobuf_flatten_google_wrappers",
      "type": "Bool",
      "description": "Enable Google wrappers for regular non-nested columns, e.g. google.protobuf.StringValue 'str' for String column 'str'. For Nullable columns empty wrappers are recognized as defaults, and missing as nulls"
    },
    {
      "name": "input_format_protobuf_skip_fields_with_unsupported_types_in_schema_inference",
      "type": "Bool",
      "description": "Skip fields with unsupported types while schema inference for format Protobuf"
    },
    {
      "name": "input_format_record_errors_file_path",
      "type": "String",
      "description": "Path of the file used to record errors while reading text formats (CSV, TSV)."
    },
    {
      "name": "input_format_skip_unknown_fields",
      "type": "Bool",
      "description": "Enables or disables skipping insertion of extra data.\n\nWhen writing data, ClickHouse throws an exception if input data contain columns that do not exist in the target table. If skipping is enabled, ClickHouse does not insert extra data and does not throw an exception.\n\nSupported formats:\n\n- [JSONEachRow](/interfaces/formats/JSONEachRow) (and other JSON formats)\n- [BSONEachRow](/interfaces/formats/BSONEachRow) (and other JSON formats)\n- [TSKV](/interfaces/formats/TSKV)\n- All formats with suffixes WithNames/WithNamesAndTypes\n- [MySQLDump](/interfaces/formats/MySQLDump)\n- [Native](/interfaces/formats/Native)\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "input_format_try_infer_dates",
      "type": "Bool",
      "description": "If enabled, ClickHouse will try to infer type `Date` from string fields in schema inference for text formats. If all fields from a column in input data were successfully parsed as dates, the result type will be `Date`, if at least one field was not parsed as date, the result type will be `String`.\n\nEnabled by default."
    },
    {
      "name": "input_format_try_infer_datetimes",
      "type": "Bool",
      "description": "If enabled, ClickHouse will try to infer type `DateTime64` from string fields in schema inference for text formats. If all fields from a column in input data were successfully parsed as datetimes, the result type will be `DateTime64`, if at least one field was not parsed as datetime, the result type will be `String`.\n\nEnabled by default."
    },
    {
      "name": "input_format_try_infer_datetimes_only_datetime64",
      "type": "Bool",
      "description": "When input_format_try_infer_datetimes is enabled, infer only DateTime64 but not DateTime types"
    },
    {
      "name": "input_format_try_infer_exponent_floats",
      "type": "Bool",
      "description": "Try to infer floats in exponential notation while schema inference in text formats (except JSON, where exponent numbers are always inferred)"
    },
    {
      "name": "input_format_try_infer_integers",
      "type": "Bool",
      "description": "If enabled, ClickHouse will try to infer integers instead of floats in schema inference for text formats. If all numbers in the column from input data are integers, the result type will be `Int64`, if at least one number is float, the result type will be `Float64`.\n\nEnabled by default."
    },
    {
      "name": "input_format_try_infer_variants",
      "type": "Bool",
      "description": "If enabled, ClickHouse will try to infer type [`Variant`](../../sql-reference/data-types/variant.md) in schema inference for text formats when there is more than one possible type for column/array elements.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "input_format_tsv_allow_variable_number_of_columns",
      "type": "Bool",
      "description": "Ignore extra columns in TSV input (if file has more columns than expected) and treat missing fields in TSV input as default values"
    },
    {
      "name": "input_format_tsv_crlf_end_of_line",
      "type": "Bool",
      "description": "If it is set true, file function will read TSV format with \\\\r\\\\n instead of \\\\n."
    },
    {
      "name": "input_format_tsv_detect_header",
      "type": "Bool",
      "description": "Automatically detect header with names and types in TSV format"
    },
    {
      "name": "input_format_tsv_empty_as_default",
      "type": "Bool",
      "description": "Treat empty fields in TSV input as default values."
    },
    {
      "name": "input_format_tsv_enum_as_number",
      "type": "Bool",
      "description": "Treat inserted enum values in TSV formats as enum indices."
    },
    {
      "name": "input_format_tsv_skip_first_lines",
      "type": "UInt64",
      "description": "Skip specified number of lines at the beginning of data in TSV format"
    },
    {
      "name": "input_format_tsv_skip_trailing_empty_lines",
      "type": "Bool",
      "description": "Skip trailing empty lines in TSV format"
    },
    {
      "name": "input_format_tsv_use_best_effort_in_schema_inference",
      "type": "Bool",
      "description": "Use some tweaks and heuristics to infer schema in TSV format"
    },
    {
      "name": "input_format_values_accurate_types_of_literals",
      "type": "Bool",
      "description": "For Values format: when parsing and interpreting expressions using template, check actual type of literal to avoid possible overflow and precision issues."
    },
    {
      "name": "input_format_values_deduce_templates_of_expressions",
      "type": "Bool",
      "description": "For Values format: if the field could not be parsed by streaming parser, run SQL parser, deduce template of the SQL expression, try to parse all rows using template and then interpret expression for all rows."
    },
    {
      "name": "input_format_values_interpret_expressions",
      "type": "Bool",
      "description": "For Values format: if the field could not be parsed by streaming parser, run SQL parser and try to interpret it as SQL expression."
    },
    {
      "name": "input_format_with_names_use_header",
      "type": "Bool",
      "description": "Enables or disables checking the column order when inserting data.\n\nTo improve insert performance, we recommend disabling this check if you are sure that the column order of the input data is the same as in the target table.\n\nSupported formats:\n\n- [CSVWithNames](/interfaces/formats/CSVWithNames)\n- [CSVWithNamesAndTypes](/interfaces/formats/CSVWithNamesAndTypes)\n- [TabSeparatedWithNames](/interfaces/formats/TabSeparatedWithNames)\n- [TabSeparatedWithNamesAndTypes](/interfaces/formats/TabSeparatedWithNamesAndTypes)\n- [JSONCompactEachRowWithNames](/interfaces/formats/JSONCompactEachRowWithNames)\n- [JSONCompactEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactEachRowWithNamesAndTypes)\n- [JSONCompactStringsEachRowWithNames](/interfaces/formats/JSONCompactStringsEachRowWithNames)\n- [JSONCompactStringsEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactStringsEachRowWithNamesAndTypes)\n- [RowBinaryWithNames](/interfaces/formats/RowBinaryWithNames)\n- [RowBinaryWithNamesAndTypes](/interfaces/formats/RowBinaryWithNamesAndTypes)\n- [CustomSeparatedWithNames](/interfaces/formats/CustomSeparatedWithNames)\n- [CustomSeparatedWithNamesAndTypes](/interfaces/formats/CustomSeparatedWithNamesAndTypes)\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "input_format_with_types_use_header",
      "type": "Bool",
      "description": "Controls whether format parser should check if data types from the input data match data types from the target table.\n\nSupported formats:\n\n- [CSVWithNamesAndTypes](/interfaces/formats/CSVWithNamesAndTypes)\n- [TabSeparatedWithNamesAndTypes](/interfaces/formats/TabSeparatedWithNamesAndTypes)\n- [JSONCompactEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactEachRowWithNamesAndTypes)\n- [JSONCompactStringsEachRowWithNamesAndTypes](/interfaces/formats/JSONCompactStringsEachRowWithNamesAndTypes)\n- [RowBinaryWithNamesAndTypes](/interfaces/formats/RowBinaryWithNamesAndTypes)\n- [CustomSeparatedWithNamesAndTypes](/interfaces/formats/CustomSeparatedWithNamesAndTypes)\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "insert_allow_materialized_columns",
      "type": "Bool",
      "description": "If setting is enabled, Allow materialized columns in INSERT."
    },
    {
      "name": "insert_deduplicate",
      "type": "Bool",
      "description": "Enables or disables block deduplication of `INSERT` (for Replicated\\* tables).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nBy default, blocks inserted into replicated tables by the `INSERT` statement are deduplicated (see [Data Replication](../../engines/table-engines/mergetree-family/replication.md)).\nFor the replicated tables by default the only 100 of the most recent blocks for each partition are deduplicated (see [replicated_deduplication_window](merge-tree-settings.md/#replicated_deduplication_window), [replicated_deduplication_window_seconds](merge-tree-settings.md/#replicated_deduplication_window_seconds)).\nFor not replicated tables see [non_replicated_deduplication_window](merge-tree-settings.md/#non_replicated_deduplication_window)."
    },
    {
      "name": "insert_deduplication_token",
      "type": "String",
      "description": "The setting allows a user to provide own deduplication semantic in MergeTree/ReplicatedMergeTree\nFor example, by providing a unique value for the setting in each INSERT statement,\nuser can avoid the same inserted data being deduplicated.\n\n\nPossible values:\n\n- Any string\n\n`insert_deduplication_token` is used for deduplication _only_ when not empty.\n\nFor the replicated tables by default the only 100 of the most recent inserts for each partition are deduplicated (see [replicated_deduplication_window](merge-tree-settings.md/#replicated_deduplication_window), [replicated_deduplication_window_seconds](merge-tree-settings.md/#replicated_deduplication_window_seconds)).\nFor not replicated tables see [non_replicated_deduplication_window](merge-tree-settings.md/#non_replicated_deduplication_window).\n\n:::note\n`insert_deduplication_token` works on a partition level (the same as `insert_deduplication` checksum). Multiple partitions can have the same `insert_deduplication_token`.\n:::\n\nExample:\n\n```sql\nCREATE TABLE test_table\n( A Int64 )\nENGINE = MergeTree\nORDER BY A\nSETTINGS non_replicated_deduplication_window = 100;\n\nINSERT INTO test_table SETTINGS insert_deduplication_token = 'test' VALUES (1);\n\n-- the next insert won't be deduplicated because insert_deduplication_token is different\nINSERT INTO test_table SETTINGS insert_deduplication_token = 'test1' VALUES (1);\n\n-- the next insert will be deduplicated because insert_deduplication_token\n-- is the same as one of the previous\nINSERT INTO test_table SETTINGS insert_deduplication_token = 'test' VALUES (2);\n\nSELECT * FROM test_table\n\n┌─A─┐\n│ 1 │\n└───┘\n┌─A─┐\n│ 1 │\n└───┘\n```"
    },
    {
      "name": "insert_distributed_one_random_shard",
      "type": "Bool",
      "description": "Enables or disables random shard insertion into a [Distributed](/engines/table-engines/special/distributed) table when there is no distributed key.\n\nBy default, when inserting data into a `Distributed` table with more than one shard, the ClickHouse server will reject any insertion request if there is no distributed key. When `insert_distributed_one_random_shard = 1`, insertions are allowed and data is forwarded randomly among all shards.\n\nPossible values:\n\n- 0 — Insertion is rejected if there are multiple shards and no distributed key is given.\n- 1 — Insertion is done randomly among all available shards when no distributed key is given."
    },
    {
      "name": "insert_distributed_sync",
      "type": "Bool",
      "description": "Enables or disables synchronous data insertion into a [Distributed](/engines/table-engines/special/distributed) table.\n\nBy default, when inserting data into a `Distributed` table, the ClickHouse server sends data to cluster nodes in background mode. When `distributed_foreground_insert=1`, the data is processed synchronously, and the `INSERT` operation succeeds only after all the data is saved on all shards (at least one replica for each shard if `internal_replication` is true).\n\nPossible values:\n\n- 0 — Data is inserted in background mode.\n- 1 — Data is inserted in synchronous mode.\n\nCloud default value: `1`.\n\n**See Also**\n\n- [Distributed Table Engine](/engines/table-engines/special/distributed)\n- [Managing Distributed Tables](/sql-reference/statements/system#managing-distributed-tables)"
    },
    {
      "name": "insert_distributed_timeout",
      "type": "UInt64",
      "description": "Timeout for insert query into distributed. Setting is used only with insert_distributed_sync enabled. Zero value means no timeout."
    },
    {
      "name": "insert_keeper_fault_injection_probability",
      "type": "Float",
      "description": "Approximate probability of failure for a keeper request during insert. Valid value is in interval [0.0f, 1.0f]"
    },
    {
      "name": "insert_keeper_fault_injection_seed",
      "type": "UInt64",
      "description": "0 - random seed, otherwise the setting value"
    },
    {
      "name": "insert_keeper_max_retries",
      "type": "UInt64",
      "description": "The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.\n\nPossible values:\n\n- Positive integer.\n- 0 — Retries are disabled\n\nCloud default value: `20`.\n\nKeeper request retries are done after some timeout. The timeout is controlled by the following settings: `insert_keeper_retry_initial_backoff_ms`, `insert_keeper_retry_max_backoff_ms`.\nThe first retry is done after `insert_keeper_retry_initial_backoff_ms` timeout. The consequent timeouts will be calculated as follows:\n```\ntimeout = min(insert_keeper_retry_max_backoff_ms, latest_timeout * 2)\n```\n\nFor example, if `insert_keeper_retry_initial_backoff_ms=100`, `insert_keeper_retry_max_backoff_ms=10000` and `insert_keeper_max_retries=8` then timeouts will be `100, 200, 400, 800, 1600, 3200, 6400, 10000`.\n\nApart from fault tolerance, the retries aim to provide a better user experience - they allow to avoid returning an error during INSERT execution if Keeper is restarted, for example, due to an upgrade."
    },
    {
      "name": "insert_keeper_retry_initial_backoff_ms",
      "type": "UInt64",
      "description": "Initial timeout(in milliseconds) to retry a failed Keeper request during INSERT query execution\n\nPossible values:\n\n- Positive integer.\n- 0 — No timeout"
    },
    {
      "name": "insert_keeper_retry_max_backoff_ms",
      "type": "UInt64",
      "description": "Maximum timeout (in milliseconds) to retry a failed Keeper request during INSERT query execution\n\nPossible values:\n\n- Positive integer.\n- 0 — Maximum timeout is not limited"
    },
    {
      "name": "insert_null_as_default",
      "type": "Bool",
      "description": "Enables or disables the insertion of [default values](/sql-reference/statements/create/table#default_values) instead of [NULL](/sql-reference/syntax#null) into columns with not [nullable](/sql-reference/data-types/nullable) data type.\nIf column type is not nullable and this setting is disabled, then inserting `NULL` causes an exception. If column type is nullable, then `NULL` values are inserted as is, regardless of this setting.\n\nThis setting is applicable to [INSERT ... SELECT](../../sql-reference/statements/insert-into.md/#inserting-the-results-of-select) queries. Note that `SELECT` subqueries may be concatenated with `UNION ALL` clause.\n\nPossible values:\n\n- 0 — Inserting `NULL` into a not nullable column causes an exception.\n- 1 — Default column value is inserted instead of `NULL`."
    },
    {
      "name": "insert_quorum",
      "type": "UInt64Auto",
      "description": ":::note\nThis setting is not applicable to SharedMergeTree, see [SharedMergeTree consistency](/cloud/reference/shared-merge-tree#consistency) for more information.\n:::\n\nEnables the quorum writes.\n\n- If `insert_quorum < 2`, the quorum writes are disabled.\n- If `insert_quorum >= 2`, the quorum writes are enabled.\n- If `insert_quorum = 'auto'`, use majority number (`number_of_replicas / 2 + 1`) as quorum number.\n\nQuorum writes\n\n`INSERT` succeeds only when ClickHouse manages to correctly write data to the `insert_quorum` of replicas during the `insert_quorum_timeout`. If for any reason the number of replicas with successful writes does not reach the `insert_quorum`, the write is considered failed and ClickHouse will delete the inserted block from all the replicas where data has already been written.\n\nWhen `insert_quorum_parallel` is disabled, all replicas in the quorum are consistent, i.e. they contain data from all previous `INSERT` queries (the `INSERT` sequence is linearized). When reading data written using `insert_quorum` and `insert_quorum_parallel` is disabled, you can turn on sequential consistency for `SELECT` queries using [select_sequential_consistency](#select_sequential_consistency).\n\nClickHouse generates an exception:\n\n- If the number of available replicas at the time of the query is less than the `insert_quorum`.\n- When `insert_quorum_parallel` is disabled and an attempt to write data is made when the previous block has not yet been inserted in `insert_quorum` of replicas. This situation may occur if the user tries to perform another `INSERT` query to the same table before the previous one with `insert_quorum` is completed.\n\nSee also:\n\n- [insert_quorum_timeout](#insert_quorum_timeout)\n- [insert_quorum_parallel](#insert_quorum_parallel)\n- [select_sequential_consistency](#select_sequential_consistency)"
    },
    {
      "name": "insert_quorum_parallel",
      "type": "Bool",
      "description": ":::note\nThis setting is not applicable to SharedMergeTree, see [SharedMergeTree consistency](/cloud/reference/shared-merge-tree#consistency) for more information.\n:::\n\nEnables or disables parallelism for quorum `INSERT` queries. If enabled, additional `INSERT` queries can be sent while previous queries have not yet finished. If disabled, additional writes to the same table will be rejected.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nSee also:\n\n- [insert_quorum](#insert_quorum)\n- [insert_quorum_timeout](#insert_quorum_timeout)\n- [select_sequential_consistency](#select_sequential_consistency)"
    },
    {
      "name": "insert_quorum_timeout",
      "type": "Milliseconds",
      "description": "Write to a quorum timeout in milliseconds. If the timeout has passed and no write has taken place yet, ClickHouse will generate an exception and the client must repeat the query to write the same block to the same or any other replica.\n\nSee also:\n\n- [insert_quorum](#insert_quorum)\n- [insert_quorum_parallel](#insert_quorum_parallel)\n- [select_sequential_consistency](#select_sequential_consistency)"
    },
    {
      "name": "insert_shard_id",
      "type": "UInt64",
      "description": "If not `0`, specifies the shard of [Distributed](/engines/table-engines/special/distributed) table into which the data will be inserted synchronously.\n\nIf `insert_shard_id` value is incorrect, the server will throw an exception.\n\nTo get the number of shards on `requested_cluster`, you can check server config or use this query:\n\n```sql\nSELECT uniq(shard_num) FROM system.clusters WHERE cluster = 'requested_cluster';\n```\n\nPossible values:\n\n- 0 — Disabled.\n- Any number from `1` to `shards_num` of corresponding [Distributed](/engines/table-engines/special/distributed) table.\n\n**Example**\n\nQuery:\n\n```sql\nCREATE TABLE x AS system.numbers ENGINE = MergeTree ORDER BY number;\nCREATE TABLE x_dist AS x ENGINE = Distributed('test_cluster_two_shards_localhost', currentDatabase(), x);\nINSERT INTO x_dist SELECT * FROM numbers(5) SETTINGS insert_shard_id = 1;\nSELECT * FROM x_dist ORDER BY number ASC;\n```\n\nResult:\n\n```text\n┌─number─┐\n│      0 │\n│      0 │\n│      1 │\n│      1 │\n│      2 │\n│      2 │\n│      3 │\n│      3 │\n│      4 │\n│      4 │\n└────────┘\n```"
    },
    {
      "name": "interactive_delay",
      "type": "UInt64",
      "description": "The interval in microseconds for checking whether request execution has been canceled and sending the progress."
    },
    {
      "name": "intersect_default_mode",
      "type": "SetOperationMode",
      "description": "Set default mode in INTERSECT query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception."
    },
    {
      "name": "interval_output_format",
      "type": "IntervalOutputFormat",
      "description": "Allows choosing different output formats of the text representation of interval types.\n\nPossible values:\n\n-   `kusto` - KQL-style output format.\n\n    ClickHouse outputs intervals in [KQL format](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-timespan-format-strings#the-constant-c-format-specifier). For example, `toIntervalDay(2)` would be formatted as `2.00:00:00`. Please note that for interval types of varying length (ie. `IntervalMonth` and `IntervalYear`) the average number of seconds per interval is taken into account.\n\n-   `numeric` - Numeric output format.\n\n    ClickHouse outputs intervals as their underlying numeric representation. For example, `toIntervalDay(2)` would be formatted as `2`.\n\nSee also:\n\n-   [Interval](../../sql-reference/data-types/special-data-types/interval.md)"
    },
    {
      "name": "join_algorithm",
      "type": "JoinAlgorithm",
      "description": "Specifies which [JOIN](../../sql-reference/statements/select/join.md) algorithm is used.\n\nSeveral algorithms can be specified, and an available one would be chosen for a particular query based on kind/strictness and table engine.\n\nPossible values:\n\n- grace_hash\n\n [Grace hash join](https://en.wikipedia.org/wiki/Hash_join#Grace_hash_join) is used.  Grace hash provides an algorithm option that provides performant complex joins while limiting memory use.\n\n The first phase of a grace join reads the right table and splits it into N buckets depending on the hash value of key columns (initially, N is `grace_hash_join_initial_buckets`). This is done in a way to ensure that each bucket can be processed independently. Rows from the first bucket are added to an in-memory hash table while the others are saved to disk. If the hash table grows beyond the memory limit (e.g., as set by [`max_bytes_in_join`](/operations/settings/settings#max_bytes_in_join), the number of buckets is increased and the assigned bucket for each row. Any rows which don't belong to the current bucket are flushed and reassigned.\n\n Supports `INNER/LEFT/RIGHT/FULL ALL/ANY JOIN`.\n\n- hash\n\n [Hash join algorithm](https://en.wikipedia.org/wiki/Hash_join) is used. The most generic implementation that supports all combinations of kind and strictness and multiple join keys that are combined with `OR` in the `JOIN ON` section.\n\n When using the `hash` algorithm, the right part of `JOIN` is uploaded into RAM.\n\n- parallel_hash\n\n A variation of `hash` join that splits the data into buckets and builds several hashtables instead of one concurrently to speed up this process.\n\n When using the `parallel_hash` algorithm, the right part of `JOIN` is uploaded into RAM.\n\n- partial_merge\n\n A variation of the [sort-merge algorithm](https://en.wikipedia.org/wiki/Sort-merge_join), where only the right table is fully sorted.\n\n The `RIGHT JOIN` and `FULL JOIN` are supported only with `ALL` strictness (`SEMI`, `ANTI`, `ANY`, and `ASOF` are not supported).\n\n When using the `partial_merge` algorithm, ClickHouse sorts the data and dumps it to the disk. The `partial_merge` algorithm in ClickHouse differs slightly from the classic realization. First, ClickHouse sorts the right table by joining keys in blocks and creates a min-max index for sorted blocks. Then it sorts parts of the left table by the `join key` and joins them over the right table. The min-max index is also used to skip unneeded right table blocks.\n\n- direct\n\n This algorithm can be applied when the storage for the right table supports key-value requests.\n\n The `direct` algorithm performs a lookup in the right table using rows from the left table as keys. It's supported only by special storage such as [Dictionary](/engines/table-engines/special/dictionary) or [EmbeddedRocksDB](../../engines/table-engines/integrations/embedded-rocksdb.md) and only the `LEFT` and `INNER` JOINs.\n\n- auto\n\n When set to `auto`, `hash` join is tried first, and the algorithm is switched on the fly to another algorithm if the memory limit is violated.\n\n- full_sorting_merge\n\n [Sort-merge algorithm](https://en.wikipedia.org/wiki/Sort-merge_join) with full sorting joined tables before joining.\n\n- prefer_partial_merge\n\n ClickHouse always tries to use `partial_merge` join if possible, otherwise, it uses `hash`. *Deprecated*, same as `partial_merge,hash`.\n\n- default (deprecated)\n\n Legacy value, please don't use anymore.\n Same as `direct,hash`, i.e. try to use direct join and hash join join (in this order).\n"
    },
    {
      "name": "join_any_take_last_row",
      "type": "Bool",
      "description": "Changes the behaviour of join operations with `ANY` strictness.\n\n:::note\nThis setting applies only for `JOIN` operations with [Join](../../engines/table-engines/special/join.md) engine tables.\n:::\n\nPossible values:\n\n- 0 — If the right table has more than one matching row, only the first one found is joined.\n- 1 — If the right table has more than one matching row, only the last one found is joined.\n\nSee also:\n\n- [JOIN clause](/sql-reference/statements/select/join)\n- [Join table engine](../../engines/table-engines/special/join.md)\n- [join_default_strictness](#join_default_strictness)"
    },
    {
      "name": "join_default_strictness",
      "type": "JoinStrictness",
      "description": "Sets default strictness for [JOIN clauses](/sql-reference/statements/select/join).\n\nPossible values:\n\n- `ALL` — If the right table has several matching rows, ClickHouse creates a [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) from matching rows. This is the normal `JOIN` behaviour from standard SQL.\n- `ANY` — If the right table has several matching rows, only the first one found is joined. If the right table has only one matching row, the results of `ANY` and `ALL` are the same.\n- `ASOF` — For joining sequences with an uncertain match.\n- `Empty string` — If `ALL` or `ANY` is not specified in the query, ClickHouse throws an exception."
    },
    {
      "name": "join_on_disk_max_files_to_merge",
      "type": "UInt64",
      "description": "Limits the number of files allowed for parallel sorting in MergeJoin operations when they are executed on disk.\n\nThe bigger the value of the setting, the more RAM is used and the less disk I/O is needed.\n\nPossible values:\n\n- Any positive integer, starting from 2."
    },
    {
      "name": "join_output_by_rowlist_perkey_rows_threshold",
      "type": "UInt64",
      "description": "The lower limit of per-key average rows in the right table to determine whether to output by row list in hash join."
    },
    {
      "name": "join_overflow_mode",
      "type": "OverflowMode",
      "description": "Defines what action ClickHouse performs when any of the following join limits is reached:\n\n- [max_bytes_in_join](/operations/settings/settings#max_bytes_in_join)\n- [max_rows_in_join](/operations/settings/settings#max_rows_in_join)\n\nPossible values:\n\n- `THROW` — ClickHouse throws an exception and breaks operation.\n- `BREAK` — ClickHouse breaks operation and does not throw an exception.\n\nDefault value: `THROW`.\n\n**See Also**\n\n- [JOIN clause](/sql-reference/statements/select/join)\n- [Join table engine](/engines/table-engines/special/join)"
    },
    {
      "name": "join_to_sort_maximum_table_rows",
      "type": "UInt64",
      "description": "The maximum number of rows in the right table to determine whether to rerange the right table by key in left or inner join."
    },
    {
      "name": "join_to_sort_minimum_perkey_rows",
      "type": "UInt64",
      "description": "The lower limit of per-key average rows in the right table to determine whether to rerange the right table by key in left or inner join. This setting ensures that the optimization is not applied for sparse table keys"
    },
    {
      "name": "join_use_nulls",
      "type": "Bool",
      "description": "Sets the type of [JOIN](../../sql-reference/statements/select/join.md) behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.\n\nPossible values:\n\n- 0 — The empty cells are filled with the default value of the corresponding field type.\n- 1 — `JOIN` behaves the same way as in standard SQL. The type of the corresponding field is converted to [Nullable](/sql-reference/data-types/nullable), and empty cells are filled with [NULL](/sql-reference/syntax)."
    },
    {
      "name": "joined_subquery_requires_alias",
      "type": "Bool",
      "description": "Force joined subqueries and table functions to have aliases for correct name qualification."
    },
    {
      "name": "kafka_disable_num_consumers_limit",
      "type": "Bool",
      "description": "Disable limit on kafka_num_consumers that depends on the number of available CPU cores."
    },
    {
      "name": "kafka_max_wait_ms",
      "type": "Milliseconds",
      "description": "The wait time in milliseconds for reading messages from [Kafka](/engines/table-engines/integrations/kafka) before retry.\n\nPossible values:\n\n- Positive integer.\n- 0 — Infinite timeout.\n\nSee also:\n\n- [Apache Kafka](https://kafka.apache.org/)"
    },
    {
      "name": "keeper_map_strict_mode",
      "type": "Bool",
      "description": "Enforce additional checks during operations on KeeperMap. E.g. throw an exception on an insert for already existing key"
    },
    {
      "name": "keeper_max_retries",
      "type": "UInt64",
      "description": "Max retries for general keeper operations"
    },
    {
      "name": "keeper_retry_initial_backoff_ms",
      "type": "UInt64",
      "description": "Initial backoff timeout for general keeper operations"
    },
    {
      "name": "keeper_retry_max_backoff_ms",
      "type": "UInt64",
      "description": "Max backoff timeout for general keeper operations"
    },
    {
      "name": "least_greatest_legacy_null_behavior",
      "type": "Bool",
      "description": "If enabled, functions 'least' and 'greatest' return NULL if one of their arguments is NULL."
    },
    {
      "name": "legacy_column_name_of_tuple_literal",
      "type": "Bool",
      "description": "List all names of element of large tuple literals in their column names instead of hash. This settings exists only for compatibility reasons. It makes sense to set to 'true', while doing rolling update of cluster from version lower than 21.7 to higher."
    },
    {
      "name": "lightweight_delete_mode",
      "type": "LightweightDeleteMode",
      "description": "A mode of internal update query that is executed as a part of lightweight delete.\n\nPossible values:\n- `alter_update` - run `ALTER UPDATE` query that creates a heavyweight mutation.\n- `lightweight_update` - run lightweight update if possible, run `ALTER UPDATE` otherwise.\n- `lightweight_update_force` - run lightweight update if possible, throw otherwise."
    },
    {
      "name": "lightweight_deletes_sync",
      "type": "UInt64",
      "description": "The same as [`mutations_sync`](#mutations_sync), but controls only execution of lightweight deletes.\n\nPossible values:\n\n- 0 - Mutations execute asynchronously.\n- 1 - The query waits for the lightweight deletes to complete on the current server.\n- 2 - The query waits for the lightweight deletes to complete on all replicas (if they exist).\n\n**See Also**\n\n- [Synchronicity of ALTER Queries](../../sql-reference/statements/alter/index.md/#synchronicity-of-alter-queries)\n- [Mutations](../../sql-reference/statements/alter/index.md/#mutations)"
    },
    {
      "name": "lightweight_mutation_projection_mode",
      "type": "LightweightMutationProjectionMode",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "limit",
      "type": "UInt64",
      "description": "Sets the maximum number of rows to get from the query result. It adjusts the value set by the [LIMIT](/sql-reference/statements/select/limit) clause, so that the limit, specified in the query, cannot exceed the limit, set by this setting.\n\nPossible values:\n\n- 0 — The number of rows is not limited.\n- Positive integer."
    },
    {
      "name": "live_view_heartbeat_interval",
      "type": "Seconds",
      "description": "The heartbeat interval in seconds to indicate live query is alive."
    },
    {
      "name": "load_balancing",
      "type": "LoadBalancing",
      "description": "Specifies the algorithm of replicas selection that is used for distributed query processing.\n\nClickHouse supports the following algorithms of choosing replicas:\n\n- [Random](#load_balancing-random) (by default)\n- [Nearest hostname](#load_balancing-nearest_hostname)\n- [Hostname levenshtein distance](#load_balancing-hostname_levenshtein_distance)\n- [In order](#load_balancing-in_order)\n- [First or random](#load_balancing-first_or_random)\n- [Round robin](#load_balancing-round_robin)\n\nSee also:\n\n- [distributed_replica_max_ignored_errors](#distributed_replica_max_ignored_errors)\n\n### Random (by Default) {#load_balancing-random}\n\n```sql\nload_balancing = random\n```\n\nThe number of errors is counted for each replica. The query is sent to the replica with the fewest errors, and if there are several of these, to anyone of them.\nDisadvantages: Server proximity is not accounted for; if the replicas have different data, you will also get different data.\n\n### Nearest Hostname {#load_balancing-nearest_hostname}\n\n```sql\nload_balancing = nearest_hostname\n```\n\nThe number of errors is counted for each replica. Every 5 minutes, the number of errors is integrally divided by 2. Thus, the number of errors is calculated for a recent time with exponential smoothing. If there is one replica with a minimal number of errors (i.e. errors occurred recently on the other replicas), the query is sent to it. If there are multiple replicas with the same minimal number of errors, the query is sent to the replica with a hostname that is most similar to the server's hostname in the config file (for the number of different characters in identical positions, up to the minimum length of both hostnames).\n\nFor instance, example01-01-1 and example01-01-2 are different in one position, while example01-01-1 and example01-02-2 differ in two places.\nThis method might seem primitive, but it does not require external data about network topology, and it does not compare IP addresses, which would be complicated for our IPv6 addresses.\n\nThus, if there are equivalent replicas, the closest one by name is preferred.\nWe can also assume that when sending a query to the same server, in the absence of failures, a distributed query will also go to the same servers. So even if different data is placed on the replicas, the query will return mostly the same results.\n\n### Hostname levenshtein distance {#load_balancing-hostname_levenshtein_distance}\n\n```sql\nload_balancing = hostname_levenshtein_distance\n```\n\nJust like `nearest_hostname`, but it compares hostname in a [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) manner. For example:\n\n```text\nexample-clickhouse-0-0 ample-clickhouse-0-0\n1\n\nexample-clickhouse-0-0 example-clickhouse-1-10\n2\n\nexample-clickhouse-0-0 example-clickhouse-12-0\n3\n```\n\n### In Order {#load_balancing-in_order}\n\n```sql\nload_balancing = in_order\n```\n\nReplicas with the same number of errors are accessed in the same order as they are specified in the configuration.\nThis method is appropriate when you know exactly which replica is preferable.\n\n### First or Random {#load_balancing-first_or_random}\n\n```sql\nload_balancing = first_or_random\n```\n\nThis algorithm chooses the first replica in the set or a random replica if the first is unavailable. It's effective in cross-replication topology setups, but useless in other configurations.\n\nThe `first_or_random` algorithm solves the problem of the `in_order` algorithm. With `in_order`, if one replica goes down, the next one gets a double load while the remaining replicas handle the usual amount of traffic. When using the `first_or_random` algorithm, the load is evenly distributed among replicas that are still available.\n\nIt's possible to explicitly define what the first replica is by using the setting `load_balancing_first_offset`. This gives more control to rebalance query workloads among replicas.\n\n### Round Robin {#load_balancing-round_robin}\n\n```sql\nload_balancing = round_robin\n```\n\nThis algorithm uses a round-robin policy across replicas with the same number of errors (only the queries with `round_robin` policy is accounted)."
    },
    {
      "name": "load_balancing_first_offset",
      "type": "UInt64",
      "description": "Which replica to preferably send a query when FIRST_OR_RANDOM load balancing strategy is used."
    },
    {
      "name": "load_marks_asynchronously",
      "type": "Bool",
      "description": "Load MergeTree marks asynchronously"
    },
    {
      "name": "local_filesystem_read_method",
      "type": "String",
      "description": "Method of reading data from local filesystem, one of: read, pread, mmap, io_uring, pread_threadpool.\n\nThe 'io_uring' method is experimental and does not work for Log, TinyLog, StripeLog, File, Set and Join, and other tables with append-able files in presence of concurrent reads and writes.\nIf you read various articles about 'io_uring' on the Internet, don't be blinded by them. It is not a better method of reading files, unless the case of a large amount of small IO requests, which is not the case in ClickHouse. There are no reasons to enable 'io_uring'."
    },
    {
      "name": "local_filesystem_read_prefetch",
      "type": "Bool",
      "description": "Should use prefetching when reading data from local filesystem."
    },
    {
      "name": "lock_acquire_timeout",
      "type": "Seconds",
      "description": "Defines how many seconds a locking request waits before failing.\n\nLocking timeout is used to protect from deadlocks while executing read/write operations with tables. When the timeout expires and the locking request fails, the ClickHouse server throws an exception \"Locking attempt timed out! Possible deadlock avoided. Client should retry.\" with error code `DEADLOCK_AVOIDED`.\n\nPossible values:\n\n- Positive integer (in seconds).\n- 0 — No locking timeout."
    },
    {
      "name": "log_comment",
      "type": "String",
      "description": "Specifies the value for the `log_comment` field of the [system.query_log](../system-tables/query_log.md) table and comment text for the server log.\n\nIt can be used to improve the readability of server logs. Additionally, it helps to select queries related to the test from the `system.query_log` after running [clickhouse-test](../../development/tests.md).\n\nPossible values:\n\n- Any string no longer than [max_query_size](#max_query_size). If the max_query_size is exceeded, the server throws an exception.\n\n**Example**\n\nQuery:\n\n```sql\nSET log_comment = 'log_comment test', log_queries = 1;\nSELECT 1;\nSYSTEM FLUSH LOGS;\nSELECT type, query FROM system.query_log WHERE log_comment = 'log_comment test' AND event_date >= yesterday() ORDER BY event_time DESC LIMIT 2;\n```\n\nResult:\n\n```text\n┌─type────────┬─query─────┐\n│ QueryStart  │ SELECT 1; │\n│ QueryFinish │ SELECT 1; │\n└─────────────┴───────────┘\n```"
    },
    {
      "name": "log_formatted_queries",
      "type": "Bool",
      "description": "Allows to log formatted queries to the [system.query_log](../../operations/system-tables/query_log.md) system table (populates `formatted_query` column in the [system.query_log](../../operations/system-tables/query_log.md)).\n\nPossible values:\n\n- 0 — Formatted queries are not logged in the system table.\n- 1 — Formatted queries are logged in the system table."
    },
    {
      "name": "log_processors_profiles",
      "type": "Bool",
      "description": "Write time that processor spent during execution/waiting for data to `system.processors_profile_log` table.\n\nSee also:\n\n- [`system.processors_profile_log`](../../operations/system-tables/processors_profile_log.md)\n- [`EXPLAIN PIPELINE`](../../sql-reference/statements/explain.md/#explain-pipeline)"
    },
    {
      "name": "log_profile_events",
      "type": "Bool",
      "description": "Log query performance statistics into the query_log, query_thread_log and query_views_log."
    },
    {
      "name": "log_queries",
      "type": "Bool",
      "description": "Setting up query logging.\n\nQueries sent to ClickHouse with this setup are logged according to the rules in the [query_log](../../operations/server-configuration-parameters/settings.md/#query_log) server configuration parameter.\n\nExample:\n\n```text\nlog_queries=1\n```"
    },
    {
      "name": "log_queries_cut_to_length",
      "type": "UInt64",
      "description": "If query length is greater than a specified threshold (in bytes), then cut query when writing to query log. Also limit the length of printed query in ordinary text log."
    },
    {
      "name": "log_queries_min_query_duration_ms",
      "type": "Milliseconds",
      "description": "If enabled (non-zero), queries faster than the value of this setting will not be logged (you can think about this as a `long_query_time` for [MySQL Slow Query Log](https://dev.mysql.com/doc/refman/5.7/slow-query-log.html)), and this basically means that you will not find them in the following tables:\n\n- `system.query_log`\n- `system.query_thread_log`\n\nOnly the queries with the following type will get to the log:\n\n- `QUERY_FINISH`\n- `EXCEPTION_WHILE_PROCESSING`\n\n- Type: milliseconds\n- Default value: 0 (any query)"
    },
    {
      "name": "log_queries_min_type",
      "type": "LogQueriesType",
      "description": "`query_log` minimal type to log.\n\nPossible values:\n- `QUERY_START` (`=1`)\n- `QUERY_FINISH` (`=2`)\n- `EXCEPTION_BEFORE_START` (`=3`)\n- `EXCEPTION_WHILE_PROCESSING` (`=4`)\n\nCan be used to limit which entities will go to `query_log`, say you are interested only in errors, then you can use `EXCEPTION_WHILE_PROCESSING`:\n\n```text\nlog_queries_min_type='EXCEPTION_WHILE_PROCESSING'\n```"
    },
    {
      "name": "log_queries_probability",
      "type": "Float",
      "description": "Allows a user to write to [query_log](../../operations/system-tables/query_log.md), [query_thread_log](../../operations/system-tables/query_thread_log.md), and [query_views_log](../../operations/system-tables/query_views_log.md) system tables only a sample of queries selected randomly with the specified probability. It helps to reduce the load with a large volume of queries in a second.\n\nPossible values:\n\n- 0 — Queries are not logged in the system tables.\n- Positive floating-point number in the range [0..1]. For example, if the setting value is `0.5`, about half of the queries are logged in the system tables.\n- 1 — All queries are logged in the system tables."
    },
    {
      "name": "log_query_settings",
      "type": "Bool",
      "description": "Log query settings into the query_log and OpenTelemetry span log."
    },
    {
      "name": "log_query_threads",
      "type": "Bool",
      "description": "Setting up query threads logging.\n\nQuery threads log into the [system.query_thread_log](../../operations/system-tables/query_thread_log.md) table. This setting has effect only when [log_queries](#log_queries) is true. Queries' threads run by ClickHouse with this setup are logged according to the rules in the [query_thread_log](/operations/server-configuration-parameters/settings#query_thread_log) server configuration parameter.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\n**Example**\n\n```text\nlog_query_threads=1\n```"
    },
    {
      "name": "log_query_views",
      "type": "Bool",
      "description": "Setting up query views logging.\n\nWhen a query run by ClickHouse with this setting enabled has associated views (materialized or live views), they are logged in the [query_views_log](/operations/server-configuration-parameters/settings#query_views_log) server configuration parameter.\n\nExample:\n\n```text\nlog_query_views=1\n```"
    },
    {
      "name": "low_cardinality_allow_in_native_format",
      "type": "Bool",
      "description": "Allows or restricts using the [LowCardinality](../../sql-reference/data-types/lowcardinality.md) data type with the [Native](../../interfaces/formats.md/#native) format.\n\nIf usage of `LowCardinality` is restricted, ClickHouse server converts `LowCardinality`-columns to ordinary ones for `SELECT` queries, and convert ordinary columns to `LowCardinality`-columns for `INSERT` queries.\n\nThis setting is required mainly for third-party clients which do not support `LowCardinality` data type.\n\nPossible values:\n\n- 1 — Usage of `LowCardinality` is not restricted.\n- 0 — Usage of `LowCardinality` is restricted."
    },
    {
      "name": "low_cardinality_max_dictionary_size",
      "type": "UInt64",
      "description": "Sets a maximum size in rows of a shared global dictionary for the [LowCardinality](../../sql-reference/data-types/lowcardinality.md) data type that can be written to a storage file system. This setting prevents issues with RAM in case of unlimited dictionary growth. All the data that can't be encoded due to maximum dictionary size limitation ClickHouse writes in an ordinary method.\n\nPossible values:\n\n- Any positive integer."
    },
    {
      "name": "low_cardinality_use_single_dictionary_for_part",
      "type": "Bool",
      "description": "Turns on or turns off using of single dictionary for the data part.\n\nBy default, the ClickHouse server monitors the size of dictionaries and if a dictionary overflows then the server starts to write the next one. To prohibit creating several dictionaries set `low_cardinality_use_single_dictionary_for_part = 1`.\n\nPossible values:\n\n- 1 — Creating several dictionaries for the data part is prohibited.\n- 0 — Creating several dictionaries for the data part is not prohibited."
    },
    {
      "name": "low_priority_query_wait_time_ms",
      "type": "Milliseconds",
      "description": "When the query prioritization mechanism is employed (see setting `priority`), low-priority queries wait for higher-priority queries to finish. This setting specifies the duration of waiting."
    },
    {
      "name": "make_distributed_plan",
      "type": "Bool",
      "description": "Make distributed query plan."
    },
    {
      "name": "materialize_skip_indexes_on_insert",
      "type": "Bool",
      "description": "If INSERTs build and store skip indexes. If disabled, skip indexes will be build and stored during merges or by explicit MATERIALIZE INDEX"
    },
    {
      "name": "materialize_statistics_on_insert",
      "type": "Bool",
      "description": "If INSERTs build and insert statistics. If disabled, statistics will be build and stored during merges or by explicit MATERIALIZE STATISTICS"
    },
    {
      "name": "materialize_ttl_after_modify",
      "type": "Bool",
      "description": "Apply TTL for old data, after ALTER MODIFY TTL query"
    },
    {
      "name": "materialized_views_ignore_errors",
      "type": "Bool",
      "description": "Allows to ignore errors for MATERIALIZED VIEW, and deliver original block to the table regardless of MVs"
    },
    {
      "name": "max_alter_threads",
      "type": "MaxThreads",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_analyze_depth",
      "type": "UInt64",
      "description": "Maximum number of analyses performed by interpreter."
    },
    {
      "name": "max_ast_depth",
      "type": "UInt64",
      "description": "The maximum nesting depth of a query syntactic tree. If exceeded, an exception is thrown.\n\n:::note\nAt this time, it isn't checked during parsing, but only after parsing the query.\nThis means that a syntactic tree that is too deep can be created during parsing,\nbut the query will fail.\n:::"
    },
    {
      "name": "max_ast_elements",
      "type": "UInt64",
      "description": "The maximum number of elements in a query syntactic tree. If exceeded, an exception is thrown.\n\n:::note\nAt this time, it isn't checked during parsing, but only after parsing the query.\nThis means that a syntactic tree that is too deep can be created during parsing,\nbut the query will fail.\n:::"
    },
    {
      "name": "max_autoincrement_series",
      "type": "UInt64",
      "description": "The limit on the number of series created by the `generateSeriesID` function.\n\nAs each series represents a node in Keeper, it is recommended to have no more than a couple of millions of them."
    },
    {
      "name": "max_backup_bandwidth",
      "type": "UInt64",
      "description": "The maximum read speed in bytes per second for particular backup on server. Zero means unlimited."
    },
    {
      "name": "max_block_size",
      "type": "NonZeroUInt64",
      "description": "In ClickHouse, data is processed by blocks, which are sets of column parts. The internal processing cycles for a single block are efficient but there are noticeable costs when processing each block.\n\nThe `max_block_size` setting indicates the recommended maximum number of rows to include in a single block when loading data from tables. Blocks the size of `max_block_size` are not always loaded from the table: if ClickHouse determines that less data needs to be retrieved, a smaller block is processed.\n\nThe block size should not be too small to avoid noticeable costs when processing each block. It should also not be too large to ensure that queries with a LIMIT clause execute quickly after processing the first block. When setting `max_block_size`, the goal should be to avoid consuming too much memory when extracting a large number of columns in multiple threads and to preserve at least some cache locality."
    },
    {
      "name": "max_bytes_before_external_group_by",
      "type": "UInt64",
      "description": "Cloud default value: half the memory amount per replica.\n\nEnables or disables execution of `GROUP BY` clauses in external memory.\n(See [GROUP BY in external memory](/sql-reference/statements/select/group-by#group-by-in-external-memory))\n\nPossible values:\n\n- Maximum volume of RAM (in bytes) that can be used by the single [GROUP BY](/sql-reference/statements/select/group-by) operation.\n- `0` — `GROUP BY` in external memory disabled.\n\n:::note\nIf memory usage during GROUP BY operations is exceeding this threshold in bytes,\nactivate the 'external aggregation' mode (spill data to disk).\n\nThe recommended value is half of the available system memory.\n:::"
    },
    {
      "name": "max_bytes_before_external_sort",
      "type": "UInt64",
      "description": "Cloud default value: half the memory amount per replica.\n\nEnables or disables execution of `ORDER BY` clauses in external memory. See [ORDER BY Implementation Details](../../sql-reference/statements/select/order-by.md#implementation-details)\nIf memory usage during ORDER BY operation exceeds this threshold in bytes, the 'external sorting' mode (spill data to disk) is activated.\n\nPossible values:\n\n- Maximum volume of RAM (in bytes) that can be used by the single [ORDER BY](../../sql-reference/statements/select/order-by.md) operation.\n  The recommended value is half of available system memory\n- `0` — `ORDER BY` in external memory disabled."
    },
    {
      "name": "max_bytes_before_remerge_sort",
      "type": "UInt64",
      "description": "In case of ORDER BY with LIMIT, when memory usage is higher than specified threshold, perform additional steps of merging blocks before final merge to keep just top LIMIT rows."
    },
    {
      "name": "max_bytes_in_distinct",
      "type": "UInt64",
      "description": "The maximum number of bytes of the state (in uncompressed bytes) in memory, which\nis used by a hash table when using DISTINCT."
    },
    {
      "name": "max_bytes_in_join",
      "type": "UInt64",
      "description": "The maximum size in number of bytes of the hash table used when joining tables.\n\nThis setting applies to [SELECT ... JOIN](/sql-reference/statements/select/join)\noperations and the [Join table engine](/engines/table-engines/special/join).\n\nIf the query contains joins, ClickHouse checks this setting for every intermediate result.\n\nClickHouse can proceed with different actions when the limit is reached. Use\nthe [join_overflow_mode](/operations/settings/settings#join_overflow_mode) settings to choose the action.\n\nPossible values:\n\n- Positive integer.\n- 0 — Memory control is disabled."
    },
    {
      "name": "max_bytes_in_set",
      "type": "UInt64",
      "description": "The maximum number of bytes (of uncompressed data) used by a set in the IN clause\ncreated from a subquery."
    },
    {
      "name": "max_bytes_ratio_before_external_group_by",
      "type": "Double",
      "description": "The ratio of available memory that is allowed for `GROUP BY`. Once reached,\nexternal memory is used for aggregation.\n\nFor example, if set to `0.6`, `GROUP BY` will allow using 60% of the available memory\n(to server/user/merges) at the beginning of the execution, after that, it will\nstart using external aggregation."
    },
    {
      "name": "max_bytes_ratio_before_external_sort",
      "type": "Double",
      "description": "The ratio of available memory that is allowed for `ORDER BY`. Once reached, external sort is used.\n\nFor example, if set to `0.6`, `ORDER BY` will allow using `60%` of available memory (to server/user/merges) at the beginning of the execution, after that, it will start using external sort.\n\nNote, that `max_bytes_before_external_sort` is still respected, spilling to disk will be done only if the sorting block is bigger then `max_bytes_before_external_sort`."
    },
    {
      "name": "max_bytes_to_read",
      "type": "UInt64",
      "description": "The maximum number of bytes (of uncompressed data) that can be read from a table when running a query.\nThe restriction is checked for each processed chunk of data, applied only to the\ndeepest table expression and when reading from a remote server, checked only on\nthe remote server."
    },
    {
      "name": "max_bytes_to_read_leaf",
      "type": "UInt64",
      "description": "The maximum number of bytes (of uncompressed data) that can be read from a local\ntable on a leaf node when running a distributed query. While distributed queries\ncan issue a multiple sub-queries to each shard (leaf) - this limit will\nbe checked only on the read stage on the leaf nodes and will be ignored on the\nmerging of results stage on the root node.\n\nFor example, a cluster consists of 2 shards and each shard contains a table with\n100 bytes of data. A distributed query which is supposed to read all the data\nfrom both tables with setting `max_bytes_to_read=150` will fail as in total it\nwill be 200 bytes. A query with `max_bytes_to_read_leaf=150` will succeed since\nleaf nodes will read 100 bytes at max.\n\nThe restriction is checked for each processed chunk of data.\n\n:::note\nThis setting is unstable with `prefer_localhost_replica=1`.\n:::"
    },
    {
      "name": "max_bytes_to_sort",
      "type": "UInt64",
      "description": "The maximum number of bytes before sorting. If more than the specified amount of\nuncompressed bytes have to be processed for ORDER BY operation, the behavior will\nbe determined by the `sort_overflow_mode` which by default is set to `throw`."
    },
    {
      "name": "max_bytes_to_transfer",
      "type": "UInt64",
      "description": "The maximum number of bytes (uncompressed data) that can be passed to a remote\nserver or saved in a temporary table when the GLOBAL IN/JOIN section is executed."
    },
    {
      "name": "max_columns_to_read",
      "type": "UInt64",
      "description": "The maximum number of columns that can be read from a table in a single query.\nIf a query requires reading more than the specified number of columns, an exception\nis thrown.\n\n:::tip\nThis setting is useful for preventing overly complex queries.\n:::\n\n`0` value means unlimited."
    },
    {
      "name": "max_compress_block_size",
      "type": "UInt64",
      "description": "The maximum size of blocks of uncompressed data before compressing for writing to a table. By default, 1,048,576 (1 MiB). Specifying a smaller block size generally leads to slightly reduced compression ratio, the compression and decompression speed increases slightly due to cache locality, and memory consumption is reduced.\n\n:::note\nThis is an expert-level setting, and you shouldn't change it if you're just getting started with ClickHouse.\n:::\n\nDon't confuse blocks for compression (a chunk of memory consisting of bytes) with blocks for query processing (a set of rows from a table)."
    },
    {
      "name": "max_concurrent_queries_for_all_users",
      "type": "UInt64",
      "description": "Throw exception if the value of this setting is less or equal than the current number of simultaneously processed queries.\n\nExample: `max_concurrent_queries_for_all_users` can be set to 99 for all users and database administrator can set it to 100 for itself to run queries for investigation even when the server is overloaded.\n\nModifying the setting for one query or user does not affect other queries.\n\nPossible values:\n\n- Positive integer.\n- 0 — No limit.\n\n**Example**\n\n```xml\n<max_concurrent_queries_for_all_users>99</max_concurrent_queries_for_all_users>\n```\n\n**See Also**\n\n- [max_concurrent_queries](/operations/server-configuration-parameters/settings#max_concurrent_queries)"
    },
    {
      "name": "max_concurrent_queries_for_user",
      "type": "UInt64",
      "description": "The maximum number of simultaneously processed queries per user.\n\nPossible values:\n\n- Positive integer.\n- 0 — No limit.\n\n**Example**\n\n```xml\n<max_concurrent_queries_for_user>5</max_concurrent_queries_for_user>\n```"
    },
    {
      "name": "max_distributed_connections",
      "type": "UInt64",
      "description": "The maximum number of simultaneous connections with remote servers for distributed processing of a single query to a single Distributed table. We recommend setting a value no less than the number of servers in the cluster.\n\nThe following parameters are only used when creating Distributed tables (and when launching a server), so there is no reason to change them at runtime."
    },
    {
      "name": "max_distributed_depth",
      "type": "UInt64",
      "description": "Limits the maximum depth of recursive queries for [Distributed](../../engines/table-engines/special/distributed.md) tables.\n\nIf the value is exceeded, the server throws an exception.\n\nPossible values:\n\n- Positive integer.\n- 0 — Unlimited depth."
    },
    {
      "name": "max_download_buffer_size",
      "type": "UInt64",
      "description": "The maximal size of buffer for parallel downloading (e.g. for URL engine) per each thread."
    },
    {
      "name": "max_download_threads",
      "type": "MaxThreads",
      "description": "The maximum number of threads to download data (e.g. for URL engine)."
    },
    {
      "name": "max_entries_for_hash_table_stats",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "max_estimated_execution_time",
      "type": "Seconds",
      "description": "Maximum query estimate execution time in seconds. Checked on every data block\nwhen [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)\nexpires."
    },
    {
      "name": "max_execution_speed",
      "type": "UInt64",
      "description": "The maximum number of execution rows per second. Checked on every data block when\n[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)\nexpires. If the execution speed is high, the execution speed will be reduced."
    },
    {
      "name": "max_execution_speed_bytes",
      "type": "UInt64",
      "description": "The maximum number of execution bytes per second. Checked on every data block when\n[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)\nexpires. If the execution speed is high, the execution speed will be reduced."
    },
    {
      "name": "max_execution_time",
      "type": "Seconds",
      "description": "The maximum query execution time in seconds.\n\nThe `max_execution_time` parameter can be a bit tricky to understand.\nIt operates based on interpolation relative to the current query execution speed\n(this behaviour is controlled by [`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)).\n\nClickHouse will interrupt a query if the projected execution time exceeds the\nspecified `max_execution_time`. By default, the `timeout_before_checking_execution_speed`\nis set to 10 seconds. This means that after 10 seconds of query execution, ClickHouse\nwill begin estimating the total execution time. If, for example, `max_execution_time`\nis set to 3600 seconds (1 hour), ClickHouse will terminate the query if the estimated\ntime exceeds this 3600-second limit. If you set `timeout_before_checking_execution_speed`\nto 0, ClickHouse will use the clock time as the basis for `max_execution_time`.\n\nIf query runtime exceeds the specified number of seconds, the behavior will be\ndetermined by the 'timeout_overflow_mode', which by default is set to `throw`.\n\n:::note\nThe timeout is checked and the query can stop only in designated places during data processing.\nIt currently cannot stop during merging of aggregation states or during query analysis,\nand the actual run time will be higher than the value of this setting.\n:::"
    },
    {
      "name": "max_execution_time_leaf",
      "type": "Seconds",
      "description": "Similar semantically to [`max_execution_time`](#max_execution_time) but only\napplied on leaf nodes for distributed or remote queries.\n\nFor example, if we want to limit the execution time on a leaf node to `10s` but\nhave no limit on the initial node, instead of having `max_execution_time` in the\nnested subquery settings:\n\n```sql\nSELECT count()\nFROM cluster(cluster, view(SELECT * FROM t SETTINGS max_execution_time = 10));\n```\n\nWe can use `max_execution_time_leaf` as the query settings:\n\n```sql\nSELECT count()\nFROM cluster(cluster, view(SELECT * FROM t)) SETTINGS max_execution_time_leaf = 10;\n```"
    },
    {
      "name": "max_expanded_ast_elements",
      "type": "UInt64",
      "description": "Maximum size of query syntax tree in number of nodes after expansion of aliases and the asterisk."
    },
    {
      "name": "max_fetch_partition_retries_count",
      "type": "UInt64",
      "description": "Amount of retries while fetching partition from another host."
    },
    {
      "name": "max_final_threads",
      "type": "MaxThreads",
      "description": "Sets the maximum number of parallel threads for the `SELECT` query data read phase with the [FINAL](/sql-reference/statements/select/from#final-modifier) modifier.\n\nPossible values:\n\n- Positive integer.\n- 0 or 1 — Disabled. `SELECT` queries are executed in a single thread."
    },
    {
      "name": "max_http_get_redirects",
      "type": "UInt64",
      "description": "Max number of HTTP GET redirects hops allowed. Ensures additional security measures are in place to prevent a malicious server from redirecting your requests to unexpected services.\\n\\nIt is the case when an external server redirects to another address, but that address appears to be internal to the company's infrastructure, and by sending an HTTP request to an internal server, you could request an internal API from the internal network, bypassing the auth, or even query other services, such as Redis or Memcached. When you don't have an internal infrastructure (including something running on your localhost), or you trust the server, it is safe to allow redirects. Although keep in mind, that if the URL uses HTTP instead of HTTPS, and you will have to trust not only the remote server but also your ISP and every network in the middle."
    },
    {
      "name": "max_hyperscan_regexp_length",
      "type": "UInt64",
      "description": "Defines the maximum length for each regular expression in the [hyperscan multi-match functions](/sql-reference/functions/string-search-functions#multimatchany).\n\nPossible values:\n\n- Positive integer.\n- 0 - The length is not limited.\n\n**Example**\n\nQuery:\n\n```sql\nSELECT multiMatchAny('abcd', ['ab','bcd','c','d']) SETTINGS max_hyperscan_regexp_length = 3;\n```\n\nResult:\n\n```text\n┌─multiMatchAny('abcd', ['ab', 'bcd', 'c', 'd'])─┐\n│                                              1 │\n└────────────────────────────────────────────────┘\n```\n\nQuery:\n\n```sql\nSELECT multiMatchAny('abcd', ['ab','bcd','c','d']) SETTINGS max_hyperscan_regexp_length = 2;\n```\n\nResult:\n\n```text\nException: Regexp length too large.\n```\n\n**See Also**\n\n- [max_hyperscan_regexp_total_length](#max_hyperscan_regexp_total_length)"
    },
    {
      "name": "max_hyperscan_regexp_total_length",
      "type": "UInt64",
      "description": "Sets the maximum length total of all regular expressions in each [hyperscan multi-match function](/sql-reference/functions/string-search-functions#multimatchany).\n\nPossible values:\n\n- Positive integer.\n- 0 - The length is not limited.\n\n**Example**\n\nQuery:\n\n```sql\nSELECT multiMatchAny('abcd', ['a','b','c','d']) SETTINGS max_hyperscan_regexp_total_length = 5;\n```\n\nResult:\n\n```text\n┌─multiMatchAny('abcd', ['a', 'b', 'c', 'd'])─┐\n│                                           1 │\n└─────────────────────────────────────────────┘\n```\n\nQuery:\n\n```sql\nSELECT multiMatchAny('abcd', ['ab','bc','c','d']) SETTINGS max_hyperscan_regexp_total_length = 5;\n```\n\nResult:\n\n```text\nException: Total regexp lengths too large.\n```\n\n**See Also**\n\n- [max_hyperscan_regexp_length](#max_hyperscan_regexp_length)"
    },
    {
      "name": "max_insert_block_size",
      "type": "UInt64",
      "description": "The size of blocks (in a count of rows) to form for insertion into a table.\nThis setting only applies in cases when the server forms the blocks.\nFor example, for an INSERT via the HTTP interface, the server parses the data format and forms blocks of the specified size.\nBut when using clickhouse-client, the client parses the data itself, and the 'max_insert_block_size' setting on the server does not affect the size of the inserted blocks.\nThe setting also does not have a purpose when using INSERT SELECT, since data is inserted using the same blocks that are formed after SELECT.\n\nThe default is slightly more than `max_block_size`. The reason for this is that certain table engines (`*MergeTree`) form a data part on the disk for each inserted block, which is a fairly large entity. Similarly, `*MergeTree` tables sort data during insertion, and a large enough block size allow sorting more data in RAM."
    },
    {
      "name": "max_insert_delayed_streams_for_parallel_write",
      "type": "UInt64",
      "description": "The maximum number of streams (columns) to delay final part flush. Default - auto (100 in case of underlying storage supports parallel write, for example S3 and disabled otherwise)"
    },
    {
      "name": "max_insert_threads",
      "type": "UInt64",
      "description": "The maximum number of threads to execute the `INSERT SELECT` query.\n\nPossible values:\n\n- 0 (or 1) — `INSERT SELECT` no parallel execution.\n- Positive integer. Bigger than 1.\n\nCloud default value: from `2` to `4`, depending on the service size.\n\nParallel `INSERT SELECT` has effect only if the `SELECT` part is executed in parallel, see [max_threads](#max_threads) setting.\nHigher values will lead to higher memory usage."
    },
    {
      "name": "max_joined_block_size_rows",
      "type": "UInt64",
      "description": "Maximum block size for JOIN result (if join algorithm supports it). 0 means unlimited."
    },
    {
      "name": "max_limit_for_ann_queries",
      "type": "Int64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_limit_for_vector_search_queries",
      "type": "UInt64",
      "description": "SELECT queries with LIMIT bigger than this setting cannot use vector similarity indices. Helps to prevent memory overflows in vector similarity indices."
    },
    {
      "name": "max_live_view_insert_blocks_before_refresh",
      "type": "UInt64",
      "description": "Limit maximum number of inserted blocks after which mergeable blocks are dropped and query is re-executed."
    },
    {
      "name": "max_local_read_bandwidth",
      "type": "UInt64",
      "description": "The maximum speed of local reads in bytes per second."
    },
    {
      "name": "max_local_write_bandwidth",
      "type": "UInt64",
      "description": "The maximum speed of local writes in bytes per second."
    },
    {
      "name": "max_memory_usage",
      "type": "UInt64",
      "description": "Cloud default value: depends on the amount of RAM on the replica.\n\nThe maximum amount of RAM to use for running a query on a single server.\nA value of `0` means unlimited.\n\nThis setting does not consider the volume of available memory or the total volume\nof memory on the machine. The restriction applies to a single query within a\nsingle server.\n\nYou can use `SHOW PROCESSLIST` to see the current memory consumption for each query.\nPeak memory consumption is tracked for each query and written to the log.\n\nMemory usage is not fully tracked for states of the following aggregate functions\nfrom `String` and `Array` arguments:\n- `min`\n- `max`\n- `any`\n- `anyLast`\n- `argMin`\n- `argMax`\n\nMemory consumption is also restricted by the parameters [`max_memory_usage_for_user`](/operations/settings/settings#max_memory_usage_for_user)\nand [`max_server_memory_usage`](/operations/server-configuration-parameters/settings#max_server_memory_usage)."
    },
    {
      "name": "max_memory_usage_for_all_queries",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_memory_usage_for_user",
      "type": "UInt64",
      "description": "The maximum amount of RAM to use for running a user's queries on a single server. Zero means unlimited.\n\nBy default, the amount is not restricted (`max_memory_usage_for_user = 0`).\n\nAlso see the description of [`max_memory_usage`](/operations/settings/settings#max_memory_usage).\n\nFor example if you want to set `max_memory_usage_for_user` to 1000 bytes for a user named `clickhouse_read`, you can use the statement\n\n```sql\nALTER USER clickhouse_read SETTINGS max_memory_usage_for_user = 1000;\n```\n\nYou can verify it worked by logging out of your client, logging back in, then use the `getSetting` function:\n\n```sql\nSELECT getSetting('max_memory_usage_for_user');\n```"
    },
    {
      "name": "max_network_bandwidth",
      "type": "UInt64",
      "description": "Limits the speed of the data exchange over the network in bytes per second. This setting applies to every query.\n\nPossible values:\n\n- Positive integer.\n- 0 — Bandwidth control is disabled."
    },
    {
      "name": "max_network_bandwidth_for_all_users",
      "type": "UInt64",
      "description": "Limits the speed that data is exchanged at over the network in bytes per second. This setting applies to all concurrently running queries on the server.\n\nPossible values:\n\n- Positive integer.\n- 0 — Control of the data speed is disabled."
    },
    {
      "name": "max_network_bandwidth_for_user",
      "type": "UInt64",
      "description": "Limits the speed of the data exchange over the network in bytes per second. This setting applies to all concurrently running queries performed by a single user.\n\nPossible values:\n\n- Positive integer.\n- 0 — Control of the data speed is disabled."
    },
    {
      "name": "max_network_bytes",
      "type": "UInt64",
      "description": "Limits the data volume (in bytes) that is received or transmitted over the network when executing a query. This setting applies to every individual query.\n\nPossible values:\n\n- Positive integer.\n- 0 — Data volume control is disabled."
    },
    {
      "name": "max_number_of_partitions_for_independent_aggregation",
      "type": "UInt64",
      "description": "Maximal number of partitions in table to apply optimization"
    },
    {
      "name": "max_os_cpu_wait_time_ratio_to_throw",
      "type": "Float",
      "description": "Max ratio between OS CPU wait (OSCPUWaitMicroseconds metric) and busy (OSCPUVirtualTimeMicroseconds metric) times to consider rejecting queries. Linear interpolation between min and max ratio is used to calculate the probability, the probability is 1 at this point."
    },
    {
      "name": "max_parallel_replicas",
      "type": "NonZeroUInt64",
      "description": "The maximum number of replicas for each shard when executing a query.\n\nPossible values:\n\n- Positive integer.\n\n**Additional Info**\n\nThis options will produce different results depending on the settings used.\n\n:::note\nThis setting will produce incorrect results when joins or subqueries are involved, and all tables don't meet certain requirements. See [Distributed Subqueries and max_parallel_replicas](/operations/settings/settings#max_parallel_replicas) for more details.\n:::\n\n### Parallel processing using `SAMPLE` key\n\nA query may be processed faster if it is executed on several servers in parallel. But the query performance may degrade in the following cases:\n\n- The position of the sampling key in the partitioning key does not allow efficient range scans.\n- Adding a sampling key to the table makes filtering by other columns less efficient.\n- The sampling key is an expression that is expensive to calculate.\n- The cluster latency distribution has a long tail, so that querying more servers increases the query overall latency.\n\n### Parallel processing using [parallel_replicas_custom_key](#parallel_replicas_custom_key)\n\nThis setting is useful for any replicated table."
    },
    {
      "name": "max_parser_backtracks",
      "type": "UInt64",
      "description": "Maximum parser backtracking (how many times it tries different alternatives in the recursive descend parsing process)."
    },
    {
      "name": "max_parser_depth",
      "type": "UInt64",
      "description": "Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size.\n\nPossible values:\n\n- Positive integer.\n- 0 — Recursion depth is unlimited."
    },
    {
      "name": "max_parsing_threads",
      "type": "MaxThreads",
      "description": "The maximum number of threads to parse data in input formats that support parallel parsing. By default, it is determined automatically"
    },
    {
      "name": "max_partition_size_to_drop",
      "type": "UInt64",
      "description": "Restriction on dropping partitions in query time. The value 0 means that you can drop partitions without any restrictions.\n\nCloud default value: 1 TB.\n\n:::note\nThis query setting overwrites its server setting equivalent, see [max_partition_size_to_drop](/operations/server-configuration-parameters/settings#max_partition_size_to_drop)\n:::"
    },
    {
      "name": "max_partitions_per_insert_block",
      "type": "UInt64",
      "description": "Limits the maximum number of partitions in a single inserted block\nand an exception is thrown if the block contains too many partitions.\n\n- Positive integer.\n- `0` — Unlimited number of partitions.\n\n**Details**\n\nWhen inserting data, ClickHouse calculates the number of partitions in the\ninserted block. If the number of partitions is more than\n`max_partitions_per_insert_block`, ClickHouse either logs a warning or throws an\nexception based on `throw_on_max_partitions_per_insert_block`. Exceptions have\nthe following text:\n\n> \"Too many partitions for a single INSERT block (`partitions_count` partitions, limit is \" + toString(max_partitions) + \").\n  The limit is controlled by the 'max_partitions_per_insert_block' setting.\n  A large number of partitions is a common misconception. It will lead to severe\n  negative performance impact, including slow server startup, slow INSERT queries\n  and slow SELECT queries. Recommended total number of partitions for a table is\n  under 1000..10000. Please note, that partitioning is not intended to speed up\n  SELECT queries (ORDER BY key is sufficient to make range queries fast).\n  Partitions are intended for data manipulation (DROP PARTITION, etc).\"\n\n:::note\nThis setting is a safety threshold because using a large number of partitions is a common misconception.\n:::"
    },
    {
      "name": "max_partitions_to_read",
      "type": "Int64",
      "description": "Limits the maximum number of partitions that can be accessed in a single query.\n\nThe setting value specified when the table is created can be overridden via query-level setting.\n\nPossible values:\n\n- Positive integer\n- `-1` - unlimited (default)\n\n:::note\nYou can also specify the MergeTree setting [`max_partitions_to_read`](/operations/settings/settings#max_partitions_to_read) in tables' setting.\n:::"
    },
    {
      "name": "max_parts_to_move",
      "type": "UInt64",
      "description": "Limit the number of parts that can be moved in one query. Zero means unlimited."
    },
    {
      "name": "max_pipeline_depth",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_query_size",
      "type": "UInt64",
      "description": "The maximum number of bytes of a query string parsed by the SQL parser.\nData in the VALUES clause of INSERT queries is processed by a separate stream parser (that consumes O(1) RAM) and not affected by this restriction.\n\n:::note\n`max_query_size` cannot be set within an SQL query (e.g., `SELECT now() SETTINGS max_query_size=10000`) because ClickHouse needs to allocate a buffer to parse the query, and this buffer size is determined by the `max_query_size` setting, which must be configured before the query is executed.\n:::"
    },
    {
      "name": "max_read_buffer_size",
      "type": "NonZeroUInt64",
      "description": "The maximum size of the buffer to read from the filesystem."
    },
    {
      "name": "max_read_buffer_size_local_fs",
      "type": "UInt64",
      "description": "The maximum size of the buffer to read from local filesystem. If set to 0 then max_read_buffer_size will be used."
    },
    {
      "name": "max_read_buffer_size_remote_fs",
      "type": "UInt64",
      "description": "The maximum size of the buffer to read from remote filesystem. If set to 0 then max_read_buffer_size will be used."
    },
    {
      "name": "max_recursive_cte_evaluation_depth",
      "type": "UInt64",
      "description": "Maximum limit on recursive CTE evaluation depth"
    },
    {
      "name": "max_remote_read_network_bandwidth",
      "type": "UInt64",
      "description": "The maximum speed of data exchange over the network in bytes per second for read."
    },
    {
      "name": "max_remote_read_network_bandwidth_for_server",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "max_remote_write_network_bandwidth",
      "type": "UInt64",
      "description": "The maximum speed of data exchange over the network in bytes per second for write."
    },
    {
      "name": "max_remote_write_network_bandwidth_for_server",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "max_replica_delay_for_distributed_queries",
      "type": "UInt64",
      "description": "Disables lagging replicas for distributed queries. See [Replication](../../engines/table-engines/mergetree-family/replication.md).\n\nSets the time in seconds. If a replica's lag is greater than or equal to the set value, this replica is not used.\n\nPossible values:\n\n- Positive integer.\n- 0 — Replica lags are not checked.\n\nTo prevent the use of any replica with a non-zero lag, set this parameter to 1.\n\nUsed when performing `SELECT` from a distributed table that points to replicated tables."
    },
    {
      "name": "max_replicated_fetches_network_bandwidth_for_server",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "max_replicated_sends_network_bandwidth_for_server",
      "type": "UInt64",
      "description": "User-level setting is deprecated, and it must be defined in the server configuration instead."
    },
    {
      "name": "max_result_bytes",
      "type": "UInt64",
      "description": "Limits the result size in bytes (uncompressed). The query will stop after processing a block of data if the threshold is met,\nbut it will not cut the last block of the result, therefore the result size can be larger than the threshold.\n\n**Caveats**\n\nThe result size in memory is taken into account for this threshold.\nEven if the result size is small, it can reference larger data structures in memory,\nrepresenting dictionaries of LowCardinality columns, and Arenas of AggregateFunction columns,\nso the threshold can be exceeded despite the small result size.\n\n:::warning\nThe setting is fairly low level and should be used with caution\n:::"
    },
    {
      "name": "max_result_rows",
      "type": "UInt64",
      "description": "Cloud default value: `0`.\n\nLimits the number of rows in the result. Also checked for subqueries, and on remote servers when running parts of a distributed query.\nNo limit is applied when the value is `0`.\n\nThe query will stop after processing a block of data if the threshold is met, but\nit will not cut the last block of the result, therefore the result size can be\nlarger than the threshold."
    },
    {
      "name": "max_rows_in_distinct",
      "type": "UInt64",
      "description": "The maximum number of different rows when using DISTINCT."
    },
    {
      "name": "max_rows_in_join",
      "type": "UInt64",
      "description": "Limits the number of rows in the hash table that is used when joining tables.\n\nThis settings applies to [SELECT ... JOIN](/sql-reference/statements/select/join)\noperations and the [Join](/engines/table-engines/special/join) table engine.\n\nIf a query contains multiple joins, ClickHouse checks this setting for every intermediate result.\n\nClickHouse can proceed with different actions when the limit is reached. Use the\n[`join_overflow_mode`](/operations/settings/settings#join_overflow_mode) setting to choose the action.\n\nPossible values:\n\n- Positive integer.\n- `0` — Unlimited number of rows."
    },
    {
      "name": "max_rows_in_set",
      "type": "UInt64",
      "description": "The maximum number of rows for a data set in the IN clause created from a subquery."
    },
    {
      "name": "max_rows_in_set_to_optimize_join",
      "type": "UInt64",
      "description": "Maximal size of the set to filter joined tables by each other's row sets before joining.\n\nPossible values:\n\n- 0 — Disable.\n- Any positive integer."
    },
    {
      "name": "max_rows_to_group_by",
      "type": "UInt64",
      "description": "The maximum number of unique keys received from aggregation. This setting lets\nyou limit memory consumption when aggregating.\n\nIf aggregation during GROUP BY is generating more than the specified number of\nrows (unique GROUP BY keys), the behavior will be determined by the\n'group_by_overflow_mode' which by default is `throw`, but can be also switched\nto an approximate GROUP BY mode."
    },
    {
      "name": "max_rows_to_read",
      "type": "UInt64",
      "description": "The maximum number of rows that can be read from a table when running a query.\nThe restriction is checked for each processed chunk of data, applied only to the\ndeepest table expression and when reading from a remote server, checked only on\nthe remote server."
    },
    {
      "name": "max_rows_to_read_leaf",
      "type": "UInt64",
      "description": "The maximum number of rows that can be read from a local table on a leaf node when\nrunning a distributed query. While distributed queries can issue multiple sub-queries\nto each shard (leaf) - this limit will be checked only on the read stage on the\nleaf nodes and ignored on the merging of results stage on the root node.\n\nFor example, a cluster consists of 2 shards and each shard contains a table with\n100 rows. The distributed query which is supposed to read all the data from both\ntables with setting `max_rows_to_read=150` will fail, as in total there will be\n200 rows. A query with `max_rows_to_read_leaf=150` will succeed, since leaf nodes\nwill read at max 100 rows.\n\nThe restriction is checked for each processed chunk of data.\n\n:::note\nThis setting is unstable with `prefer_localhost_replica=1`.\n:::"
    },
    {
      "name": "max_rows_to_sort",
      "type": "UInt64",
      "description": "The maximum number of rows before sorting. This allows you to limit memory consumption when sorting.\nIf more than the specified amount of records have to be processed for the ORDER BY operation,\nthe behavior will be determined by the `sort_overflow_mode` which by default is set to `throw`."
    },
    {
      "name": "max_rows_to_transfer",
      "type": "UInt64",
      "description": "Maximum size (in rows) that can be passed to a remote server or saved in a\ntemporary table when the GLOBAL IN/JOIN section is executed."
    },
    {
      "name": "max_sessions_for_user",
      "type": "UInt64",
      "description": "Maximum number of simultaneous sessions per authenticated user to the ClickHouse server.\n\nExample:\n\n```xml\n<profiles>\n    <single_session_profile>\n        <max_sessions_for_user>1</max_sessions_for_user>\n    </single_session_profile>\n    <two_sessions_profile>\n        <max_sessions_for_user>2</max_sessions_for_user>\n    </two_sessions_profile>\n    <unlimited_sessions_profile>\n        <max_sessions_for_user>0</max_sessions_for_user>\n    </unlimited_sessions_profile>\n</profiles>\n<users>\n    <!-- User Alice can connect to a ClickHouse server no more than once at a time. -->\n    <Alice>\n        <profile>single_session_user</profile>\n    </Alice>\n    <!-- User Bob can use 2 simultaneous sessions. -->\n    <Bob>\n        <profile>two_sessions_profile</profile>\n    </Bob>\n    <!-- User Charles can use arbitrarily many of simultaneous sessions. -->\n    <Charles>\n        <profile>unlimited_sessions_profile</profile>\n    </Charles>\n</users>\n```\n\nPossible values:\n- Positive integer\n- `0` - infinite count of simultaneous sessions (default)"
    },
    {
      "name": "max_size_to_preallocate_for_aggregation",
      "type": "UInt64",
      "description": "For how many elements it is allowed to preallocate space in all hash tables in total before aggregation"
    },
    {
      "name": "max_size_to_preallocate_for_joins",
      "type": "UInt64",
      "description": "For how many elements it is allowed to preallocate space in all hash tables in total before join"
    },
    {
      "name": "max_streams_for_merge_tree_reading",
      "type": "UInt64",
      "description": "If is not zero, limit the number of reading streams for MergeTree table."
    },
    {
      "name": "max_streams_multiplier_for_merge_tables",
      "type": "Float",
      "description": "Ask more streams when reading from Merge table. Streams will be spread across tables that Merge table will use. This allows more even distribution of work across threads and is especially helpful when merged tables differ in size."
    },
    {
      "name": "max_streams_to_max_threads_ratio",
      "type": "Float",
      "description": "Allows you to use more sources than the number of threads - to more evenly distribute work across threads. It is assumed that this is a temporary solution since it will be possible in the future to make the number of sources equal to the number of threads, but for each source to dynamically select available work for itself."
    },
    {
      "name": "max_subquery_depth",
      "type": "UInt64",
      "description": "If a query has more than the specified number of nested subqueries, throws an\nexception.\n\n:::tip\nThis allows you to have a sanity check to protect against the users of your\ncluster from writing overly complex queries.\n:::"
    },
    {
      "name": "max_table_size_to_drop",
      "type": "UInt64",
      "description": "Restriction on deleting tables in query time. The value 0 means that you can delete all tables without any restrictions.\n\nCloud default value: 1 TB.\n\n:::note\nThis query setting overwrites its server setting equivalent, see [max_table_size_to_drop](/operations/server-configuration-parameters/settings#max_table_size_to_drop)\n:::"
    },
    {
      "name": "max_temporary_columns",
      "type": "UInt64",
      "description": "The maximum number of temporary columns that must be kept in RAM simultaneously\nwhen running a query, including constant columns. If a query generates more than\nthe specified number of temporary columns in memory as a result of intermediate\ncalculation, then an exception is thrown.\n\n:::tip\nThis setting is useful for preventing overly complex queries.\n:::\n\n`0` value means unlimited."
    },
    {
      "name": "max_temporary_data_on_disk_size_for_query",
      "type": "UInt64",
      "description": "The maximum amount of data consumed by temporary files on disk in bytes for all\nconcurrently running queries.\n\nPossible values:\n\n- Positive integer.\n- `0` — unlimited (default)"
    },
    {
      "name": "max_temporary_data_on_disk_size_for_user",
      "type": "UInt64",
      "description": "The maximum amount of data consumed by temporary files on disk in bytes for all\nconcurrently running user queries.\n\nPossible values:\n\n- Positive integer.\n- `0` — unlimited (default)"
    },
    {
      "name": "max_temporary_non_const_columns",
      "type": "UInt64",
      "description": "Like `max_temporary_columns`, the maximum number of temporary columns that must\nbe kept in RAM simultaneously when running a query, but without counting constant\ncolumns.\n\n:::note\nConstant columns are formed fairly often when running a query, but they require\napproximately zero computing resources.\n:::"
    },
    {
      "name": "max_threads",
      "type": "MaxThreads",
      "description": "The maximum number of query processing threads, excluding threads for retrieving data from remote servers (see the 'max_distributed_connections' parameter).\n\nThis parameter applies to threads that perform the same stages of the query processing pipeline in parallel.\nFor example, when reading from a table, if it is possible to evaluate expressions with functions, filter with WHERE and pre-aggregate for GROUP BY in parallel using at least 'max_threads' number of threads, then 'max_threads' are used.\n\nFor queries that are completed quickly because of a LIMIT, you can set a lower 'max_threads'. For example, if the necessary number of entries are located in every block and max_threads = 8, then 8 blocks are retrieved, although it would have been enough to read just one.\n\nThe smaller the `max_threads` value, the less memory is consumed."
    },
    {
      "name": "max_threads_for_annoy_index_creation",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_threads_for_indexes",
      "type": "UInt64",
      "description": "The maximum number of threads process indices."
    },
    {
      "name": "max_untracked_memory",
      "type": "UInt64",
      "description": "Small allocations and deallocations are grouped in thread local variable and tracked or profiled only when an amount (in absolute value) becomes larger than the specified value. If the value is higher than 'memory_profiler_step' it will be effectively lowered to 'memory_profiler_step'."
    },
    {
      "name": "memory_overcommit_ratio_denominator",
      "type": "UInt64",
      "description": "It represents the soft memory limit when the hard limit is reached on the global level.\nThis value is used to compute the overcommit ratio for the query.\nZero means skip the query.\nRead more about [memory overcommit](memory-overcommit.md)."
    },
    {
      "name": "memory_overcommit_ratio_denominator_for_user",
      "type": "UInt64",
      "description": "It represents the soft memory limit when the hard limit is reached on the user level.\nThis value is used to compute the overcommit ratio for the query.\nZero means skip the query.\nRead more about [memory overcommit](memory-overcommit.md)."
    },
    {
      "name": "memory_profiler_sample_max_allocation_size",
      "type": "UInt64",
      "description": "Collect random allocations of size less or equal than the specified value with probability equal to `memory_profiler_sample_probability`. 0 means disabled. You may want to set 'max_untracked_memory' to 0 to make this threshold work as expected."
    },
    {
      "name": "memory_profiler_sample_min_allocation_size",
      "type": "UInt64",
      "description": "Collect random allocations of size greater or equal than the specified value with probability equal to `memory_profiler_sample_probability`. 0 means disabled. You may want to set 'max_untracked_memory' to 0 to make this threshold work as expected."
    },
    {
      "name": "memory_profiler_sample_probability",
      "type": "Float",
      "description": "Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless of the size of the allocation (can be changed with `memory_profiler_sample_min_allocation_size` and `memory_profiler_sample_max_allocation_size`). Note that sampling happens only when the amount of untracked memory exceeds 'max_untracked_memory'. You may want to set 'max_untracked_memory' to 0 for extra fine-grained sampling."
    },
    {
      "name": "memory_profiler_step",
      "type": "UInt64",
      "description": "Sets the step of memory profiler. Whenever query memory usage becomes larger than every next step in number of bytes the memory profiler will collect the allocating stacktrace and will write it into [trace_log](/operations/system-tables/trace_log).\n\nPossible values:\n\n- A positive integer number of bytes.\n\n- 0 for turning off the memory profiler."
    },
    {
      "name": "memory_tracker_fault_probability",
      "type": "Float",
      "description": "For testing of `exception safety` - throw an exception every time you allocate memory with the specified probability."
    },
    {
      "name": "memory_usage_overcommit_max_wait_microseconds",
      "type": "UInt64",
      "description": "Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level.\nIf the timeout is reached and memory is not freed, an exception is thrown.\nRead more about [memory overcommit](memory-overcommit.md)."
    },
    {
      "name": "merge_table_max_tables_to_look_for_schema_inference",
      "type": "UInt64",
      "description": "When creating a `Merge` table without an explicit schema or when using the `merge` table function, infer schema as a union of not more than the specified number of matching tables.\nIf there is a larger number of tables, the schema will be inferred from the first specified number of tables."
    },
    {
      "name": "merge_tree_clear_old_parts_interval_seconds",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "merge_tree_clear_old_temporary_directories_interval_seconds",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "merge_tree_coarse_index_granularity",
      "type": "UInt64",
      "description": "When searching for data, ClickHouse checks the data marks in the index file. If ClickHouse finds that required keys are in some range, it divides this range into `merge_tree_coarse_index_granularity` subranges and searches the required keys there recursively.\n\nPossible values:\n\n- Any positive even integer."
    },
    {
      "name": "merge_tree_compact_parts_min_granules_to_multibuffer_read",
      "type": "UInt64",
      "description": "Only has an effect in ClickHouse Cloud. Number of granules in stripe of compact part of MergeTree tables to use multibuffer reader, which supports parallel reading and prefetch. In case of reading from remote fs using of multibuffer reader increases number of read request."
    },
    {
      "name": "merge_tree_determine_task_size_by_prewhere_columns",
      "type": "Bool",
      "description": "Whether to use only prewhere columns size to determine reading task size."
    },
    {
      "name": "merge_tree_max_bytes_to_use_cache",
      "type": "UInt64",
      "description": "If ClickHouse should read more than `merge_tree_max_bytes_to_use_cache` bytes in one query, it does not use the cache of uncompressed blocks.\n\nThe cache of uncompressed blocks stores data extracted for queries. ClickHouse uses this cache to speed up responses to repeated small queries. This setting protects the cache from trashing by queries that read a large amount of data. The [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) server setting defines the size of the cache of uncompressed blocks.\n\nPossible values:\n\n- Any positive integer."
    },
    {
      "name": "merge_tree_max_rows_to_use_cache",
      "type": "UInt64",
      "description": "If ClickHouse should read more than `merge_tree_max_rows_to_use_cache` rows in one query, it does not use the cache of uncompressed blocks.\n\nThe cache of uncompressed blocks stores data extracted for queries. ClickHouse uses this cache to speed up responses to repeated small queries. This setting protects the cache from trashing by queries that read a large amount of data. The [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) server setting defines the size of the cache of uncompressed blocks.\n\nPossible values:\n\n- Any positive integer."
    },
    {
      "name": "merge_tree_min_bytes_for_concurrent_read",
      "type": "UInt64",
      "description": "If the number of bytes to read from one file of a [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md)-engine table exceeds `merge_tree_min_bytes_for_concurrent_read`, then ClickHouse tries to concurrently read from this file in several threads.\n\nPossible value:\n\n- Positive integer."
    },
    {
      "name": "merge_tree_min_bytes_for_concurrent_read_for_remote_filesystem",
      "type": "UInt64",
      "description": "The minimum number of bytes to read from one file before [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) engine can parallelize reading, when reading from remote filesystem. We do not recommend using this setting.\n\nPossible values:\n\n- Positive integer."
    },
    {
      "name": "merge_tree_min_bytes_for_seek",
      "type": "UInt64",
      "description": "If the distance between two data blocks to be read in one file is less than `merge_tree_min_bytes_for_seek` bytes, then ClickHouse sequentially reads a range of file that contains both blocks, thus avoiding extra seek.\n\nPossible values:\n\n- Any positive integer."
    },
    {
      "name": "merge_tree_min_bytes_per_task_for_remote_reading",
      "type": "UInt64",
      "description": "Min bytes to read per task."
    },
    {
      "name": "merge_tree_min_read_task_size",
      "type": "UInt64",
      "description": "Hard lower limit on the task size (even when the number of granules is low and the number of available threads is high we won't allocate smaller tasks"
    },
    {
      "name": "merge_tree_min_rows_for_concurrent_read",
      "type": "UInt64",
      "description": "If the number of rows to be read from a file of a [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) table exceeds `merge_tree_min_rows_for_concurrent_read` then ClickHouse tries to perform a concurrent reading from this file on several threads.\n\nPossible values:\n\n- Positive integer."
    },
    {
      "name": "merge_tree_min_rows_for_concurrent_read_for_remote_filesystem",
      "type": "UInt64",
      "description": "The minimum number of lines to read from one file before the [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) engine can parallelize reading, when reading from remote filesystem. We do not recommend using this setting.\n\nPossible values:\n\n- Positive integer."
    },
    {
      "name": "merge_tree_min_rows_for_seek",
      "type": "UInt64",
      "description": "If the distance between two data blocks to be read in one file is less than `merge_tree_min_rows_for_seek` rows, then ClickHouse does not seek through the file but reads the data sequentially.\n\nPossible values:\n\n- Any positive integer."
    },
    {
      "name": "merge_tree_read_split_ranges_into_intersecting_and_non_intersecting_injection_probability",
      "type": "Float",
      "description": "For testing of `PartsSplitter` - split read ranges into intersecting and non intersecting every time you read from MergeTree with the specified probability."
    },
    {
      "name": "merge_tree_storage_snapshot_sleep_ms",
      "type": "UInt64",
      "description": "Inject artificial delay (in milliseconds) when creating a storage snapshot for MergeTree tables.\nUsed for testing and debugging purposes only.\n\nPossible values:\n- 0 - No delay (default)\n- N - Delay in milliseconds"
    },
    {
      "name": "merge_tree_use_const_size_tasks_for_remote_reading",
      "type": "Bool",
      "description": "Whether to use constant size tasks for reading from a remote table."
    },
    {
      "name": "merge_tree_use_deserialization_prefixes_cache",
      "type": "Bool",
      "description": "Enables caching of columns metadata from the file prefixes during reading from Wide parts in MergeTree."
    },
    {
      "name": "merge_tree_use_prefixes_deserialization_thread_pool",
      "type": "Bool",
      "description": "Enables usage of the thread pool for parallel prefixes reading in Wide parts in MergeTree. Size of that thread pool is controlled by server setting `max_prefixes_deserialization_thread_pool_size`."
    },
    {
      "name": "merge_tree_use_v1_object_and_dynamic_serialization",
      "type": "Bool",
      "description": "When enabled, V1 serialization version of JSON and Dynamic types will be used in MergeTree instead of V2. Changing this setting takes affect only after server restart."
    },
    {
      "name": "metrics_perf_events_enabled",
      "type": "Bool",
      "description": "If enabled, some of the perf events will be measured throughout queries' execution."
    },
    {
      "name": "metrics_perf_events_list",
      "type": "String",
      "description": "Comma separated list of perf metrics that will be measured throughout queries' execution. Empty means all events. See PerfEventInfo in sources for the available events."
    },
    {
      "name": "min_bytes_to_use_direct_io",
      "type": "UInt64",
      "description": "The minimum data volume required for using direct I/O access to the storage disk.\n\nClickHouse uses this setting when reading data from tables. If the total storage volume of all the data to be read exceeds `min_bytes_to_use_direct_io` bytes, then ClickHouse reads the data from the storage disk with the `O_DIRECT` option.\n\nPossible values:\n\n- 0 — Direct I/O is disabled.\n- Positive integer."
    },
    {
      "name": "min_bytes_to_use_mmap_io",
      "type": "UInt64",
      "description": "This is an experimental setting. Sets the minimum amount of memory for reading large files without copying data from the kernel to userspace. Recommended threshold is about 64 MB, because [mmap/munmap](https://en.wikipedia.org/wiki/Mmap) is slow. It makes sense only for large files and helps only if data reside in the page cache.\n\nPossible values:\n\n- Positive integer.\n- 0 — Big files read with only copying data from kernel to userspace."
    },
    {
      "name": "min_chunk_bytes_for_parallel_parsing",
      "type": "NonZeroUInt64",
      "description": "- Type: unsigned int\n- Default value: 1 MiB\n\nThe minimum chunk size in bytes, which each thread will parse in parallel."
    },
    {
      "name": "min_compress_block_size",
      "type": "UInt64",
      "description": "For [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) tables. In order to reduce latency when processing queries, a block is compressed when writing the next mark if its size is at least `min_compress_block_size`. By default, 65,536.\n\nThe actual size of the block, if the uncompressed data is less than `max_compress_block_size`, is no less than this value and no less than the volume of data for one mark.\n\nLet's look at an example. Assume that `index_granularity` was set to 8192 during table creation.\n\nWe are writing a UInt32-type column (4 bytes per value). When writing 8192 rows, the total will be 32 KB of data. Since min_compress_block_size = 65,536, a compressed block will be formed for every two marks.\n\nWe are writing a URL column with the String type (average size of 60 bytes per value). When writing 8192 rows, the average will be slightly less than 500 KB of data. Since this is more than 65,536, a compressed block will be formed for each mark. In this case, when reading data from the disk in the range of a single mark, extra data won't be decompressed.\n\n:::note\nThis is an expert-level setting, and you shouldn't change it if you're just getting started with ClickHouse.\n:::"
    },
    {
      "name": "min_count_to_compile_aggregate_expression",
      "type": "UInt64",
      "description": "The minimum number of identical aggregate expressions to start JIT-compilation. Works only if the [compile_aggregate_expressions](#compile_aggregate_expressions) setting is enabled.\n\nPossible values:\n\n- Positive integer.\n- 0 — Identical aggregate expressions are always JIT-compiled."
    },
    {
      "name": "min_count_to_compile_expression",
      "type": "UInt64",
      "description": "Minimum count of executing same expression before it is get compiled."
    },
    {
      "name": "min_count_to_compile_sort_description",
      "type": "UInt64",
      "description": "The number of identical sort descriptions before they are JIT-compiled"
    },
    {
      "name": "min_execution_speed",
      "type": "UInt64",
      "description": "Minimal execution speed in rows per second. Checked on every data block when\n[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)\nexpires. If the execution speed is lower, an exception is thrown."
    },
    {
      "name": "min_execution_speed_bytes",
      "type": "UInt64",
      "description": "The minimum number of execution bytes per second. Checked on every data block when\n[`timeout_before_checking_execution_speed`](/operations/settings/settings#timeout_before_checking_execution_speed)\nexpires. If the execution speed is lower, an exception is thrown."
    },
    {
      "name": "min_external_sort_block_bytes",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "min_external_table_block_size_bytes",
      "type": "UInt64",
      "description": "Squash blocks passed to the external table to a specified size in bytes, if blocks are not big enough."
    },
    {
      "name": "min_external_table_block_size_rows",
      "type": "UInt64",
      "description": "Squash blocks passed to external table to specified size in rows, if blocks are not big enough."
    },
    {
      "name": "min_free_disk_bytes_to_perform_insert",
      "type": "UInt64",
      "description": "Minimum free disk space bytes to perform an insert."
    },
    {
      "name": "min_free_disk_ratio_to_perform_insert",
      "type": "Float",
      "description": "Minimum free disk space ratio to perform an insert."
    },
    {
      "name": "min_free_disk_space_for_temporary_data",
      "type": "UInt64",
      "description": "The minimum disk space to keep while writing temporary data used in external sorting and aggregation."
    },
    {
      "name": "min_hit_rate_to_use_consecutive_keys_optimization",
      "type": "Float",
      "description": "Minimal hit rate of a cache which is used for consecutive keys optimization in aggregation to keep it enabled"
    },
    {
      "name": "min_insert_block_size_bytes",
      "type": "UInt64",
      "description": "Sets the minimum number of bytes in the block which can be inserted into a table by an `INSERT` query. Smaller-sized blocks are squashed into bigger ones.\n\nPossible values:\n\n- Positive integer.\n- 0 — Squashing disabled."
    },
    {
      "name": "min_insert_block_size_bytes_for_materialized_views",
      "type": "UInt64",
      "description": "Sets the minimum number of bytes in the block which can be inserted into a table by an `INSERT` query. Smaller-sized blocks are squashed into bigger ones. This setting is applied only for blocks inserted into [materialized view](../../sql-reference/statements/create/view.md). By adjusting this setting, you control blocks squashing while pushing to materialized view and avoid excessive memory usage.\n\nPossible values:\n\n- Any positive integer.\n- 0 — Squashing disabled.\n\n**See also**\n\n- [min_insert_block_size_bytes](#min_insert_block_size_bytes)"
    },
    {
      "name": "min_insert_block_size_rows",
      "type": "UInt64",
      "description": "Sets the minimum number of rows in the block that can be inserted into a table by an `INSERT` query. Smaller-sized blocks are squashed into bigger ones.\n\nPossible values:\n\n- Positive integer.\n- 0 — Squashing disabled."
    },
    {
      "name": "min_insert_block_size_rows_for_materialized_views",
      "type": "UInt64",
      "description": "Sets the minimum number of rows in the block which can be inserted into a table by an `INSERT` query. Smaller-sized blocks are squashed into bigger ones. This setting is applied only for blocks inserted into [materialized view](../../sql-reference/statements/create/view.md). By adjusting this setting, you control blocks squashing while pushing to materialized view and avoid excessive memory usage.\n\nPossible values:\n\n- Any positive integer.\n- 0 — Squashing disabled.\n\n**See Also**\n\n- [min_insert_block_size_rows](#min_insert_block_size_rows)"
    },
    {
      "name": "min_joined_block_size_bytes",
      "type": "UInt64",
      "description": "Minimum block size for JOIN result (if join algorithm supports it). 0 means unlimited."
    },
    {
      "name": "min_os_cpu_wait_time_ratio_to_throw",
      "type": "Float",
      "description": "Min ratio between OS CPU wait (OSCPUWaitMicroseconds metric) and busy (OSCPUVirtualTimeMicroseconds metric) times to consider rejecting queries. Linear interpolation between min and max ratio is used to calculate the probability, the probability is 0 at this point."
    },
    {
      "name": "min_outstreams_per_resize_after_split",
      "type": "UInt64",
      "description": "Specifies the minimum number of output streams of a `Resize` or `StrictResize` processor after the split is performed during pipeline generation. If the resulting number of streams is less than this value, the split operation will not occur.\n\n### What is a Resize Node\nA `Resize` node is a processor in the query pipeline that adjusts the number of data streams flowing through the pipeline. It can either increase or decrease the number of streams to balance the workload across multiple threads or processors. For example, if a query requires more parallelism, the `Resize` node can split a single stream into multiple streams. Conversely, it can merge multiple streams into fewer streams to consolidate data processing.\n\nThe `Resize` node ensures that data is evenly distributed across streams, maintaining the structure of the data blocks. This helps optimize resource utilization and improve query performance.\n\n### Why the Resize Node Needs to Be Split\nDuring pipeline execution, ExecutingGraph::Node::status_mutex of the centrally-hubbed `Resize` node is heavily contended especially in high-core-count environments, and this contention leads to:\n1. Increased latency for ExecutingGraph::updateNode, directly impacting query performance.\n2. Excessive CPU cycles are wasted in spin-lock contention (native_queued_spin_lock_slowpath), degrading efficiency.\n3. Reduced CPU utilization, limiting parallelism and throughput.\n\n### How the Resize Node Gets Split\n1. The number of output streams is checked to ensure the split could be performed: the output streams of each split processor meet or exceed the `min_outstreams_per_resize_after_split` threshold.\n2. The `Resize` node is divided into smaller `Resize` nodes with equal count of ports, each handling a subset of input and output streams.\n3. Each group is processed independently, reducing the lock contention.\n\n### Splitting Resize Node with Arbitrary Inputs/Outputs\nIn some cases, where the inputs/outputs are indivisible by the number of split `Resize` nodes, some inputs are connected to `NullSource`s and some outputs are connected to `NullSink`s. This allows the split to occur without affecting the overall data flow.\n\n### Purpose of the Setting\nThe `min_outstreams_per_resize_after_split` setting ensures that the splitting of `Resize` nodes is meaningful and avoids creating too few streams, which could lead to inefficient parallel processing. By enforcing a minimum number of output streams, this setting helps maintain a balance between parallelism and overhead, optimizing query execution in scenarios involving stream splitting and merging.\n\n### Disabling the Setting\nTo disable the split of `Resize` nodes, set this setting to 0. This will prevent the splitting of `Resize` nodes during pipeline generation, allowing them to retain their original structure without division into smaller nodes."
    },
    {
      "name": "mongodb_throw_on_unsupported_query",
      "type": "Bool",
      "description": "If enabled, MongoDB tables will return an error when a MongoDB query cannot be built. Otherwise, ClickHouse reads the full table and processes it locally. This option does not apply when 'allow_experimental_analyzer=0'."
    },
    {
      "name": "move_all_conditions_to_prewhere",
      "type": "Bool",
      "description": "Move all viable conditions from WHERE to PREWHERE"
    },
    {
      "name": "move_primary_key_columns_to_end_of_prewhere",
      "type": "Bool",
      "description": "Move PREWHERE conditions containing primary key columns to the end of AND chain. It is likely that these conditions are taken into account during primary key analysis and thus will not contribute a lot to PREWHERE filtering."
    },
    {
      "name": "multiple_joins_rewriter_version",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "multiple_joins_try_to_keep_original_names",
      "type": "Bool",
      "description": "Do not add aliases to top level expression list on multiple joins rewrite"
    },
    {
      "name": "mutations_execute_nondeterministic_on_initiator",
      "type": "Bool",
      "description": "If true constant nondeterministic functions (e.g. function `now()`) are executed on initiator and replaced to literals in `UPDATE` and `DELETE` queries. It helps to keep data in sync on replicas while executing mutations with constant nondeterministic functions. Default value: `false`."
    },
    {
      "name": "mutations_execute_subqueries_on_initiator",
      "type": "Bool",
      "description": "If true scalar subqueries are executed on initiator and replaced to literals in `UPDATE` and `DELETE` queries. Default value: `false`."
    },
    {
      "name": "mutations_max_literal_size_to_replace",
      "type": "UInt64",
      "description": "The maximum size of serialized literal in bytes to replace in `UPDATE` and `DELETE` queries. Takes effect only if at least one the two settings above is enabled. Default value: 16384 (16 KiB)."
    },
    {
      "name": "mutations_sync",
      "type": "UInt64",
      "description": "Allows to execute `ALTER TABLE ... UPDATE|DELETE|MATERIALIZE INDEX|MATERIALIZE PROJECTION|MATERIALIZE COLUMN|MATERIALIZE STATISTICS` queries ([mutations](../../sql-reference/statements/alter/index.md/#mutations)) synchronously.\n\nPossible values:\n\n- 0 - Mutations execute asynchronously.\n- 1 - The query waits for all mutations to complete on the current server.\n- 2 - The query waits for all mutations to complete on all replicas (if they exist)."
    },
    {
      "name": "mysql_datatypes_support_level",
      "type": "MySQLDataTypesSupport",
      "description": "Defines how MySQL types are converted to corresponding ClickHouse types. A comma separated list in any combination of `decimal`, `datetime64`, `date2Date32` or `date2String`.\n- `decimal`: convert `NUMERIC` and `DECIMAL` types to `Decimal` when precision allows it.\n- `datetime64`: convert `DATETIME` and `TIMESTAMP` types to `DateTime64` instead of `DateTime` when precision is not `0`.\n- `date2Date32`: convert `DATE` to `Date32` instead of `Date`. Takes precedence over `date2String`.\n- `date2String`: convert `DATE` to `String` instead of `Date`. Overridden by `datetime64`."
    },
    {
      "name": "mysql_map_fixed_string_to_text_in_show_columns",
      "type": "Bool",
      "description": "When enabled, [FixedString](../../sql-reference/data-types/fixedstring.md) ClickHouse data type will be displayed as `TEXT` in [SHOW COLUMNS](../../sql-reference/statements/show.md/#show_columns).\n\nHas an effect only when the connection is made through the MySQL wire protocol.\n\n- 0 - Use `BLOB`.\n- 1 - Use `TEXT`."
    },
    {
      "name": "mysql_map_string_to_text_in_show_columns",
      "type": "Bool",
      "description": "When enabled, [String](../../sql-reference/data-types/string.md) ClickHouse data type will be displayed as `TEXT` in [SHOW COLUMNS](../../sql-reference/statements/show.md/#show_columns).\n\nHas an effect only when the connection is made through the MySQL wire protocol.\n\n- 0 - Use `BLOB`.\n- 1 - Use `TEXT`."
    },
    {
      "name": "mysql_max_rows_to_insert",
      "type": "UInt64",
      "description": "The maximum number of rows in MySQL batch insertion of the MySQL storage engine"
    },
    {
      "name": "network_compression_method",
      "type": "String",
      "description": "Sets the method of data compression that is used for communication between servers and between server and [clickhouse-client](../../interfaces/cli.md).\n\nPossible values:\n\n- `LZ4` — sets LZ4 compression method.\n- `ZSTD` — sets ZSTD compression method.\n\n**See Also**\n\n- [network_zstd_compression_level](#network_zstd_compression_level)"
    },
    {
      "name": "network_zstd_compression_level",
      "type": "Int64",
      "description": "Adjusts the level of ZSTD compression. Used only when [network_compression_method](#network_compression_method) is set to `ZSTD`.\n\nPossible values:\n\n- Positive integer from 1 to 15."
    },
    {
      "name": "normalize_function_names",
      "type": "Bool",
      "description": "Normalize function names to their canonical names"
    },
    {
      "name": "number_of_mutations_to_delay",
      "type": "UInt64",
      "description": "If the mutated table contains at least that many unfinished mutations, artificially slow down mutations of table. 0 - disabled"
    },
    {
      "name": "number_of_mutations_to_throw",
      "type": "UInt64",
      "description": "If the mutated table contains at least that many unfinished mutations, throw 'Too many mutations ...' exception. 0 - disabled"
    },
    {
      "name": "odbc_bridge_connection_pool_size",
      "type": "UInt64",
      "description": "Connection pool size for each connection settings string in ODBC bridge."
    },
    {
      "name": "odbc_bridge_use_connection_pooling",
      "type": "Bool",
      "description": "Use connection pooling in ODBC bridge. If set to false, a new connection is created every time."
    },
    {
      "name": "odbc_max_field_size",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "offset",
      "type": "UInt64",
      "description": "Sets the number of rows to skip before starting to return rows from the query. It adjusts the offset set by the [OFFSET](/sql-reference/statements/select/offset) clause, so that these two values are summarized.\n\nPossible values:\n\n- 0 — No rows are skipped .\n- Positive integer.\n\n**Example**\n\nInput table:\n\n```sql\nCREATE TABLE test (i UInt64) ENGINE = MergeTree() ORDER BY i;\nINSERT INTO test SELECT number FROM numbers(500);\n```\n\nQuery:\n\n```sql\nSET limit = 5;\nSET offset = 7;\nSELECT * FROM test LIMIT 10 OFFSET 100;\n```\nResult:\n\n```text\n┌───i─┐\n│ 107 │\n│ 108 │\n│ 109 │\n└─────┘\n```"
    },
    {
      "name": "opentelemetry_start_trace_probability",
      "type": "Float",
      "description": "Sets the probability that the ClickHouse can start a trace for executed queries (if no parent [trace context](https://www.w3.org/TR/trace-context/) is supplied).\n\nPossible values:\n\n- 0 — The trace for all executed queries is disabled (if no parent trace context is supplied).\n- Positive floating-point number in the range [0..1]. For example, if the setting value is `0,5`, ClickHouse can start a trace on average for half of the queries.\n- 1 — The trace for all executed queries is enabled."
    },
    {
      "name": "opentelemetry_trace_processors",
      "type": "Bool",
      "description": "Collect OpenTelemetry spans for processors."
    },
    {
      "name": "optimize_aggregation_in_order",
      "type": "Bool",
      "description": "Enables [GROUP BY](/sql-reference/statements/select/group-by) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries for aggregating data in corresponding order in [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) tables.\n\nPossible values:\n\n- 0 — `GROUP BY` optimization is disabled.\n- 1 — `GROUP BY` optimization is enabled.\n\n**See Also**\n\n- [GROUP BY optimization](/sql-reference/statements/select/group-by#group-by-optimization-depending-on-table-sorting-key)"
    },
    {
      "name": "optimize_aggregators_of_group_by_keys",
      "type": "Bool",
      "description": "Eliminates min/max/any/anyLast aggregators of GROUP BY keys in SELECT section"
    },
    {
      "name": "optimize_and_compare_chain",
      "type": "Bool",
      "description": "Populate constant comparison in AND chains to enhance filtering ability. Support operators `<`, `<=`, `>`, `>=`, `=` and mix of them. For example, `(a < b) AND (b < c) AND (c < 5)` would be `(a < b) AND (b < c) AND (c < 5) AND (b < 5) AND (a < 5)`."
    },
    {
      "name": "optimize_append_index",
      "type": "Bool",
      "description": "Use [constraints](../../sql-reference/statements/create/table.md/#constraints) in order to append index condition. The default is `false`.\n\nPossible values:\n\n- true, false"
    },
    {
      "name": "optimize_arithmetic_operations_in_aggregate_functions",
      "type": "Bool",
      "description": "Move arithmetic operations out of aggregation functions"
    },
    {
      "name": "optimize_count_from_files",
      "type": "Bool",
      "description": "Enables or disables the optimization of counting number of rows from files in different input formats. It applies to table functions/engines `file`/`s3`/`url`/`hdfs`/`azureBlobStorage`.\n\nPossible values:\n\n- 0 — Optimization disabled.\n- 1 — Optimization enabled."
    },
    {
      "name": "optimize_distinct_in_order",
      "type": "Bool",
      "description": "Enable DISTINCT optimization if some columns in DISTINCT form a prefix of sorting. For example, prefix of sorting key in merge tree or ORDER BY statement"
    },
    {
      "name": "optimize_distributed_group_by_sharding_key",
      "type": "Bool",
      "description": "Optimize `GROUP BY sharding_key` queries, by avoiding costly aggregation on the initiator server (which will reduce memory usage for the query on the initiator server).\n\nThe following types of queries are supported (and all combinations of them):\n\n- `SELECT DISTINCT [..., ]sharding_key[, ...] FROM dist`\n- `SELECT ... FROM dist GROUP BY sharding_key[, ...]`\n- `SELECT ... FROM dist GROUP BY sharding_key[, ...] ORDER BY x`\n- `SELECT ... FROM dist GROUP BY sharding_key[, ...] LIMIT 1`\n- `SELECT ... FROM dist GROUP BY sharding_key[, ...] LIMIT 1 BY x`\n\nThe following types of queries are not supported (support for some of them may be added later):\n\n- `SELECT ... GROUP BY sharding_key[, ...] WITH TOTALS`\n- `SELECT ... GROUP BY sharding_key[, ...] WITH ROLLUP`\n- `SELECT ... GROUP BY sharding_key[, ...] WITH CUBE`\n- `SELECT ... GROUP BY sharding_key[, ...] SETTINGS extremes=1`\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nSee also:\n\n- [distributed_group_by_no_merge](#distributed_group_by_no_merge)\n- [distributed_push_down_limit](#distributed_push_down_limit)\n- [optimize_skip_unused_shards](#optimize_skip_unused_shards)\n\n:::note\nRight now it requires `optimize_skip_unused_shards` (the reason behind this is that one day it may be enabled by default, and it will work correctly only if data was inserted via Distributed table, i.e. data is distributed according to sharding_key).\n:::"
    },
    {
      "name": "optimize_duplicate_order_by_and_distinct",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "optimize_extract_common_expressions",
      "type": "Bool",
      "description": "Allow extracting common expressions from disjunctions in WHERE, PREWHERE, ON, HAVING and QUALIFY expressions. A logical expression like `(A AND B) OR (A AND C)` can be rewritten to `A AND (B OR C)`, which might help to utilize:\n- indices in simple filtering expressions\n- cross to inner join optimization"
    },
    {
      "name": "optimize_functions_to_subcolumns",
      "type": "Bool",
      "description": "Enables or disables optimization by transforming some functions to reading subcolumns. This reduces the amount of data to read.\n\nThese functions can be transformed:\n\n- [length](/sql-reference/functions/array-functions#length) to read the [size0](../../sql-reference/data-types/array.md/#array-size) subcolumn.\n- [empty](/sql-reference/functions/array-functions#empty) to read the [size0](../../sql-reference/data-types/array.md/#array-size) subcolumn.\n- [notEmpty](/sql-reference/functions/array-functions#notEmpty) to read the [size0](../../sql-reference/data-types/array.md/#array-size) subcolumn.\n- [isNull](/sql-reference/functions/functions-for-nulls#isnull) to read the [null](../../sql-reference/data-types/nullable.md/#finding-null) subcolumn.\n- [isNotNull](/sql-reference/functions/functions-for-nulls#isnotnull) to read the [null](../../sql-reference/data-types/nullable.md/#finding-null) subcolumn.\n- [count](/sql-reference/aggregate-functions/reference/count) to read the [null](../../sql-reference/data-types/nullable.md/#finding-null) subcolumn.\n- [mapKeys](/sql-reference/functions/tuple-map-functions#mapkeys) to read the [keys](/sql-reference/data-types/map#reading-subcolumns-of-map) subcolumn.\n- [mapValues](/sql-reference/functions/tuple-map-functions#mapvalues) to read the [values](/sql-reference/data-types/map#reading-subcolumns-of-map) subcolumn.\n\nPossible values:\n\n- 0 — Optimization disabled.\n- 1 — Optimization enabled."
    },
    {
      "name": "optimize_fuse_sum_count_avg",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "optimize_group_by_constant_keys",
      "type": "Bool",
      "description": "Optimize GROUP BY when all keys in block are constant"
    },
    {
      "name": "optimize_group_by_function_keys",
      "type": "Bool",
      "description": "Eliminates functions of other keys in GROUP BY section"
    },
    {
      "name": "optimize_if_chain_to_multiif",
      "type": "Bool",
      "description": "Replace if(cond1, then1, if(cond2, ...)) chains to multiIf. Currently it's not beneficial for numeric types."
    },
    {
      "name": "optimize_if_transform_strings_to_enum",
      "type": "Bool",
      "description": "Replaces string-type arguments in If and Transform to enum. Disabled by default cause it could make inconsistent change in distributed query that would lead to its fail."
    },
    {
      "name": "optimize_injective_functions_in_group_by",
      "type": "Bool",
      "description": "Replaces injective functions by it's arguments in GROUP BY section"
    },
    {
      "name": "optimize_injective_functions_inside_uniq",
      "type": "Bool",
      "description": "Delete injective functions of one argument inside uniq*() functions."
    },
    {
      "name": "optimize_min_equality_disjunction_chain_length",
      "type": "UInt64",
      "description": "The minimum length of the expression `expr = x1 OR ... expr = xN` for optimization"
    },
    {
      "name": "optimize_min_inequality_conjunction_chain_length",
      "type": "UInt64",
      "description": "The minimum length of the expression `expr <> x1 AND ... expr <> xN` for optimization"
    },
    {
      "name": "optimize_monotonous_functions_in_order_by",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "optimize_move_functions_out_of_any",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "optimize_move_to_prewhere",
      "type": "Bool",
      "description": "Enables or disables automatic [PREWHERE](../../sql-reference/statements/select/prewhere.md) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries.\n\nWorks only for [*MergeTree](../../engines/table-engines/mergetree-family/index.md) tables.\n\nPossible values:\n\n- 0 — Automatic `PREWHERE` optimization is disabled.\n- 1 — Automatic `PREWHERE` optimization is enabled."
    },
    {
      "name": "optimize_move_to_prewhere_if_final",
      "type": "Bool",
      "description": "Enables or disables automatic [PREWHERE](../../sql-reference/statements/select/prewhere.md) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries with [FINAL](/sql-reference/statements/select/from#final-modifier) modifier.\n\nWorks only for [*MergeTree](../../engines/table-engines/mergetree-family/index.md) tables.\n\nPossible values:\n\n- 0 — Automatic `PREWHERE` optimization in `SELECT` queries with `FINAL` modifier is disabled.\n- 1 — Automatic `PREWHERE` optimization in `SELECT` queries with `FINAL` modifier is enabled.\n\n**See Also**\n\n- [optimize_move_to_prewhere](#optimize_move_to_prewhere) setting"
    },
    {
      "name": "optimize_multiif_to_if",
      "type": "Bool",
      "description": "Replace 'multiIf' with only one condition to 'if'."
    },
    {
      "name": "optimize_normalize_count_variants",
      "type": "Bool",
      "description": "Rewrite aggregate functions that semantically equals to count() as count()."
    },
    {
      "name": "optimize_on_insert",
      "type": "Bool",
      "description": "Enables or disables data transformation before the insertion, as if merge was done on this block (according to table engine).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\n**Example**\n\nThe difference between enabled and disabled:\n\nQuery:\n\n```sql\nSET optimize_on_insert = 1;\n\nCREATE TABLE test1 (`FirstTable` UInt32) ENGINE = ReplacingMergeTree ORDER BY FirstTable;\n\nINSERT INTO test1 SELECT number % 2 FROM numbers(5);\n\nSELECT * FROM test1;\n\nSET optimize_on_insert = 0;\n\nCREATE TABLE test2 (`SecondTable` UInt32) ENGINE = ReplacingMergeTree ORDER BY SecondTable;\n\nINSERT INTO test2 SELECT number % 2 FROM numbers(5);\n\nSELECT * FROM test2;\n```\n\nResult:\n\n```text\n┌─FirstTable─┐\n│          0 │\n│          1 │\n└────────────┘\n\n┌─SecondTable─┐\n│           0 │\n│           0 │\n│           0 │\n│           1 │\n│           1 │\n└─────────────┘\n```\n\nNote that this setting influences [Materialized view](/sql-reference/statements/create/view#materialized-view) behaviour."
    },
    {
      "name": "optimize_or_like_chain",
      "type": "Bool",
      "description": "Optimize multiple OR LIKE into multiMatchAny. This optimization should not be enabled by default, because it defies index analysis in some cases."
    },
    {
      "name": "optimize_read_in_order",
      "type": "Bool",
      "description": "Enables [ORDER BY](/sql-reference/statements/select/order-by#optimization-of-data-reading) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries for reading data from [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) tables.\n\nPossible values:\n\n- 0 — `ORDER BY` optimization is disabled.\n- 1 — `ORDER BY` optimization is enabled.\n\n**See Also**\n\n- [ORDER BY Clause](/sql-reference/statements/select/order-by#optimization-of-data-reading)"
    },
    {
      "name": "optimize_read_in_window_order",
      "type": "Bool",
      "description": "Enable ORDER BY optimization in window clause for reading data in corresponding order in MergeTree tables."
    },
    {
      "name": "optimize_redundant_functions_in_order_by",
      "type": "Bool",
      "description": "Remove functions from ORDER BY if its argument is also in ORDER BY"
    },
    {
      "name": "optimize_respect_aliases",
      "type": "Bool",
      "description": "If it is set to true, it will respect aliases in WHERE/GROUP BY/ORDER BY, that will help with partition pruning/secondary indexes/optimize_aggregation_in_order/optimize_read_in_order/optimize_trivial_count"
    },
    {
      "name": "optimize_rewrite_aggregate_function_with_if",
      "type": "Bool",
      "description": "Rewrite aggregate functions with if expression as argument when logically equivalent.\nFor example, `avg(if(cond, col, null))` can be rewritten to `avgOrNullIf(cond, col)`. It may improve performance.\n\n:::note\nSupported only with the analyzer (`enable_analyzer = 1`).\n:::"
    },
    {
      "name": "optimize_rewrite_array_exists_to_has",
      "type": "Bool",
      "description": "Rewrite arrayExists() functions to has() when logically equivalent. For example, arrayExists(x -> x = 1, arr) can be rewritten to has(arr, 1)"
    },
    {
      "name": "optimize_rewrite_sum_if_to_count_if",
      "type": "Bool",
      "description": "Rewrite sumIf() and sum(if()) function countIf() function when logically equivalent"
    },
    {
      "name": "optimize_skip_merged_partitions",
      "type": "Bool",
      "description": "Enables or disables optimization for [OPTIMIZE TABLE ... FINAL](../../sql-reference/statements/optimize.md) query if there is only one part with level > 0 and it doesn't have expired TTL.\n\n- `OPTIMIZE TABLE ... FINAL SETTINGS optimize_skip_merged_partitions=1`\n\nBy default, `OPTIMIZE TABLE ... FINAL` query rewrites the one part even if there is only a single part.\n\nPossible values:\n\n- 1 - Enable optimization.\n- 0 - Disable optimization."
    },
    {
      "name": "optimize_skip_unused_shards",
      "type": "Bool",
      "description": "Enables or disables skipping of unused shards for [SELECT](../../sql-reference/statements/select/index.md) queries that have sharding key condition in `WHERE/PREWHERE` (assuming that the data is distributed by sharding key, otherwise a query yields incorrect result).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "optimize_skip_unused_shards_limit",
      "type": "UInt64",
      "description": "Limit for number of sharding key values, turns off `optimize_skip_unused_shards` if the limit is reached.\n\nToo many values may require significant amount for processing, while the benefit is doubtful, since if you have huge number of values in `IN (...)`, then most likely the query will be sent to all shards anyway."
    },
    {
      "name": "optimize_skip_unused_shards_nesting",
      "type": "UInt64",
      "description": "Controls [`optimize_skip_unused_shards`](#optimize_skip_unused_shards) (hence still requires [`optimize_skip_unused_shards`](#optimize_skip_unused_shards)) depends on the nesting level of the distributed query (case when you have `Distributed` table that look into another `Distributed` table).\n\nPossible values:\n\n- 0 — Disabled, `optimize_skip_unused_shards` works always.\n- 1 — Enables `optimize_skip_unused_shards` only for the first level.\n- 2 — Enables `optimize_skip_unused_shards` up to the second level."
    },
    {
      "name": "optimize_skip_unused_shards_rewrite_in",
      "type": "Bool",
      "description": "Rewrite IN in query for remote shards to exclude values that does not belong to the shard (requires optimize_skip_unused_shards).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "optimize_sorting_by_input_stream_properties",
      "type": "Bool",
      "description": "Optimize sorting by sorting properties of input stream"
    },
    {
      "name": "optimize_substitute_columns",
      "type": "Bool",
      "description": "Use [constraints](../../sql-reference/statements/create/table.md/#constraints) for column substitution. The default is `false`.\n\nPossible values:\n\n- true, false"
    },
    {
      "name": "optimize_syntax_fuse_functions",
      "type": "Bool",
      "description": "Enables to fuse aggregate functions with identical argument. It rewrites query contains at least two aggregate functions from [sum](/sql-reference/aggregate-functions/reference/sum), [count](/sql-reference/aggregate-functions/reference/count) or [avg](/sql-reference/aggregate-functions/reference/avg) with identical argument to [sumCount](/sql-reference/aggregate-functions/reference/sumcount).\n\nPossible values:\n\n- 0 — Functions with identical argument are not fused.\n- 1 — Functions with identical argument are fused.\n\n**Example**\n\nQuery:\n\n```sql\nCREATE TABLE fuse_tbl(a Int8, b Int8) Engine = Log;\nSET optimize_syntax_fuse_functions = 1;\nEXPLAIN SYNTAX SELECT sum(a), sum(b), count(b), avg(b) from fuse_tbl FORMAT TSV;\n```\n\nResult:\n\n```text\nSELECT\n    sum(a),\n    sumCount(b).1,\n    sumCount(b).2,\n    (sumCount(b).1) / (sumCount(b).2)\nFROM fuse_tbl\n```"
    },
    {
      "name": "optimize_throw_if_noop",
      "type": "Bool",
      "description": "Enables or disables throwing an exception if an [OPTIMIZE](../../sql-reference/statements/optimize.md) query didn't perform a merge.\n\nBy default, `OPTIMIZE` returns successfully even if it didn't do anything. This setting lets you differentiate these situations and get the reason in an exception message.\n\nPossible values:\n\n- 1 — Throwing an exception is enabled.\n- 0 — Throwing an exception is disabled."
    },
    {
      "name": "optimize_time_filter_with_preimage",
      "type": "Bool",
      "description": "Optimize Date and DateTime predicates by converting functions into equivalent comparisons without conversions (e.g. `toYear(col) = 2023 -> col >= '2023-01-01' AND col <= '2023-12-31'`)"
    },
    {
      "name": "optimize_trivial_approximate_count_query",
      "type": "Bool",
      "description": "Use an approximate value for trivial count optimization of storages that support such estimation, for example, EmbeddedRocksDB.\n\nPossible values:\n\n   - 0 — Optimization disabled.\n   - 1 — Optimization enabled."
    },
    {
      "name": "optimize_trivial_count_query",
      "type": "Bool",
      "description": "Enables or disables the optimization to trivial query `SELECT count() FROM table` using metadata from MergeTree. If you need to use row-level security, disable this setting.\n\nPossible values:\n\n   - 0 — Optimization disabled.\n   - 1 — Optimization enabled.\n\nSee also:\n\n- [optimize_functions_to_subcolumns](#optimize_functions_to_subcolumns)"
    },
    {
      "name": "optimize_trivial_insert_select",
      "type": "Bool",
      "description": "Optimize trivial 'INSERT INTO table SELECT ... FROM TABLES' query"
    },
    {
      "name": "optimize_uniq_to_count",
      "type": "Bool",
      "description": "Rewrite uniq and its variants(except uniqUpTo) to count if subquery has distinct or group by clause."
    },
    {
      "name": "optimize_use_implicit_projections",
      "type": "Bool",
      "description": "Automatically choose implicit projections to perform SELECT query"
    },
    {
      "name": "optimize_use_projection_filtering",
      "type": "Bool",
      "description": "Enables using projections to filter part ranges even when projections are not selected to perform SELECT query."
    },
    {
      "name": "optimize_use_projections",
      "type": "Bool",
      "description": "Enables or disables [projection](../../engines/table-engines/mergetree-family/mergetree.md/#projections) optimization when processing `SELECT` queries.\n\nPossible values:\n\n- 0 — Projection optimization disabled.\n- 1 — Projection optimization enabled."
    },
    {
      "name": "optimize_using_constraints",
      "type": "Bool",
      "description": "Use [constraints](../../sql-reference/statements/create/table.md/#constraints) for query optimization. The default is `false`.\n\nPossible values:\n\n- true, false"
    },
    {
      "name": "os_thread_priority",
      "type": "Int64",
      "description": "Sets the priority ([nice](https://en.wikipedia.org/wiki/Nice_(Unix))) for threads that execute queries. The OS scheduler considers this priority when choosing the next thread to run on each available CPU core.\n\n:::note\nTo use this setting, you need to set the `CAP_SYS_NICE` capability. The `clickhouse-server` package sets it up during installation. Some virtual environments do not allow you to set the `CAP_SYS_NICE` capability. In this case, `clickhouse-server` shows a message about it at the start.\n:::\n\nPossible values:\n\n- You can set values in the range `[-20, 19]`.\n\nLower values mean higher priority. Threads with low `nice` priority values are executed more frequently than threads with high values. High values are preferable for long-running non-interactive queries because it allows them to quickly give up resources in favour of short interactive queries when they arrive."
    },
    {
      "name": "output_format_arrow_compression_method",
      "type": "ArrowCompression",
      "description": "Compression method for Arrow output format. Supported codecs: lz4_frame, zstd, none (uncompressed)"
    },
    {
      "name": "output_format_arrow_fixed_string_as_fixed_byte_array",
      "type": "Bool",
      "description": "Use Arrow FIXED_SIZE_BINARY type instead of Binary for FixedString columns."
    },
    {
      "name": "output_format_arrow_low_cardinality_as_dictionary",
      "type": "Bool",
      "description": "Enable output LowCardinality type as Dictionary Arrow type"
    },
    {
      "name": "output_format_arrow_string_as_string",
      "type": "Bool",
      "description": "Use Arrow String type instead of Binary for String columns"
    },
    {
      "name": "output_format_arrow_use_64_bit_indexes_for_dictionary",
      "type": "Bool",
      "description": "Always use 64 bit integers for dictionary indexes in Arrow format"
    },
    {
      "name": "output_format_arrow_use_signed_indexes_for_dictionary",
      "type": "Bool",
      "description": "Use signed integers for dictionary indexes in Arrow format"
    },
    {
      "name": "output_format_avro_codec",
      "type": "String",
      "description": "Compression codec used for output. Possible values: 'null', 'deflate', 'snappy', 'zstd'."
    },
    {
      "name": "output_format_avro_rows_in_file",
      "type": "UInt64",
      "description": "Max rows in a file (if permitted by storage)"
    },
    {
      "name": "output_format_avro_string_column_pattern",
      "type": "String",
      "description": "For Avro format: regexp of String columns to select as AVRO string."
    },
    {
      "name": "output_format_avro_sync_interval",
      "type": "UInt64",
      "description": "Sync interval in bytes."
    },
    {
      "name": "output_format_binary_encode_types_in_binary_format",
      "type": "Bool",
      "description": "Write data types in binary format instead of type names in RowBinaryWithNamesAndTypes output format"
    },
    {
      "name": "output_format_binary_write_json_as_string",
      "type": "Bool",
      "description": "Write values of [JSON](../../sql-reference/data-types/newjson.md) data type as JSON [String](../../sql-reference/data-types/string.md) values in RowBinary output format."
    },
    {
      "name": "output_format_bson_string_as_string",
      "type": "Bool",
      "description": "Use BSON String type instead of Binary for String columns."
    },
    {
      "name": "output_format_compression_level",
      "type": "UInt64",
      "description": "Default compression level if query output is compressed. The setting is applied when `SELECT` query has `INTO OUTFILE` or when writing to table functions `file`, `url`, `hdfs`, `s3`, or `azureBlobStorage`.\n\nPossible values: from `1` to `22`"
    },
    {
      "name": "output_format_compression_zstd_window_log",
      "type": "UInt64",
      "description": "Can be used when the output compression method is `zstd`. If greater than `0`, this setting explicitly sets compression window size (power of `2`) and enables a long-range mode for zstd compression. This can help to achieve a better compression ratio.\n\nPossible values: non-negative numbers. Note that if the value is too small or too big, `zstdlib` will throw an exception. Typical values are from `20` (window size = `1MB`) to `30` (window size = `1GB`)."
    },
    {
      "name": "output_format_csv_crlf_end_of_line",
      "type": "Bool",
      "description": "If it is set true, end of line in CSV format will be \\\\r\\\\n instead of \\\\n."
    },
    {
      "name": "output_format_csv_serialize_tuple_into_separate_columns",
      "type": "Bool",
      "description": "If it set to true, then Tuples in CSV format are serialized as separate columns (that is, their nesting in the tuple is lost)"
    },
    {
      "name": "output_format_decimal_trailing_zeros",
      "type": "Bool",
      "description": "Output trailing zeros when printing Decimal values. E.g. 1.230000 instead of 1.23.\n\nDisabled by default."
    },
    {
      "name": "output_format_enable_streaming",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "output_format_json_array_of_rows",
      "type": "Bool",
      "description": "Enables the ability to output all rows as a JSON array in the [JSONEachRow](/interfaces/formats/JSONEachRow) format.\n\nPossible values:\n\n- 1 — ClickHouse outputs all rows as an array, each row in the `JSONEachRow` format.\n- 0 — ClickHouse outputs each row separately in the `JSONEachRow` format.\n\n**Example of a query with the enabled setting**\n\nQuery:\n\n```sql\nSET output_format_json_array_of_rows = 1;\nSELECT number FROM numbers(3) FORMAT JSONEachRow;\n```\n\nResult:\n\n```text\n[\n{\"number\":\"0\"},\n{\"number\":\"1\"},\n{\"number\":\"2\"}\n]\n```\n\n**Example of a query with the disabled setting**\n\nQuery:\n\n```sql\nSET output_format_json_array_of_rows = 0;\nSELECT number FROM numbers(3) FORMAT JSONEachRow;\n```\n\nResult:\n\n```text\n{\"number\":\"0\"}\n{\"number\":\"1\"}\n{\"number\":\"2\"}\n```"
    },
    {
      "name": "output_format_json_escape_forward_slashes",
      "type": "Bool",
      "description": "Controls escaping forward slashes for string outputs in JSON output format. This is intended for compatibility with JavaScript. Don't confuse with backslashes that are always escaped.\n\nEnabled by default."
    },
    {
      "name": "output_format_json_named_tuples_as_objects",
      "type": "Bool",
      "description": "Serialize named tuple columns as JSON objects.\n\nEnabled by default."
    },
    {
      "name": "output_format_json_pretty_print",
      "type": "Bool",
      "description": "When enabled, values of complex data types like Tuple/Array/Map in JSON output format in 'data' section will be printed in pretty format.\n\nEnabled by default."
    },
    {
      "name": "output_format_json_quote_64bit_floats",
      "type": "Bool",
      "description": "Controls quoting of 64-bit [floats](../../sql-reference/data-types/float.md) when they are output in JSON* formats.\n\nDisabled by default."
    },
    {
      "name": "output_format_json_quote_64bit_integers",
      "type": "Bool",
      "description": "Controls quoting of 64-bit or bigger [integers](../../sql-reference/data-types/int-uint.md) (like `UInt64` or `Int128`) when they are output in a [JSON](/interfaces/formats/JSON) format.\nSuch integers are enclosed in quotes by default. This behavior is compatible with most JavaScript implementations.\n\nPossible values:\n\n- 0 — Integers are output without quotes.\n- 1 — Integers are enclosed in quotes."
    },
    {
      "name": "output_format_json_quote_decimals",
      "type": "Bool",
      "description": "Controls quoting of decimals in JSON output formats.\n\nDisabled by default."
    },
    {
      "name": "output_format_json_quote_denormals",
      "type": "Bool",
      "description": "Enables `+nan`, `-nan`, `+inf`, `-inf` outputs in [JSON](/interfaces/formats/JSON) output format.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\n**Example**\n\nConsider the following table `account_orders`:\n\n```text\n┌─id─┬─name───┬─duration─┬─period─┬─area─┐\n│  1 │ Andrew │       20 │      0 │  400 │\n│  2 │ John   │       40 │      0 │    0 │\n│  3 │ Bob    │       15 │      0 │ -100 │\n└────┴────────┴──────────┴────────┴──────┘\n```\n\nWhen `output_format_json_quote_denormals = 0`, the query returns `null` values in output:\n\n```sql\nSELECT area/period FROM account_orders FORMAT JSON;\n```\n\n```json\n{\n        \"meta\":\n        [\n                {\n                        \"name\": \"divide(area, period)\",\n                        \"type\": \"Float64\"\n                }\n        ],\n\n        \"data\":\n        [\n                {\n                        \"divide(area, period)\": null\n                },\n                {\n                        \"divide(area, period)\": null\n                },\n                {\n                        \"divide(area, period)\": null\n                }\n        ],\n\n        \"rows\": 3,\n\n        \"statistics\":\n        {\n                \"elapsed\": 0.003648093,\n                \"rows_read\": 3,\n                \"bytes_read\": 24\n        }\n}\n```\n\nWhen `output_format_json_quote_denormals = 1`, the query returns:\n\n```json\n{\n        \"meta\":\n        [\n                {\n                        \"name\": \"divide(area, period)\",\n                        \"type\": \"Float64\"\n                }\n        ],\n\n        \"data\":\n        [\n                {\n                        \"divide(area, period)\": \"inf\"\n                },\n                {\n                        \"divide(area, period)\": \"-nan\"\n                },\n                {\n                        \"divide(area, period)\": \"-inf\"\n                }\n        ],\n\n        \"rows\": 3,\n\n        \"statistics\":\n        {\n                \"elapsed\": 0.000070241,\n                \"rows_read\": 3,\n                \"bytes_read\": 24\n        }\n}\n```"
    },
    {
      "name": "output_format_json_skip_null_value_in_named_tuples",
      "type": "Bool",
      "description": "Skip key value pairs with null value when serialize named tuple columns as JSON objects. It is only valid when output_format_json_named_tuples_as_objects is true."
    },
    {
      "name": "output_format_json_validate_utf8",
      "type": "Bool",
      "description": "Controls validation of UTF-8 sequences in JSON output formats, doesn't impact formats JSON/JSONCompact/JSONColumnsWithMetadata, they always validate UTF-8.\n\nDisabled by default."
    },
    {
      "name": "output_format_markdown_escape_special_characters",
      "type": "Bool",
      "description": "When enabled, escape special characters in Markdown.\n\n[Common Mark](https://spec.commonmark.org/0.30/#example-12) defines the following special characters that can be escaped by \\:\n\n```\n! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~\n```\n\nPossible values:\n\n+ 0 — Disable.\n+ 1 — Enable."
    },
    {
      "name": "output_format_msgpack_uuid_representation",
      "type": "MsgPackUUIDRepresentation",
      "description": "The way how to output UUID in MsgPack format."
    },
    {
      "name": "output_format_native_encode_types_in_binary_format",
      "type": "Bool",
      "description": "Write data types in binary format instead of type names in Native output format"
    },
    {
      "name": "output_format_native_use_flattened_dynamic_and_json_serialization",
      "type": "Bool",
      "description": "Write data of [JSON](../../sql-reference/data-types/newjson.md) and [Dynamic](../../sql-reference/data-types/dynamic.md) columns in a flattened format (all types/paths as separate subcolumns)."
    },
    {
      "name": "output_format_native_write_json_as_string",
      "type": "Bool",
      "description": "Write data of [JSON](../../sql-reference/data-types/newjson.md) column as [String](../../sql-reference/data-types/string.md) column containing JSON strings instead of default native JSON serialization."
    },
    {
      "name": "output_format_orc_compression_method",
      "type": "ORCCompression",
      "description": "Compression method for ORC output format. Supported codecs: lz4, snappy, zlib, zstd, none (uncompressed)"
    },
    {
      "name": "output_format_orc_dictionary_key_size_threshold",
      "type": "Double",
      "description": "For a string column in ORC output format, if the number of distinct values is greater than this fraction of the total number of non-null rows, turn off dictionary encoding. Otherwise dictionary encoding is enabled"
    },
    {
      "name": "output_format_orc_row_index_stride",
      "type": "UInt64",
      "description": "Target row index stride in ORC output format"
    },
    {
      "name": "output_format_orc_string_as_string",
      "type": "Bool",
      "description": "Use ORC String type instead of Binary for String columns"
    },
    {
      "name": "output_format_orc_writer_time_zone_name",
      "type": "String",
      "description": "The time zone name for ORC writer, the default ORC writer's time zone is GMT."
    },
    {
      "name": "output_format_parallel_formatting",
      "type": "Bool",
      "description": "Enables or disables parallel formatting of data formats. Supported only for [TSV](../../interfaces/formats.md/#tabseparated), [TSKV](../../interfaces/formats.md/#tskv), [CSV](../../interfaces/formats.md/#csv) and [JSONEachRow](../../interfaces/formats.md/#jsoneachrow) formats.\n\nPossible values:\n\n- 1 — Enabled.\n- 0 — Disabled."
    },
    {
      "name": "output_format_parquet_batch_size",
      "type": "NonZeroUInt64",
      "description": "Check page size every this many rows. Consider decreasing if you have columns with average values size above a few KBs."
    },
    {
      "name": "output_format_parquet_bloom_filter_bits_per_value",
      "type": "Double",
      "description": "Approximate number of bits to use for each distinct value in parquet bloom filters. Estimated false positive rates:\n  *  6   bits - 10%\n  * 10.5 bits -  1%\n  * 16.9 bits -  0.1%\n  * 26.4 bits -  0.01%\n  * 41   bits -  0.001%"
    },
    {
      "name": "output_format_parquet_bloom_filter_flush_threshold_bytes",
      "type": "UInt64",
      "description": "Where in the parquet file to place the bloom filters. Bloom filters will be written in groups of approximately this size. In particular:\n  * if 0, each row group's bloom filters are written immediately after the row group,\n  * if greater than the total size of all bloom filters, bloom filters for all row groups will be accumulated in memory, then written together near the end of the file,\n  * otherwise, bloom filters will be accumulated in memory and written out whenever their total size goes above this value."
    },
    {
      "name": "output_format_parquet_compliant_nested_types",
      "type": "Bool",
      "description": "In parquet file schema, use name 'element' instead of 'item' for list elements. This is a historical artifact of Arrow library implementation. Generally increases compatibility, except perhaps with some old versions of Arrow."
    },
    {
      "name": "output_format_parquet_compression_method",
      "type": "ParquetCompression",
      "description": "Compression method for Parquet output format. Supported codecs: snappy, lz4, brotli, zstd, gzip, none (uncompressed)"
    },
    {
      "name": "output_format_parquet_data_page_size",
      "type": "UInt64",
      "description": "Target page size in bytes, before compression."
    },
    {
      "name": "output_format_parquet_date_as_uint16",
      "type": "Bool",
      "description": "Write Date values as plain 16-bit numbers (read back as UInt16), instead of converting to a 32-bit parquet DATE type (read back as Date32)."
    },
    {
      "name": "output_format_parquet_datetime_as_uint32",
      "type": "Bool",
      "description": "Write DateTime values as raw unix timestamp (read back as UInt32), instead of converting to milliseconds (read back as DateTime64(3))."
    },
    {
      "name": "output_format_parquet_fixed_string_as_fixed_byte_array",
      "type": "Bool",
      "description": "Use Parquet FIXED_LENGTH_BYTE_ARRAY type instead of Binary for FixedString columns."
    },
    {
      "name": "output_format_parquet_parallel_encoding",
      "type": "Bool",
      "description": "Do Parquet encoding in multiple threads. Requires output_format_parquet_use_custom_encoder."
    },
    {
      "name": "output_format_parquet_row_group_size",
      "type": "UInt64",
      "description": "Target row group size in rows."
    },
    {
      "name": "output_format_parquet_row_group_size_bytes",
      "type": "UInt64",
      "description": "Target row group size in bytes, before compression."
    },
    {
      "name": "output_format_parquet_string_as_string",
      "type": "Bool",
      "description": "Use Parquet String type instead of Binary for String columns."
    },
    {
      "name": "output_format_parquet_use_custom_encoder",
      "type": "Bool",
      "description": "Use a faster Parquet encoder implementation."
    },
    {
      "name": "output_format_parquet_version",
      "type": "ParquetVersion",
      "description": "Parquet format version for output format. Supported versions: 1.0, 2.4, 2.6 and 2.latest (default)"
    },
    {
      "name": "output_format_parquet_write_bloom_filter",
      "type": "Bool",
      "description": "Write bloom filters in parquet files. Requires output_format_parquet_use_custom_encoder = true."
    },
    {
      "name": "output_format_parquet_write_page_index",
      "type": "Bool",
      "description": "Write column index and offset index (i.e. statistics about each data page, which may be used for filter pushdown on read) into parquet files."
    },
    {
      "name": "output_format_pretty_color",
      "type": "UInt64Auto",
      "description": "Use ANSI escape sequences in Pretty formats. 0 - disabled, 1 - enabled, 'auto' - enabled if a terminal."
    },
    {
      "name": "output_format_pretty_display_footer_column_names",
      "type": "UInt64",
      "description": "Display column names in the footer if there are many table rows.\n\nPossible values:\n\n- 0 — No column names are displayed in the footer.\n- 1 — Column names are displayed in the footer if row count is greater than or equal to the threshold value set by [output_format_pretty_display_footer_column_names_min_rows](#output_format_pretty_display_footer_column_names_min_rows) (50 by default).\n\n**Example**\n\nQuery:\n\n```sql\nSELECT *, toTypeName(*) FROM (SELECT * FROM system.numbers LIMIT 1000);\n```\n\nResult:\n\n```response\n      ┌─number─┬─toTypeName(number)─┐\n   1. │      0 │ UInt64             │\n   2. │      1 │ UInt64             │\n   3. │      2 │ UInt64             │\n   ...\n 999. │    998 │ UInt64             │\n1000. │    999 │ UInt64             │\n      └─number─┴─toTypeName(number)─┘\n```"
    },
    {
      "name": "output_format_pretty_display_footer_column_names_min_rows",
      "type": "UInt64",
      "description": "Sets the minimum number of rows for which a footer with column names will be displayed if setting [output_format_pretty_display_footer_column_names](#output_format_pretty_display_footer_column_names) is enabled."
    },
    {
      "name": "output_format_pretty_fallback_to_vertical",
      "type": "Bool",
      "description": "If enabled, and the table is wide but short, the Pretty format will output it as the Vertical format does.\nSee `output_format_pretty_fallback_to_vertical_max_rows_per_chunk` and `output_format_pretty_fallback_to_vertical_min_table_width` for detailed tuning of this behavior."
    },
    {
      "name": "output_format_pretty_fallback_to_vertical_max_rows_per_chunk",
      "type": "UInt64",
      "description": "The fallback to Vertical format (see `output_format_pretty_fallback_to_vertical`) will be activated only if the number of records in a chunk is not more than the specified value."
    },
    {
      "name": "output_format_pretty_fallback_to_vertical_min_columns",
      "type": "UInt64",
      "description": "The fallback to Vertical format (see `output_format_pretty_fallback_to_vertical`) will be activated only if the number of columns is greater than the specified value."
    },
    {
      "name": "output_format_pretty_fallback_to_vertical_min_table_width",
      "type": "UInt64",
      "description": "The fallback to Vertical format (see `output_format_pretty_fallback_to_vertical`) will be activated only if the sum of lengths of columns in a table is at least the specified value, or if at least one value contains a newline character."
    },
    {
      "name": "output_format_pretty_glue_chunks",
      "type": "UInt64Auto",
      "description": "If the data rendered in Pretty formats arrived in multiple chunks, even after a delay, but the next chunk has the same column widths as the previous, use ANSI escape sequences to move back to the previous line and overwrite the footer of the previous chunk to continue it with the data of the new chunk. This makes the result more visually pleasant.\n\n0 - disabled, 1 - enabled, 'auto' - enabled if a terminal."
    },
    {
      "name": "output_format_pretty_grid_charset",
      "type": "String",
      "description": "Charset for printing grid borders. Available charsets: ASCII, UTF-8 (default one)."
    },
    {
      "name": "output_format_pretty_highlight_digit_groups",
      "type": "Bool",
      "description": "If enabled and if output is a terminal, highlight every digit corresponding to the number of thousands, millions, etc. with underline."
    },
    {
      "name": "output_format_pretty_highlight_trailing_spaces",
      "type": "Bool",
      "description": "If enabled and if output is a terminal, highlight trailing spaces with a gray color and underline."
    },
    {
      "name": "output_format_pretty_max_column_name_width_cut_to",
      "type": "UInt64",
      "description": "If the column name is too long, cut it to this length.\nThe column will be cut if it is longer than `output_format_pretty_max_column_name_width_cut_to` plus `output_format_pretty_max_column_name_width_min_chars_to_cut`."
    },
    {
      "name": "output_format_pretty_max_column_name_width_min_chars_to_cut",
      "type": "UInt64",
      "description": "Minimum characters to cut if the column name is too long.\nThe column will be cut if it is longer than `output_format_pretty_max_column_name_width_cut_to` plus `output_format_pretty_max_column_name_width_min_chars_to_cut`."
    },
    {
      "name": "output_format_pretty_max_column_pad_width",
      "type": "UInt64",
      "description": "Maximum width to pad all values in a column in Pretty formats."
    },
    {
      "name": "output_format_pretty_max_rows",
      "type": "UInt64",
      "description": "Rows limit for Pretty formats."
    },
    {
      "name": "output_format_pretty_max_value_width",
      "type": "UInt64",
      "description": "Maximum width of value to display in Pretty formats. If greater - it will be cut.\nThe value 0 means - never cut."
    },
    {
      "name": "output_format_pretty_max_value_width_apply_for_single_value",
      "type": "UInt64",
      "description": "Only cut values (see the `output_format_pretty_max_value_width` setting) when it is not a single value in a block. Otherwise output it entirely, which is useful for the `SHOW CREATE TABLE` query."
    },
    {
      "name": "output_format_pretty_multiline_fields",
      "type": "Bool",
      "description": "If enabled, Pretty formats will render multi-line fields inside table cell, so the table's outline will be preserved.\nIf not, they will be rendered as is, potentially deforming the table (one upside of keeping it off is that copy-pasting multi-line values will be easier)."
    },
    {
      "name": "output_format_pretty_row_numbers",
      "type": "Bool",
      "description": "Add row numbers before each row for pretty output format"
    },
    {
      "name": "output_format_pretty_single_large_number_tip_threshold",
      "type": "UInt64",
      "description": "Print a readable number tip on the right side of the table if the block consists of a single number which exceeds this value (except 0)"
    },
    {
      "name": "output_format_pretty_squash_consecutive_ms",
      "type": "UInt64",
      "description": "Wait for the next block for up to specified number of milliseconds and squash it to the previous before writing.\nThis avoids frequent output of too small blocks, but still allows to display data in a streaming fashion."
    },
    {
      "name": "output_format_pretty_squash_max_wait_ms",
      "type": "UInt64",
      "description": "Output the pending block in pretty formats if more than the specified number of milliseconds has passed since the previous output."
    },
    {
      "name": "output_format_protobuf_nullables_with_google_wrappers",
      "type": "Bool",
      "description": "When serializing Nullable columns with Google wrappers, serialize default values as empty wrappers. If turned off, default and null values are not serialized"
    },
    {
      "name": "output_format_schema",
      "type": "String",
      "description": "The path to the file where the automatically generated schema will be saved in [Cap'n Proto](/interfaces/formats/CapnProto) or [Protobuf](/interfaces/formats/Protobuf) formats."
    },
    {
      "name": "output_format_sql_insert_include_column_names",
      "type": "Bool",
      "description": "Include column names in INSERT query"
    },
    {
      "name": "output_format_sql_insert_max_batch_size",
      "type": "UInt64",
      "description": "The maximum number  of rows in one INSERT statement."
    },
    {
      "name": "output_format_sql_insert_quote_names",
      "type": "Bool",
      "description": "Quote column names with '`' characters"
    },
    {
      "name": "output_format_sql_insert_table_name",
      "type": "String",
      "description": "The name of table in the output INSERT query"
    },
    {
      "name": "output_format_sql_insert_use_replace",
      "type": "Bool",
      "description": "Use REPLACE statement instead of INSERT"
    },
    {
      "name": "output_format_tsv_crlf_end_of_line",
      "type": "Bool",
      "description": "If it is set true, end of line in TSV format will be \\\\r\\\\n instead of \\\\n."
    },
    {
      "name": "output_format_values_escape_quote_with_quote",
      "type": "Bool",
      "description": "If true escape ' with '', otherwise quoted with \\\\'"
    },
    {
      "name": "output_format_write_statistics",
      "type": "Bool",
      "description": "Write statistics about read rows, bytes, time elapsed in suitable output formats.\n\nEnabled by default"
    },
    {
      "name": "page_cache_block_size",
      "type": "UInt64",
      "description": "Size of file chunks to store in the userspace page cache, in bytes. All reads that go through the cache will be rounded up to a multiple of this size.\n\nThis setting can be adjusted on a per-query level basis, but cache entries with different block sizes cannot be reused. Changing this setting effectively invalidates existing entries in the cache.\n\nA higher value, like 1 MiB is good for high-throughput queries, and a lower value, like 64 KiB is good for low-latency point queries."
    },
    {
      "name": "page_cache_inject_eviction",
      "type": "Bool",
      "description": "Userspace page cache will sometimes invalidate some pages at random. Intended for testing."
    },
    {
      "name": "page_cache_lookahead_blocks",
      "type": "UInt64",
      "description": "On userspace page cache miss, read up to this many consecutive blocks at once from the underlying storage, if they're also not in the cache. Each block is page_cache_block_size bytes.\n\nA higher value is good for high-throughput queries, while low-latency point queries will work better without readahead."
    },
    {
      "name": "parallel_distributed_insert_select",
      "type": "UInt64",
      "description": "Enables parallel distributed `INSERT ... SELECT` query.\n\nIf we execute `INSERT INTO distributed_table_a SELECT ... FROM distributed_table_b` queries and both tables use the same cluster, and both tables are either [replicated](../../engines/table-engines/mergetree-family/replication.md) or non-replicated, then this query is processed locally on every shard.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — `SELECT` will be executed on each shard from the underlying table of the distributed engine.\n- 2 — `SELECT` and `INSERT` will be executed on each shard from/to the underlying table of the distributed engine."
    },
    {
      "name": "parallel_hash_join_threshold",
      "type": "UInt64",
      "description": "When hash-based join algorithm is applied, this threshold helps to decide between using `hash` and `parallel_hash` (only if estimation of the right table size is available).\nThe former is used when we know that the right table size is below the threshold."
    },
    {
      "name": "parallel_replica_offset",
      "type": "UInt64",
      "description": "This is internal setting that should not be used directly and represents an implementation detail of the 'parallel replicas' mode. This setting will be automatically set up by the initiator server for distributed queries to the index of the replica participating in query processing among parallel replicas."
    },
    {
      "name": "parallel_replicas_allow_in_with_subquery",
      "type": "Bool",
      "description": "If true, subquery for IN will be executed on every follower replica."
    },
    {
      "name": "parallel_replicas_connect_timeout_ms",
      "type": "Milliseconds",
      "description": "The timeout in milliseconds for connecting to a remote replica during query execution with parallel replicas. If the timeout is expired, the corresponding replicas is not used for query execution"
    },
    {
      "name": "parallel_replicas_count",
      "type": "UInt64",
      "description": "This is internal setting that should not be used directly and represents an implementation detail of the 'parallel replicas' mode. This setting will be automatically set up by the initiator server for distributed queries to the number of parallel replicas participating in query processing."
    },
    {
      "name": "parallel_replicas_custom_key",
      "type": "String",
      "description": "An arbitrary integer expression that can be used to split work between replicas for a specific table.\nThe value can be any integer expression.\n\nSimple expressions using primary keys are preferred.\n\nIf the setting is used on a cluster that consists of a single shard with multiple replicas, those replicas will be converted into virtual shards.\nOtherwise, it will behave same as for `SAMPLE` key, it will use multiple replicas of each shard."
    },
    {
      "name": "parallel_replicas_custom_key_filter_type",
      "type": "ParallelReplicasCustomKeyFilterType",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "parallel_replicas_custom_key_range_lower",
      "type": "UInt64",
      "description": "Allows the filter type `range` to split the work evenly between replicas based on the custom range `[parallel_replicas_custom_key_range_lower, INT_MAX]`.\n\nWhen used in conjunction with [parallel_replicas_custom_key_range_upper](#parallel_replicas_custom_key_range_upper), it lets the filter evenly split the work over replicas for the range `[parallel_replicas_custom_key_range_lower, parallel_replicas_custom_key_range_upper]`.\n\nNote: This setting will not cause any additional data to be filtered during query processing, rather it changes the points at which the range filter breaks up the range `[0, INT_MAX]` for parallel processing."
    },
    {
      "name": "parallel_replicas_custom_key_range_upper",
      "type": "UInt64",
      "description": "Allows the filter type `range` to split the work evenly between replicas based on the custom range `[0, parallel_replicas_custom_key_range_upper]`. A value of 0 disables the upper bound, setting it the max value of the custom key expression.\n\nWhen used in conjunction with [parallel_replicas_custom_key_range_lower](#parallel_replicas_custom_key_range_lower), it lets the filter evenly split the work over replicas for the range `[parallel_replicas_custom_key_range_lower, parallel_replicas_custom_key_range_upper]`.\n\nNote: This setting will not cause any additional data to be filtered during query processing, rather it changes the points at which the range filter breaks up the range `[0, INT_MAX]` for parallel processing"
    },
    {
      "name": "parallel_replicas_for_cluster_engines",
      "type": "Bool",
      "description": "Replace table function engines with their -Cluster alternatives"
    },
    {
      "name": "parallel_replicas_for_non_replicated_merge_tree",
      "type": "Bool",
      "description": "If true, ClickHouse will use parallel replicas algorithm also for non-replicated MergeTree tables"
    },
    {
      "name": "parallel_replicas_index_analysis_only_on_coordinator",
      "type": "Bool",
      "description": "Index analysis done only on replica-coordinator and skipped on other replicas. Effective only with enabled parallel_replicas_local_plan"
    },
    {
      "name": "parallel_replicas_insert_select_local_pipeline",
      "type": "Bool",
      "description": "Use local pipeline during distributed INSERT SELECT with parallel replicas"
    },
    {
      "name": "parallel_replicas_local_plan",
      "type": "Bool",
      "description": "Build local plan for local replica"
    },
    {
      "name": "parallel_replicas_mark_segment_size",
      "type": "UInt64",
      "description": "Parts virtually divided into segments to be distributed between replicas for parallel reading. This setting controls the size of these segments. Not recommended to change until you're absolutely sure in what you're doing. Value should be in range [128; 16384]"
    },
    {
      "name": "parallel_replicas_min_number_of_granules_to_enable",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "parallel_replicas_min_number_of_rows_per_replica",
      "type": "UInt64",
      "description": "Limit the number of replicas used in a query to (estimated rows to read / min_number_of_rows_per_replica). The max is still limited by 'max_parallel_replicas'"
    },
    {
      "name": "parallel_replicas_mode",
      "type": "ParallelReplicasMode",
      "description": "Type of filter to use with custom key for parallel replicas. default - use modulo operation on the custom key, range - use range filter on custom key using all possible values for the value type of custom key."
    },
    {
      "name": "parallel_replicas_only_with_analyzer",
      "type": "Bool",
      "description": "The analyzer should be enabled to use parallel replicas. With disabled analyzer query execution fallbacks to local execution, even if parallel reading from replicas is enabled. Using parallel replicas without the analyzer enabled is not supported"
    },
    {
      "name": "parallel_replicas_prefer_local_join",
      "type": "Bool",
      "description": "If true, and JOIN can be executed with parallel replicas algorithm, and all storages of right JOIN part are *MergeTree, local JOIN will be used instead of GLOBAL JOIN."
    },
    {
      "name": "parallel_replicas_single_task_marks_count_multiplier",
      "type": "Float",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "parallel_view_processing",
      "type": "Bool",
      "description": "Enables pushing to attached views concurrently instead of sequentially."
    },
    {
      "name": "parallelize_output_from_storages",
      "type": "Bool",
      "description": "Parallelize output for reading step from storage. It allows parallelization of query processing right after reading from storage if possible"
    },
    {
      "name": "parsedatetime_e_requires_space_padding",
      "type": "Bool",
      "description": "Formatter '%e' in function 'parseDateTime' expects that single-digit days are space-padded, e.g., ' 2' is accepted but '2' raises an error.\n    "
    },
    {
      "name": "parsedatetime_parse_without_leading_zeros",
      "type": "Bool",
      "description": "Formatters '%c', '%l' and '%k' in function 'parseDateTime' parse months and hours without leading zeros."
    },
    {
      "name": "partial_merge_join_left_table_buffer_bytes",
      "type": "UInt64",
      "description": "If not 0 group left table blocks in bigger ones for left-side table in partial merge join. It uses up to 2x of specified memory per joining thread."
    },
    {
      "name": "partial_merge_join_optimizations",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "partial_merge_join_rows_in_right_blocks",
      "type": "UInt64",
      "description": "Limits sizes of right-hand join data blocks in partial merge join algorithm for [JOIN](../../sql-reference/statements/select/join.md) queries.\n\nClickHouse server:\n\n1.  Splits right-hand join data into blocks with up to the specified number of rows.\n2.  Indexes each block with its minimum and maximum values.\n3.  Unloads prepared blocks to disk if it is possible.\n\nPossible values:\n\n- Any positive integer. Recommended range of values: \\[1000, 100000\\]."
    },
    {
      "name": "partial_result_on_first_cancel",
      "type": "Bool",
      "description": "Allows query to return a partial result after cancel."
    },
    {
      "name": "parts_to_delay_insert",
      "type": "UInt64",
      "description": "If the destination table contains at least that many active parts in a single partition, artificially slow down insert into table."
    },
    {
      "name": "parts_to_throw_insert",
      "type": "UInt64",
      "description": "If more than this number active parts in a single partition of the destination table, throw 'Too many parts ...' exception."
    },
    {
      "name": "periodic_live_view_refresh",
      "type": "Seconds",
      "description": "Interval after which periodically refreshed live view is forced to refresh."
    },
    {
      "name": "poll_interval",
      "type": "UInt64",
      "description": "Block at the query wait loop on the server for the specified number of seconds."
    },
    {
      "name": "postgresql_connection_attempt_timeout",
      "type": "UInt64",
      "description": "Connection timeout in seconds of a single attempt to connect PostgreSQL end-point.\nThe value is passed as a `connect_timeout` parameter of the connection URL."
    },
    {
      "name": "postgresql_connection_pool_auto_close_connection",
      "type": "Bool",
      "description": "Close connection before returning connection to the pool."
    },
    {
      "name": "postgresql_connection_pool_retries",
      "type": "UInt64",
      "description": "Connection pool push/pop retries number for PostgreSQL table engine and database engine."
    },
    {
      "name": "postgresql_connection_pool_size",
      "type": "UInt64",
      "description": "Connection pool size for PostgreSQL table engine and database engine."
    },
    {
      "name": "postgresql_connection_pool_wait_timeout",
      "type": "UInt64",
      "description": "Connection pool push/pop timeout on empty pool for PostgreSQL table engine and database engine. By default it will block on empty pool."
    },
    {
      "name": "postgresql_fault_injection_probability",
      "type": "Float",
      "description": "Approximate probability of failing internal (for replication) PostgreSQL queries. Valid value is in interval [0.0f, 1.0f]"
    },
    {
      "name": "precise_float_parsing",
      "type": "Bool",
      "description": "Prefer more precise (but slower) float parsing algorithm"
    },
    {
      "name": "prefer_column_name_to_alias",
      "type": "Bool",
      "description": "Enables or disables using the original column names instead of aliases in query expressions and clauses. It especially matters when alias is the same as the column name, see [Expression Aliases](/sql-reference/syntax#notes-on-usage). Enable this setting to make aliases syntax rules in ClickHouse more compatible with most other database engines.\n\nPossible values:\n\n- 0 — The column name is substituted with the alias.\n- 1 — The column name is not substituted with the alias.\n\n**Example**\n\nThe difference between enabled and disabled:\n\nQuery:\n\n```sql\nSET prefer_column_name_to_alias = 0;\nSELECT avg(number) AS number, max(number) FROM numbers(10);\n```\n\nResult:\n\n```text\nReceived exception from server (version 21.5.1):\nCode: 184. DB::Exception: Received from localhost:9000. DB::Exception: Aggregate function avg(number) is found inside another aggregate function in query: While processing avg(number) AS number.\n```\n\nQuery:\n\n```sql\nSET prefer_column_name_to_alias = 1;\nSELECT avg(number) AS number, max(number) FROM numbers(10);\n```\n\nResult:\n\n```text\n┌─number─┬─max(number)─┐\n│    4.5 │           9 │\n└────────┴─────────────┘\n```"
    },
    {
      "name": "prefer_external_sort_block_bytes",
      "type": "UInt64",
      "description": "Prefer maximum block bytes for external sort, reduce the memory usage during merging."
    },
    {
      "name": "prefer_global_in_and_join",
      "type": "Bool",
      "description": "Enables the replacement of `IN`/`JOIN` operators with `GLOBAL IN`/`GLOBAL JOIN`.\n\nPossible values:\n\n- 0 — Disabled. `IN`/`JOIN` operators are not replaced with `GLOBAL IN`/`GLOBAL JOIN`.\n- 1 — Enabled. `IN`/`JOIN` operators are replaced with `GLOBAL IN`/`GLOBAL JOIN`.\n\n**Usage**\n\nAlthough `SET distributed_product_mode=global` can change the queries behavior for the distributed tables, it's not suitable for local tables or tables from external resources. Here is when the `prefer_global_in_and_join` setting comes into play.\n\nFor example, we have query serving nodes that contain local tables, which are not suitable for distribution. We need to scatter their data on the fly during distributed processing with the `GLOBAL` keyword — `GLOBAL IN`/`GLOBAL JOIN`.\n\nAnother use case of `prefer_global_in_and_join` is accessing tables created by external engines. This setting helps to reduce the number of calls to external sources while joining such tables: only one call per query.\n\n**See also:**\n\n- [Distributed subqueries](/sql-reference/operators/in#distributed-subqueries) for more information on how to use `GLOBAL IN`/`GLOBAL JOIN`"
    },
    {
      "name": "prefer_localhost_replica",
      "type": "Bool",
      "description": "Enables/disables preferable using the localhost replica when processing distributed queries.\n\nPossible values:\n\n- 1 — ClickHouse always sends a query to the localhost replica if it exists.\n- 0 — ClickHouse uses the balancing strategy specified by the [load_balancing](#load_balancing) setting.\n\n:::note\nDisable this setting if you use [max_parallel_replicas](#max_parallel_replicas) without [parallel_replicas_custom_key](#parallel_replicas_custom_key).\nIf [parallel_replicas_custom_key](#parallel_replicas_custom_key) is set, disable this setting only if it's used on a cluster with multiple shards containing multiple replicas.\nIf it's used on a cluster with a single shard and multiple replicas, disabling this setting will have negative effects.\n:::"
    },
    {
      "name": "prefer_warmed_unmerged_parts_seconds",
      "type": "Int64",
      "description": "Only has an effect in ClickHouse Cloud. If a merged part is less than this many seconds old and is not pre-warmed (see [cache_populated_by_fetch](merge-tree-settings.md/#cache_populated_by_fetch)), but all its source parts are available and pre-warmed, SELECT queries will read from those parts instead. Only for Replicated-/SharedMergeTree. Note that this only checks whether CacheWarmer processed the part; if the part was fetched into cache by something else, it'll still be considered cold until CacheWarmer gets to it; if it was warmed, then evicted from cache, it'll still be considered warm."
    },
    {
      "name": "preferred_block_size_bytes",
      "type": "UInt64",
      "description": "This setting adjusts the data block size for query processing and represents additional fine-tuning to the more rough 'max_block_size' setting. If the columns are large and with 'max_block_size' rows the block size is likely to be larger than the specified amount of bytes, its size will be lowered for better CPU cache locality."
    },
    {
      "name": "preferred_max_column_in_block_size_bytes",
      "type": "UInt64",
      "description": "Limit on max column size in block while reading. Helps to decrease cache misses count. Should be close to L2 cache size."
    },
    {
      "name": "preferred_optimize_projection_name",
      "type": "String",
      "description": "If it is set to a non-empty string, ClickHouse will try to apply specified projection in query.\n\n\nPossible values:\n\n- string: name of preferred projection"
    },
    {
      "name": "prefetch_buffer_size",
      "type": "UInt64",
      "description": "The maximum size of the prefetch buffer to read from the filesystem."
    },
    {
      "name": "print_pretty_type_names",
      "type": "Bool",
      "description": "Allows to print deep-nested type names in a pretty way with indents in `DESCRIBE` query and in `toTypeName()` function.\n\nExample:\n\n```sql\nCREATE TABLE test (a Tuple(b String, c Tuple(d Nullable(UInt64), e Array(UInt32), f Array(Tuple(g String, h Map(String, Array(Tuple(i String, j UInt64))))), k Date), l Nullable(String))) ENGINE=Memory;\nDESCRIBE TABLE test FORMAT TSVRaw SETTINGS print_pretty_type_names=1;\n```\n\n```\na   Tuple(\n    b String,\n    c Tuple(\n        d Nullable(UInt64),\n        e Array(UInt32),\n        f Array(Tuple(\n            g String,\n            h Map(\n                String,\n                Array(Tuple(\n                    i String,\n                    j UInt64\n                ))\n            )\n        )),\n        k Date\n    ),\n    l Nullable(String)\n)\n```"
    },
    {
      "name": "priority",
      "type": "UInt64",
      "description": "Priority of the query. 1 - the highest, higher value - lower priority; 0 - do not use priorities."
    },
    {
      "name": "push_external_roles_in_interserver_queries",
      "type": "Bool",
      "description": "Enable pushing user roles from originator to other nodes while performing a query."
    },
    {
      "name": "query_cache_compress_entries",
      "type": "Bool",
      "description": "Compress entries in the [query cache](../query-cache.md). Lessens the memory consumption of the query cache at the cost of slower inserts into / reads from it.\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "query_cache_max_entries",
      "type": "UInt64",
      "description": "The maximum number of query results the current user may store in the [query cache](../query-cache.md). 0 means unlimited.\n\nPossible values:\n\n- Positive integer >= 0."
    },
    {
      "name": "query_cache_max_size_in_bytes",
      "type": "UInt64",
      "description": "The maximum amount of memory (in bytes) the current user may allocate in the [query cache](../query-cache.md). 0 means unlimited.\n\nPossible values:\n\n- Positive integer >= 0."
    },
    {
      "name": "query_cache_min_query_duration",
      "type": "Milliseconds",
      "description": "Minimum duration in milliseconds a query needs to run for its result to be stored in the [query cache](../query-cache.md).\n\nPossible values:\n\n- Positive integer >= 0."
    },
    {
      "name": "query_cache_min_query_runs",
      "type": "UInt64",
      "description": "Minimum number of times a `SELECT` query must run before its result is stored in the [query cache](../query-cache.md).\n\nPossible values:\n\n- Positive integer >= 0."
    },
    {
      "name": "query_cache_nondeterministic_function_handling",
      "type": "QueryResultCacheNondeterministicFunctionHandling",
      "description": "Controls how the [query cache](../query-cache.md) handles `SELECT` queries with non-deterministic functions like `rand()` or `now()`.\n\nPossible values:\n\n- `'throw'` - Throw an exception and don't cache the query result.\n- `'save'` - Cache the query result.\n- `'ignore'` - Don't cache the query result and don't throw an exception."
    },
    {
      "name": "query_cache_share_between_users",
      "type": "Bool",
      "description": "If turned on, the result of `SELECT` queries cached in the [query cache](../query-cache.md) can be read by other users.\nIt is not recommended to enable this setting due to security reasons.\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "query_cache_squash_partial_results",
      "type": "Bool",
      "description": "Squash partial result blocks to blocks of size [max_block_size](#max_block_size). Reduces performance of inserts into the [query cache](../query-cache.md) but improves the compressability of cache entries (see [query_cache_compress-entries](#query_cache_compress_entries)).\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "query_cache_store_results_of_queries_with_nondeterministic_functions",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "query_cache_system_table_handling",
      "type": "QueryResultCacheSystemTableHandling",
      "description": "Controls how the [query cache](../query-cache.md) handles `SELECT` queries against system tables, i.e. tables in databases `system.*` and `information_schema.*`.\n\nPossible values:\n\n- `'throw'` - Throw an exception and don't cache the query result.\n- `'save'` - Cache the query result.\n- `'ignore'` - Don't cache the query result and don't throw an exception."
    },
    {
      "name": "query_cache_tag",
      "type": "String",
      "description": "A string which acts as a label for [query cache](../query-cache.md) entries.\nThe same queries with different tags are considered different by the query cache.\n\nPossible values:\n\n- Any string"
    },
    {
      "name": "query_cache_ttl",
      "type": "Seconds",
      "description": "After this time in seconds entries in the [query cache](../query-cache.md) become stale.\n\nPossible values:\n\n- Positive integer >= 0."
    },
    {
      "name": "query_condition_cache_store_conditions_as_plaintext",
      "type": "Bool",
      "description": "Stores the filter condition for the [query condition cache](/operations/query-condition-cache) in plaintext.\nIf enabled, system.query_condition_cache shows the verbatim filter condition which makes it easier to debug issues with the cache.\nDisabled by default because plaintext filter conditions may expose sensitive information.\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "query_metric_log_interval",
      "type": "Int64",
      "description": "The interval in milliseconds at which the [query_metric_log](../../operations/system-tables/query_metric_log.md) for individual queries is collected.\n\nIf set to any negative value, it will take the value `collect_interval_milliseconds` from the [query_metric_log setting](/operations/server-configuration-parameters/settings#query_metric_log) or default to 1000 if not present.\n\nTo disable the collection of a single query, set `query_metric_log_interval` to 0.\n\nDefault value: -1\n    "
    },
    {
      "name": "query_plan_aggregation_in_order",
      "type": "Bool",
      "description": "Toggles the aggregation in-order query-plan-level optimization.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_convert_join_to_in",
      "type": "Bool",
      "description": "Allow to convert `JOIN` to subquery with `IN` if output columns tied to only left table. May cause wrong results with non-ANY JOINs (e.g. ALL JOINs which is the default)."
    },
    {
      "name": "query_plan_convert_outer_join_to_inner_join",
      "type": "Bool",
      "description": "Allow to convert `OUTER JOIN` to `INNER JOIN` if filter after `JOIN` always filters default values"
    },
    {
      "name": "query_plan_enable_multithreading_after_window_functions",
      "type": "Bool",
      "description": "Enable multithreading after evaluating window functions to allow parallel stream processing"
    },
    {
      "name": "query_plan_enable_optimizations",
      "type": "Bool",
      "description": "Toggles query optimization at the query plan level.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable all optimizations at the query plan level\n- 1 - Enable optimizations at the query plan level (but individual optimizations may still be disabled via their individual settings)"
    },
    {
      "name": "query_plan_execute_functions_after_sorting",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which moves expressions after sorting steps.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_filter_push_down",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which moves filters down in the execution plan.\nOnly takes effect if setting [query_plan_enable_optimizations](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_join_shard_by_pk_ranges",
      "type": "Bool",
      "description": "Apply sharding for JOIN if join keys contain a prefix of PRIMARY KEY for both tables. Supported for hash, parallel_hash and full_sorting_merge algorithms. Usually does not speed up queries but may lower memory consumption.\n "
    },
    {
      "name": "query_plan_join_swap_table",
      "type": "BoolAuto",
      "description": "    Determine which side of the join should be the build table (also called inner, the one inserted into the hash table for a hash join) in the query plan. This setting is supported only for `ALL` join strictness with the `JOIN ON` clause. Possible values are:\n    - 'auto': Let the planner decide which table to use as the build table.\n    - 'false': Never swap tables (the right table is the build table).\n    - 'true': Always swap tables (the left table is the build table)."
    },
    {
      "name": "query_plan_lift_up_array_join",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which moves ARRAY JOINs up in the execution plan.\nOnly takes effect if setting [query_plan_enable_optimizations](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_lift_up_union",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which moves larger subtrees of the query plan into union to enable further optimizations.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_max_limit_for_lazy_materialization",
      "type": "UInt64",
      "description": "Control maximum limit value that allows to use query plan for lazy materialization optimization. If zero, there is no limit."
    },
    {
      "name": "query_plan_max_optimizations_to_apply",
      "type": "UInt64",
      "description": "Limits the total number of optimizations applied to query plan, see setting [query_plan_enable_optimizations](#query_plan_enable_optimizations).\nUseful to avoid long optimization times for complex queries.\nIn the EXPLAIN PLAN query, stop applying optimizations after this limit is reached and return the plan as is.\nFor regular query execution if the actual number of optimizations exceeds this setting, an exception is thrown.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::"
    },
    {
      "name": "query_plan_merge_expressions",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which merges consecutive filters.\nOnly takes effect if setting [query_plan_enable_optimizations](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_merge_filter_into_join_condition",
      "type": "Bool",
      "description": "Allow to merge filter into `JOIN` condition and convert `CROSS JOIN` to `INNER`."
    },
    {
      "name": "query_plan_merge_filters",
      "type": "Bool",
      "description": "Allow to merge filters in the query plan."
    },
    {
      "name": "query_plan_optimize_lazy_materialization",
      "type": "Bool",
      "description": "Use query plan for lazy materialization optimization."
    },
    {
      "name": "query_plan_optimize_prewhere",
      "type": "Bool",
      "description": "Allow to push down filter to PREWHERE expression for supported storages"
    },
    {
      "name": "query_plan_optimize_primary_key",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "query_plan_optimize_projection",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "query_plan_push_down_limit",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which moves LIMITs down in the execution plan.\nOnly takes effect if setting [query_plan_enable_optimizations](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_read_in_order",
      "type": "Bool",
      "description": "Toggles the read in-order optimization query-plan-level optimization.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_remove_redundant_distinct",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which removes redundant DISTINCT steps.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_remove_redundant_sorting",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which removes redundant sorting steps, e.g. in subqueries.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_reuse_storage_ordering_for_window_functions",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which uses storage sorting when sorting for window functions.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_split_filter",
      "type": "Bool",
      "description": ":::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nToggles a query-plan-level optimization which splits filters into expressions.\nOnly takes effect if setting [query_plan_enable_optimizations](#query_plan_enable_optimizations) is 1.\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_try_use_vector_search",
      "type": "Bool",
      "description": "Toggles a query-plan-level optimization which tries to use the vector similarity index.\nOnly takes effect if setting [`query_plan_enable_optimizations`](#query_plan_enable_optimizations) is 1.\n\n:::note\nThis is an expert-level setting which should only be used for debugging by developers. The setting may change in future in backward-incompatible ways or be removed.\n:::\n\nPossible values:\n\n- 0 - Disable\n- 1 - Enable"
    },
    {
      "name": "query_plan_use_new_logical_join_step",
      "type": "Bool",
      "description": "Use new logical join step in query plan."
    },
    {
      "name": "query_profiler_cpu_time_period_ns",
      "type": "UInt64",
      "description": "Sets the period for a CPU clock timer of the [query profiler](../../operations/optimizing-performance/sampling-query-profiler.md). This timer counts only CPU time.\n\nPossible values:\n\n- A positive integer number of nanoseconds.\n\n    Recommended values:\n\n            - 10000000 (100 times a second) nanoseconds and more for single queries.\n            - 1000000000 (once a second) for cluster-wide profiling.\n\n- 0 for turning off the timer.\n\n**Temporarily disabled in ClickHouse Cloud.**\n\nSee also:\n\n- System table [trace_log](/operations/system-tables/trace_log)"
    },
    {
      "name": "query_profiler_real_time_period_ns",
      "type": "UInt64",
      "description": "Sets the period for a real clock timer of the [query profiler](../../operations/optimizing-performance/sampling-query-profiler.md). Real clock timer counts wall-clock time.\n\nPossible values:\n\n- Positive integer number, in nanoseconds.\n\n    Recommended values:\n\n            - 10000000 (100 times a second) nanoseconds and less for single queries.\n            - 1000000000 (once a second) for cluster-wide profiling.\n\n- 0 for turning off the timer.\n\n**Temporarily disabled in ClickHouse Cloud.**\n\nSee also:\n\n- System table [trace_log](/operations/system-tables/trace_log)"
    },
    {
      "name": "queue_max_wait_ms",
      "type": "Milliseconds",
      "description": "The wait time in the request queue, if the number of concurrent requests exceeds the maximum."
    },
    {
      "name": "rabbitmq_max_wait_ms",
      "type": "Milliseconds",
      "description": "The wait time for reading from RabbitMQ before retry."
    },
    {
      "name": "read_backoff_max_throughput",
      "type": "UInt64",
      "description": "Settings to reduce the number of threads in case of slow reads. Count events when the read bandwidth is less than that many bytes per second."
    },
    {
      "name": "read_backoff_min_concurrency",
      "type": "UInt64",
      "description": "Settings to try keeping the minimal number of threads in case of slow reads."
    },
    {
      "name": "read_backoff_min_events",
      "type": "UInt64",
      "description": "Settings to reduce the number of threads in case of slow reads. The number of events after which the number of threads will be reduced."
    },
    {
      "name": "read_backoff_min_interval_between_events_ms",
      "type": "Milliseconds",
      "description": "Settings to reduce the number of threads in case of slow reads. Do not pay attention to the event, if the previous one has passed less than a certain amount of time."
    },
    {
      "name": "read_backoff_min_latency_ms",
      "type": "Milliseconds",
      "description": "Setting to reduce the number of threads in case of slow reads. Pay attention only to reads that took at least that much time."
    },
    {
      "name": "read_from_filesystem_cache_if_exists_otherwise_bypass_cache",
      "type": "Bool",
      "description": "Allow to use the filesystem cache in passive mode - benefit from the existing cache entries, but don't put more entries into the cache. If you set this setting for heavy ad-hoc queries and leave it disabled for short real-time queries, this will allows to avoid cache threshing by too heavy queries and to improve the overall system efficiency."
    },
    {
      "name": "read_from_page_cache_if_exists_otherwise_bypass_cache",
      "type": "Bool",
      "description": "Use userspace page cache in passive mode, similar to read_from_filesystem_cache_if_exists_otherwise_bypass_cache."
    },
    {
      "name": "read_in_order_two_level_merge_threshold",
      "type": "UInt64",
      "description": "Minimal number of parts to read to run preliminary merge step during multithread reading in order of primary key."
    },
    {
      "name": "read_in_order_use_buffering",
      "type": "Bool",
      "description": "Use buffering before merging while reading in order of primary key. It increases the parallelism of query execution"
    },
    {
      "name": "read_in_order_use_virtual_row",
      "type": "Bool",
      "description": "Use virtual row while reading in order of primary key or its monotonic function fashion. It is useful when searching over multiple parts as only relevant ones are touched."
    },
    {
      "name": "read_overflow_mode",
      "type": "OverflowMode",
      "description": "What to do when the limit is exceeded."
    },
    {
      "name": "read_overflow_mode_leaf",
      "type": "OverflowMode",
      "description": "Sets what happens when the volume of data read exceeds one of the leaf limits.\n\nPossible options:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result."
    },
    {
      "name": "read_priority",
      "type": "Int64",
      "description": "Priority to read data from local filesystem or remote filesystem. Only supported for 'pread_threadpool' method for local filesystem and for `threadpool` method for remote filesystem."
    },
    {
      "name": "read_through_distributed_cache",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Allow reading from distributed cache"
    },
    {
      "name": "readonly",
      "type": "UInt64",
      "description": "0 - no read-only restrictions. 1 - only read requests, as well as changing explicitly allowed settings. 2 - only read requests, as well as changing settings, except for the 'readonly' setting."
    },
    {
      "name": "receive_data_timeout_ms",
      "type": "Milliseconds",
      "description": "Connection timeout for receiving first packet of data or packet with positive progress from replica"
    },
    {
      "name": "receive_timeout",
      "type": "Seconds",
      "description": "Timeout for receiving data from the network, in seconds. If no bytes were received in this interval, the exception is thrown. If you set this setting on the client, the 'send_timeout' for the socket will also be set on the corresponding connection end on the server."
    },
    {
      "name": "regexp_dict_allow_hyperscan",
      "type": "Bool",
      "description": "Allow regexp_tree dictionary using Hyperscan library."
    },
    {
      "name": "regexp_dict_flag_case_insensitive",
      "type": "Bool",
      "description": "Use case-insensitive matching for a regexp_tree dictionary. Can be overridden in individual expressions with (?i) and (?-i)."
    },
    {
      "name": "regexp_dict_flag_dotall",
      "type": "Bool",
      "description": "Allow '.' to match newline characters for a regexp_tree dictionary."
    },
    {
      "name": "regexp_max_matches_per_row",
      "type": "UInt64",
      "description": "Sets the maximum number of matches for a single regular expression per row. Use it to protect against memory overload when using greedy regular expression in the [extractAllGroupsHorizontal](/sql-reference/functions/string-search-functions#extractallgroupshorizontal) function.\n\nPossible values:\n\n- Positive integer."
    },
    {
      "name": "reject_expensive_hyperscan_regexps",
      "type": "Bool",
      "description": "Reject patterns which will likely be expensive to evaluate with hyperscan (due to NFA state explosion)"
    },
    {
      "name": "remerge_sort_lowered_memory_bytes_ratio",
      "type": "Float",
      "description": "If memory usage after remerge does not reduced by this ratio, remerge will be disabled."
    },
    {
      "name": "remote_filesystem_read_method",
      "type": "String",
      "description": "Method of reading data from remote filesystem, one of: read, threadpool."
    },
    {
      "name": "remote_filesystem_read_prefetch",
      "type": "Bool",
      "description": "Should use prefetching when reading data from remote filesystem."
    },
    {
      "name": "remote_fs_read_backoff_max_tries",
      "type": "UInt64",
      "description": "Max attempts to read with backoff"
    },
    {
      "name": "remote_fs_read_max_backoff_ms",
      "type": "UInt64",
      "description": "Max wait time when trying to read data for remote disk"
    },
    {
      "name": "remote_read_min_bytes_for_seek",
      "type": "UInt64",
      "description": "Min bytes required for remote read (url, s3) to do seek, instead of read with ignore."
    },
    {
      "name": "rename_files_after_processing",
      "type": "String",
      "description": "- **Type:** String\n\n- **Default value:** Empty string\n\nThis setting allows to specify renaming pattern for files processed by `file` table function. When option is set, all files read by `file` table function will be renamed according to specified pattern with placeholders, only if files processing was successful.\n\n### Placeholders\n\n- `%a` — Full original filename (e.g., \"sample.csv\").\n- `%f` — Original filename without extension (e.g., \"sample\").\n- `%e` — Original file extension with dot (e.g., \".csv\").\n- `%t` — Timestamp (in microseconds).\n- `%%` — Percentage sign (\"%\").\n\n### Example\n- Option: `--rename_files_after_processing=\"processed_%f_%t%e\"`\n\n- Query: `SELECT * FROM file('sample.csv')`\n\n\nIf reading `sample.csv` is successful, file will be renamed to `processed_sample_1683473210851438.csv`"
    },
    {
      "name": "replace_running_query",
      "type": "Bool",
      "description": "When using the HTTP interface, the 'query_id' parameter can be passed. This is any string that serves as the query identifier.\nIf a query from the same user with the same 'query_id' already exists at this time, the behaviour depends on the 'replace_running_query' parameter.\n\n`0` (default) – Throw an exception (do not allow the query to run if a query with the same 'query_id' is already running).\n\n`1` – Cancel the old query and start running the new one.\n\nSet this parameter to 1 for implementing suggestions for segmentation conditions. After entering the next character, if the old query hasn't finished yet, it should be cancelled."
    },
    {
      "name": "replace_running_query_max_wait_ms",
      "type": "Milliseconds",
      "description": "The wait time for running the query with the same `query_id` to finish, when the [replace_running_query](#replace_running_query) setting is active.\n\nPossible values:\n\n- Positive integer.\n- 0 — Throwing an exception that does not allow to run a new query if the server already executes a query with the same `query_id`."
    },
    {
      "name": "replication_alter_columns_timeout",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replication_alter_partitions_sync",
      "type": "UInt64",
      "description": "Allows to set up waiting for actions to be executed on replicas by [ALTER](../../sql-reference/statements/alter/index.md), [OPTIMIZE](../../sql-reference/statements/optimize.md) or [TRUNCATE](../../sql-reference/statements/truncate.md) queries.\n\nPossible values:\n\n- 0 — Do not wait.\n- 1 — Wait for own execution.\n- 2 — Wait for everyone.\n\nCloud default value: `0`.\n\n:::note\n`alter_sync` is applicable to `Replicated` tables only, it does nothing to alters of not `Replicated` tables.\n:::"
    },
    {
      "name": "replication_wait_for_inactive_replica_timeout",
      "type": "Int64",
      "description": "Specifies how long (in seconds) to wait for inactive replicas to execute [ALTER](../../sql-reference/statements/alter/index.md), [OPTIMIZE](../../sql-reference/statements/optimize.md) or [TRUNCATE](../../sql-reference/statements/truncate.md) queries.\n\nPossible values:\n\n- 0 — Do not wait.\n- Negative integer — Wait for unlimited time.\n- Positive integer — The number of seconds to wait."
    },
    {
      "name": "restore_replace_external_dictionary_source_to_null",
      "type": "Bool",
      "description": "Replace external dictionary sources to Null on restore. Useful for testing purposes"
    },
    {
      "name": "restore_replace_external_engines_to_null",
      "type": "Bool",
      "description": "For testing purposes. Replaces all external engines to Null to not initiate external connections."
    },
    {
      "name": "restore_replace_external_table_functions_to_null",
      "type": "Bool",
      "description": "For testing purposes. Replaces all external table functions to Null to not initiate external connections."
    },
    {
      "name": "restore_replicated_merge_tree_to_shared_merge_tree",
      "type": "Bool",
      "description": "Replace table engine from Replicated*MergeTree -> Shared*MergeTree during RESTORE."
    },
    {
      "name": "restore_threads",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "result_overflow_mode",
      "type": "OverflowMode",
      "description": "Cloud default value: `throw`\n\nSets what to do if the volume of the result exceeds one of the limits.\n\nPossible values:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result, as if the\n           source data ran out.\n\nUsing 'break' is similar to using LIMIT. `Break` interrupts execution only at the\nblock level. This means that amount of returned rows is greater than\n[`max_result_rows`](/operations/settings/settings#max_result_rows), multiple of [`max_block_size`](/operations/settings/settings#max_block_size)\nand depends on [`max_threads`](/operations/settings/settings#max_threads).\n\n**Example**\n\n```sql title=\"Query\"\nSET max_threads = 3, max_block_size = 3333;\nSET max_result_rows = 3334, result_overflow_mode = 'break';\n\nSELECT *\nFROM numbers_mt(100000)\nFORMAT Null;\n```\n\n```text title=\"Result\"\n6666 rows in set. ...\n```"
    },
    {
      "name": "rewrite_count_distinct_if_with_count_distinct_implementation",
      "type": "Bool",
      "description": "Allows you to rewrite `countDistcintIf` with [count_distinct_implementation](#count_distinct_implementation) setting.\n\nPossible values:\n\n- true — Allow.\n- false — Disallow."
    },
    {
      "name": "rows_before_aggregation",
      "type": "Bool",
      "description": "When enabled, ClickHouse will provide exact value for rows_before_aggregation statistic, represents the number of rows read before aggregation"
    },
    {
      "name": "s3_allow_multipart_copy",
      "type": "Bool",
      "description": "Allow multipart copy in S3."
    },
    {
      "name": "s3_allow_parallel_part_upload",
      "type": "Bool",
      "description": "Use multiple threads for s3 multipart upload. It may lead to slightly higher memory usage"
    },
    {
      "name": "s3_check_objects_after_upload",
      "type": "Bool",
      "description": "Check each uploaded object to s3 with head request to be sure that upload was successful"
    },
    {
      "name": "s3_connect_timeout_ms",
      "type": "UInt64",
      "description": "Connection timeout for host from s3 disks."
    },
    {
      "name": "s3_create_new_file_on_insert",
      "type": "Bool",
      "description": "Enables or disables creating a new file on each insert in s3 engine tables. If enabled, on each insert a new S3 object will be created with the key, similar to this pattern:\n\ninitial: `data.Parquet.gz` -> `data.1.Parquet.gz` -> `data.2.Parquet.gz`, etc.\n\nPossible values:\n- 0 — `INSERT` query creates a new file or fail if file exists and s3_truncate_on_insert is not set.\n- 1 — `INSERT` query creates a new file on each insert using suffix (from the second one) if s3_truncate_on_insert is not set.\n\nSee more details [here](/integrations/s3#inserting-data)."
    },
    {
      "name": "s3_disable_checksum",
      "type": "Bool",
      "description": "Do not calculate a checksum when sending a file to S3. This speeds up writes by avoiding excessive processing passes on a file. It is mostly safe as the data of MergeTree tables is checksummed by ClickHouse anyway, and when S3 is accessed with HTTPS, the TLS layer already provides integrity while transferring through the network. While additional checksums on S3 give defense in depth."
    },
    {
      "name": "s3_ignore_file_doesnt_exist",
      "type": "Bool",
      "description": "Ignore absence of file if it does not exist when reading certain keys.\n\nPossible values:\n- 1 — `SELECT` returns empty result.\n- 0 — `SELECT` throws an exception."
    },
    {
      "name": "s3_list_object_keys_size",
      "type": "UInt64",
      "description": "Maximum number of files that could be returned in batch by ListObject request"
    },
    {
      "name": "s3_max_connections",
      "type": "UInt64",
      "description": "The maximum number of connections per server."
    },
    {
      "name": "s3_max_get_burst",
      "type": "UInt64",
      "description": "Max number of requests that can be issued simultaneously before hitting request per second limit. By default (0) equals to `s3_max_get_rps`"
    },
    {
      "name": "s3_max_get_rps",
      "type": "UInt64",
      "description": "Limit on S3 GET request per second rate before throttling. Zero means unlimited."
    },
    {
      "name": "s3_max_inflight_parts_for_one_file",
      "type": "UInt64",
      "description": "The maximum number of a concurrent loaded parts in multipart upload request. 0 means unlimited."
    },
    {
      "name": "s3_max_part_number",
      "type": "UInt64",
      "description": "Maximum part number number for s3 upload part."
    },
    {
      "name": "s3_max_put_burst",
      "type": "UInt64",
      "description": "Max number of requests that can be issued simultaneously before hitting request per second limit. By default (0) equals to `s3_max_put_rps`"
    },
    {
      "name": "s3_max_put_rps",
      "type": "UInt64",
      "description": "Limit on S3 PUT request per second rate before throttling. Zero means unlimited."
    },
    {
      "name": "s3_max_redirects",
      "type": "UInt64",
      "description": "Max number of S3 redirects hops allowed."
    },
    {
      "name": "s3_max_single_operation_copy_size",
      "type": "UInt64",
      "description": "Maximum size for single-operation copy in s3. This setting is used only if s3_allow_multipart_copy is true."
    },
    {
      "name": "s3_max_single_part_upload_size",
      "type": "UInt64",
      "description": "The maximum size of object to upload using singlepart upload to S3."
    },
    {
      "name": "s3_max_single_read_retries",
      "type": "UInt64",
      "description": "The maximum number of retries during single S3 read."
    },
    {
      "name": "s3_max_unexpected_write_error_retries",
      "type": "UInt64",
      "description": "The maximum number of retries in case of unexpected errors during S3 write."
    },
    {
      "name": "s3_max_upload_part_size",
      "type": "UInt64",
      "description": "The maximum size of part to upload during multipart upload to S3."
    },
    {
      "name": "s3_min_upload_part_size",
      "type": "UInt64",
      "description": "The minimum size of part to upload during multipart upload to S3."
    },
    {
      "name": "s3_request_timeout_ms",
      "type": "UInt64",
      "description": "Idleness timeout for sending and receiving data to/from S3. Fail if a single TCP read or write call blocks for this long."
    },
    {
      "name": "s3_retry_attempts",
      "type": "UInt64",
      "description": "Setting for Aws::Client::RetryStrategy, Aws::Client does retries itself, 0 means no retries"
    },
    {
      "name": "s3_skip_empty_files",
      "type": "Bool",
      "description": "Enables or disables skipping empty files in [S3](../../engines/table-engines/integrations/s3.md) engine tables.\n\nPossible values:\n- 0 — `SELECT` throws an exception if empty file is not compatible with requested format.\n- 1 — `SELECT` returns empty result for empty file."
    },
    {
      "name": "s3_slow_all_threads_after_network_error",
      "type": "Bool",
      "description": "When set to `true`, all threads executing S3 requests to the same backup endpoint are slowed down\nafter any single s3 request encounters a retryable network error, such as socket timeout.\nWhen set to `false`, each thread handles S3 request backoff independently of the others."
    },
    {
      "name": "s3_slow_all_threads_after_retryable_error",
      "type": "Bool",
      "description": "When set to `true`, all threads executing S3 requests to the same endpoint are slowed down\nafter any single S3 request encounters a retryable S3 error, such as 'Slow Down'.\nWhen set to `false`, each thread handles s3 request backoff independently of the others."
    },
    {
      "name": "s3_strict_upload_part_size",
      "type": "UInt64",
      "description": "The exact size of part to upload during multipart upload to S3 (some implementations does not supports variable size parts)."
    },
    {
      "name": "s3_throw_on_zero_files_match",
      "type": "Bool",
      "description": "Throw an error, when ListObjects request cannot match any files"
    },
    {
      "name": "s3_truncate_on_insert",
      "type": "Bool",
      "description": "Enables or disables truncate before inserts in s3 engine tables. If disabled, an exception will be thrown on insert attempts if an S3 object already exists.\n\nPossible values:\n- 0 — `INSERT` query creates a new file or fail if file exists and s3_create_new_file_on_insert is not set.\n- 1 — `INSERT` query replaces existing content of the file with the new data.\n\nSee more details [here](/integrations/s3#inserting-data)."
    },
    {
      "name": "s3_upload_part_size_multiply_factor",
      "type": "UInt64",
      "description": "Multiply s3_min_upload_part_size by this factor each time s3_multiply_parts_count_threshold parts were uploaded from a single write to S3."
    },
    {
      "name": "s3_upload_part_size_multiply_parts_count_threshold",
      "type": "UInt64",
      "description": "Each time this number of parts was uploaded to S3, s3_min_upload_part_size is multiplied by s3_upload_part_size_multiply_factor."
    },
    {
      "name": "s3_use_adaptive_timeouts",
      "type": "Bool",
      "description": "When set to `true` than for all s3 requests first two attempts are made with low send and receive timeouts.\nWhen set to `false` than all attempts are made with identical timeouts."
    },
    {
      "name": "s3_validate_request_settings",
      "type": "Bool",
      "description": "Enables s3 request settings validation.\n\nPossible values:\n- 1 — validate settings.\n- 0 — do not validate settings."
    },
    {
      "name": "s3queue_allow_experimental_sharded_mode",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "s3queue_default_zookeeper_path",
      "type": "String",
      "description": "Default zookeeper path prefix for S3Queue engine"
    },
    {
      "name": "s3queue_enable_logging_to_s3queue_log",
      "type": "Bool",
      "description": "Enable writing to system.s3queue_log. The value can be overwritten per table with table settings"
    },
    {
      "name": "s3queue_migrate_old_metadata_to_buckets",
      "type": "Bool",
      "description": "Migrate old metadata structure of S3Queue table to a new one"
    },
    {
      "name": "schema_inference_cache_require_modification_time_for_url",
      "type": "Bool",
      "description": "Use schema from cache for URL with last modification time validation (for URLs with Last-Modified header)"
    },
    {
      "name": "schema_inference_hints",
      "type": "String",
      "description": "The list of column names and types to use as hints in schema inference for formats without schema.\n\nExample:\n\nQuery:\n```sql\ndesc format(JSONEachRow, '{\"x\" : 1, \"y\" : \"String\", \"z\" : \"0.0.0.0\" }') settings schema_inference_hints='x UInt8, z IPv4';\n```\n\nResult:\n```sql\nx   UInt8\ny   Nullable(String)\nz   IPv4\n```\n\n:::note\nIf the `schema_inference_hints` is not formatted properly, or if there is a typo or a wrong datatype, etc... the whole schema_inference_hints will be ignored.\n:::"
    },
    {
      "name": "schema_inference_make_columns_nullable",
      "type": "UInt64Auto",
      "description": "Controls making inferred types `Nullable` in schema inference.\nIf the setting is enabled, all inferred type will be `Nullable`, if disabled, the inferred type will never be `Nullable`, if set to `auto`, the inferred type will be `Nullable` only if the column contains `NULL` in a sample that is parsed during schema inference or file metadata contains information about column nullability."
    },
    {
      "name": "schema_inference_make_json_columns_nullable",
      "type": "Bool",
      "description": "Controls making inferred JSON types `Nullable` in schema inference.\nIf this setting is enabled together with schema_inference_make_columns_nullable, inferred JSON type will be `Nullable`."
    },
    {
      "name": "schema_inference_mode",
      "type": "SchemaInferenceMode",
      "description": "Mode of schema inference. 'default' - assume that all files have the same schema and schema can be inferred from any file, 'union' - files can have different schemas and the resulting schema should be the a union of schemas of all files"
    },
    {
      "name": "schema_inference_use_cache_for_azure",
      "type": "Bool",
      "description": "Use cache in schema inference while using azure table function"
    },
    {
      "name": "schema_inference_use_cache_for_file",
      "type": "Bool",
      "description": "Use cache in schema inference while using file table function"
    },
    {
      "name": "schema_inference_use_cache_for_hdfs",
      "type": "Bool",
      "description": "Use cache in schema inference while using hdfs table function"
    },
    {
      "name": "schema_inference_use_cache_for_s3",
      "type": "Bool",
      "description": "Use cache in schema inference while using s3 table function"
    },
    {
      "name": "schema_inference_use_cache_for_url",
      "type": "Bool",
      "description": "Use cache in schema inference while using url table function"
    },
    {
      "name": "secondary_indices_enable_bulk_filtering",
      "type": "Bool",
      "description": "Enable the bulk filtering algorithm for indices. It is expected to be always better, but we have this setting for compatibility and control."
    },
    {
      "name": "select_sequential_consistency",
      "type": "UInt64",
      "description": ":::note\nThis setting differ in behavior between SharedMergeTree and ReplicatedMergeTree, see [SharedMergeTree consistency](/cloud/reference/shared-merge-tree#consistency) for more information about the behavior of `select_sequential_consistency` in SharedMergeTree.\n:::\n\nEnables or disables sequential consistency for `SELECT` queries. Requires `insert_quorum_parallel` to be disabled (enabled by default).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\nUsage\n\nWhen sequential consistency is enabled, ClickHouse allows the client to execute the `SELECT` query only for those replicas that contain data from all previous `INSERT` queries executed with `insert_quorum`. If the client refers to a partial replica, ClickHouse will generate an exception. The SELECT query will not include data that has not yet been written to the quorum of replicas.\n\nWhen `insert_quorum_parallel` is enabled (the default), then `select_sequential_consistency` does not work. This is because parallel `INSERT` queries can be written to different sets of quorum replicas so there is no guarantee a single replica will have received all writes.\n\nSee also:\n\n- [insert_quorum](#insert_quorum)\n- [insert_quorum_timeout](#insert_quorum_timeout)\n- [insert_quorum_parallel](#insert_quorum_parallel)"
    },
    {
      "name": "send_logs_level",
      "type": "LogsLevel",
      "description": "Send server text logs with specified minimum level to client. Valid values: 'trace', 'debug', 'information', 'warning', 'error', 'fatal', 'none'"
    },
    {
      "name": "send_logs_source_regexp",
      "type": "String",
      "description": "Send server text logs with specified regexp to match log source name. Empty means all sources."
    },
    {
      "name": "send_progress_in_http_headers",
      "type": "Bool",
      "description": "Enables or disables `X-ClickHouse-Progress` HTTP response headers in `clickhouse-server` responses.\n\nFor more information, read the [HTTP interface description](../../interfaces/http.md).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "send_timeout",
      "type": "Seconds",
      "description": "Timeout for sending data to the network, in seconds. If a client needs to send some data but is not able to send any bytes in this interval, the exception is thrown. If you set this setting on the client, the 'receive_timeout' for the socket will also be set on the corresponding connection end on the server."
    },
    {
      "name": "serialize_query_plan",
      "type": "Bool",
      "description": "Serialize query plan for distributed processing"
    },
    {
      "name": "session_timezone",
      "type": "Timezone",
      "description": "Sets the implicit time zone of the current session or query.\nThe implicit time zone is the time zone applied to values of type DateTime/DateTime64 which have no explicitly specified time zone.\nThe setting takes precedence over the globally configured (server-level) implicit time zone.\nA value of '' (empty string) means that the implicit time zone of the current session or query is equal to the [server time zone](../server-configuration-parameters/settings.md/#timezone).\n\nYou can use functions `timeZone()` and `serverTimeZone()` to get the session time zone and server time zone.\n\nPossible values:\n\n-    Any time zone name from `system.time_zones`, e.g. `Europe/Berlin`, `UTC` or `Zulu`\n\nExamples:\n\n```sql\nSELECT timeZone(), serverTimeZone() FORMAT CSV\n\n\"Europe/Berlin\",\"Europe/Berlin\"\n```\n\n```sql\nSELECT timeZone(), serverTimeZone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT CSV\n\n\"Asia/Novosibirsk\",\"Europe/Berlin\"\n```\n\nAssign session time zone 'America/Denver' to the inner DateTime without explicitly specified time zone:\n\n```sql\nSELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV\n\n1999-12-13 07:23:23.123\n```\n\n:::warning\nNot all functions that parse DateTime/DateTime64 respect `session_timezone`. This can lead to subtle errors.\nSee the following example and explanation.\n:::\n\n```sql\nCREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');\n\nSELECT *, timeZone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'\n0 rows in set.\n\nSELECT *, timeZone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'\n┌───────────────────d─┬─timeZone()───────┐\n│ 2000-01-01 00:00:00 │ Asia/Novosibirsk │\n└─────────────────────┴──────────────────┘\n```\n\nThis happens due to different parsing pipelines:\n\n- `toDateTime()` without explicitly given time zone used in the first `SELECT` query honors setting `session_timezone` and the global time zone.\n- In the second query, a DateTime is parsed from a String, and inherits the type and time zone of the existing column`d`. Thus, setting `session_timezone` and the global time zone are not honored.\n\n**See also**\n\n- [timezone](../server-configuration-parameters/settings.md/#timezone)"
    },
    {
      "name": "set_overflow_mode",
      "type": "OverflowMode",
      "description": "Sets what happens when the amount of data exceeds one of the limits.\n\nPossible values:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result, as if the\nsource data ran out."
    },
    {
      "name": "shared_merge_tree_sync_parts_on_partition_operations",
      "type": "Bool",
      "description": "Automatically synchronize set of data parts after MOVE|REPLACE|ATTACH partition operations in SMT tables. Cloud only"
    },
    {
      "name": "short_circuit_function_evaluation",
      "type": "ShortCircuitFunctionEvaluation",
      "description": "Allows calculating the [if](../../sql-reference/functions/conditional-functions.md/#if), [multiIf](../../sql-reference/functions/conditional-functions.md/#multiif), [and](/sql-reference/functions/logical-functions#and), and [or](/sql-reference/functions/logical-functions#or) functions according to a [short scheme](https://en.wikipedia.org/wiki/Short-circuit_evaluation). This helps optimize the execution of complex expressions in these functions and prevent possible exceptions (such as division by zero when it is not expected).\n\nPossible values:\n\n- `enable` — Enables short-circuit function evaluation for functions that are suitable for it (can throw an exception or computationally heavy).\n- `force_enable` — Enables short-circuit function evaluation for all functions.\n- `disable` — Disables short-circuit function evaluation."
    },
    {
      "name": "short_circuit_function_evaluation_for_nulls",
      "type": "Bool",
      "description": "Optimizes evaluation of functions that return NULL when any argument is NULL. When the percentage of NULL values in the function's arguments exceeds the short_circuit_function_evaluation_for_nulls_threshold, the system skips evaluating the function row-by-row. Instead, it immediately returns NULL for all rows, avoiding unnecessary computation."
    },
    {
      "name": "short_circuit_function_evaluation_for_nulls_threshold",
      "type": "Double",
      "description": "Ratio threshold of NULL values to execute functions with Nullable arguments only on rows with non-NULL values in all arguments. Applies when setting short_circuit_function_evaluation_for_nulls is enabled.\nWhen the ratio of rows containing NULL values to the total number of rows exceeds this threshold, these rows containing NULL values will not be evaluated."
    },
    {
      "name": "show_create_query_identifier_quoting_rule",
      "type": "IdentifierQuotingRule",
      "description": "Set the quoting rule for identifiers in SHOW CREATE query"
    },
    {
      "name": "show_create_query_identifier_quoting_style",
      "type": "IdentifierQuotingStyle",
      "description": "Set the quoting style for identifiers in SHOW CREATE query"
    },
    {
      "name": "show_data_lake_catalogs_in_system_tables",
      "type": "Bool",
      "description": "Enables showing data lake catalogs in system tables."
    },
    {
      "name": "show_table_uuid_in_table_create_query_if_not_nil",
      "type": "Bool",
      "description": "Sets the `SHOW TABLE` query display.\n\nPossible values:\n\n- 0 — The query will be displayed without table UUID.\n- 1 — The query will be displayed with table UUID."
    },
    {
      "name": "single_join_prefer_left_table",
      "type": "Bool",
      "description": "For single JOIN in case of identifier ambiguity prefer left table"
    },
    {
      "name": "skip_download_if_exceeds_query_cache",
      "type": "Bool",
      "description": "Skip download from remote filesystem if exceeds query cache size"
    },
    {
      "name": "skip_redundant_aliases_in_udf",
      "type": "Bool",
      "description": "Redundant aliases are not used (substituted) in user-defined functions in order to simplify it's usage.\n\nPossible values:\n\n- 1 — The aliases are skipped (substituted) in UDFs.\n- 0 — The aliases are not skipped (substituted) in UDFs.\n\n**Example**\n\nThe difference between enabled and disabled:\n\nQuery:\n\n```sql\nSET skip_redundant_aliases_in_udf = 0;\nCREATE FUNCTION IF NOT EXISTS test_03274 AS ( x ) -> ((x + 1 as y, y + 2));\n\nEXPLAIN SYNTAX SELECT test_03274(4 + 2);\n```\n\nResult:\n\n```text\nSELECT ((4 + 2) + 1 AS y, y + 2)\n```\n\nQuery:\n\n```sql\nSET skip_redundant_aliases_in_udf = 1;\nCREATE FUNCTION IF NOT EXISTS test_03274 AS ( x ) -> ((x + 1 as y, y + 2));\n\nEXPLAIN SYNTAX SELECT test_03274(4 + 2);\n```\n\nResult:\n\n```text\nSELECT ((4 + 2) + 1, ((4 + 2) + 1) + 2)\n```"
    },
    {
      "name": "skip_unavailable_shards",
      "type": "Bool",
      "description": "Enables or disables silently skipping of unavailable shards.\n\nShard is considered unavailable if all its replicas are unavailable. A replica is unavailable in the following cases:\n\n- ClickHouse can't connect to replica for any reason.\n\n    When connecting to a replica, ClickHouse performs several attempts. If all these attempts fail, the replica is considered unavailable.\n\n- Replica can't be resolved through DNS.\n\n    If replica's hostname can't be resolved through DNS, it can indicate the following situations:\n\n    - Replica's host has no DNS record. It can occur in systems with dynamic DNS, for example, [Kubernetes](https://kubernetes.io), where nodes can be unresolvable during downtime, and this is not an error.\n\n    - Configuration error. ClickHouse configuration file contains a wrong hostname.\n\nPossible values:\n\n- 1 — skipping enabled.\n\n    If a shard is unavailable, ClickHouse returns a result based on partial data and does not report node availability issues.\n\n- 0 — skipping disabled.\n\n    If a shard is unavailable, ClickHouse throws an exception."
    },
    {
      "name": "sleep_after_receiving_query_ms",
      "type": "Milliseconds",
      "description": "Time to sleep after receiving query in TCPHandler"
    },
    {
      "name": "sleep_in_send_data_ms",
      "type": "Milliseconds",
      "description": "Time to sleep in sending data in TCPHandler"
    },
    {
      "name": "sleep_in_send_tables_status_ms",
      "type": "Milliseconds",
      "description": "Time to sleep in sending tables status response in TCPHandler"
    },
    {
      "name": "sort_overflow_mode",
      "type": "OverflowMode",
      "description": "Sets what happens if the number of rows received before sorting exceeds one of the limits.\n\nPossible values:\n- `throw`: throw an exception.\n- `break`: stop executing the query and return the partial result."
    },
    {
      "name": "split_intersecting_parts_ranges_into_layers_final",
      "type": "Bool",
      "description": "Split intersecting parts ranges into layers during FINAL optimization"
    },
    {
      "name": "split_parts_ranges_into_intersecting_and_non_intersecting_final",
      "type": "Bool",
      "description": "Split parts ranges into intersecting and non intersecting during FINAL optimization"
    },
    {
      "name": "splitby_max_substrings_includes_remaining_string",
      "type": "Bool",
      "description": "Controls whether function [splitBy*()](../../sql-reference/functions/splitting-merging-functions.md) with argument `max_substrings` > 0 will include the remaining string in the last element of the result array.\n\nPossible values:\n\n- `0` - The remaining string will not be included in the last element of the result array.\n- `1` - The remaining string will be included in the last element of the result array. This is the behavior of Spark's [`split()`](https://spark.apache.org/docs/3.1.2/api/python/reference/api/pyspark.sql.functions.split.html) function and Python's ['string.split()'](https://docs.python.org/3/library/stdtypes.html#str.split) method."
    },
    {
      "name": "stop_refreshable_materialized_views_on_startup",
      "type": "Bool",
      "description": "On server startup, prevent scheduling of refreshable materialized views, as if with SYSTEM STOP VIEWS. You can manually start them with `SYSTEM START VIEWS` or `SYSTEM START VIEW <name>` afterwards. Also applies to newly created views. Has no effect on non-refreshable materialized views."
    },
    {
      "name": "storage_file_read_method",
      "type": "LocalFSReadMethod",
      "description": "Method of reading data from storage file, one of: `read`, `pread`, `mmap`. The mmap method does not apply to clickhouse-server (it's intended for clickhouse-local)."
    },
    {
      "name": "storage_system_stack_trace_pipe_read_timeout_ms",
      "type": "Milliseconds",
      "description": "Maximum time to read from a pipe for receiving information from the threads when querying the `system.stack_trace` table. This setting is used for testing purposes and not meant to be changed by users."
    },
    {
      "name": "stream_flush_interval_ms",
      "type": "Milliseconds",
      "description": "Works for tables with streaming in the case of a timeout, or when a thread generates [max_insert_block_size](#max_insert_block_size) rows.\n\nThe default value is 7500.\n\nThe smaller the value, the more often data is flushed into the table. Setting the value too low leads to poor performance."
    },
    {
      "name": "stream_like_engine_allow_direct_select",
      "type": "Bool",
      "description": "Allow direct SELECT query for Kafka, RabbitMQ, FileLog, Redis Streams, and NATS engines. In case there are attached materialized views, SELECT query is not allowed even if this setting is enabled."
    },
    {
      "name": "stream_like_engine_insert_queue",
      "type": "String",
      "description": "When stream-like engine reads from multiple queues, the user will need to select one queue to insert into when writing. Used by Redis Streams and NATS."
    },
    {
      "name": "stream_poll_timeout_ms",
      "type": "Milliseconds",
      "description": "Timeout for polling data from/to streaming storages."
    },
    {
      "name": "system_events_show_zero_values",
      "type": "Bool",
      "description": "Allows to select zero-valued events from [`system.events`](../../operations/system-tables/events.md).\n\nSome monitoring systems require passing all the metrics values to them for each checkpoint, even if the metric value is zero.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled.\n\n**Examples**\n\nQuery\n\n```sql\nSELECT * FROM system.events WHERE event='QueryMemoryLimitExceeded';\n```\n\nResult\n\n```text\nOk.\n```\n\nQuery\n```sql\nSET system_events_show_zero_values = 1;\nSELECT * FROM system.events WHERE event='QueryMemoryLimitExceeded';\n```\n\nResult\n\n```text\n┌─event────────────────────┬─value─┬─description───────────────────────────────────────────┐\n│ QueryMemoryLimitExceeded │     0 │ Number of times when memory limit exceeded for query. │\n└──────────────────────────┴───────┴───────────────────────────────────────────────────────┘\n```"
    },
    {
      "name": "table_function_remote_max_addresses",
      "type": "UInt64",
      "description": "Sets the maximum number of addresses generated from patterns for the [remote](../../sql-reference/table-functions/remote.md) function.\n\nPossible values:\n\n- Positive integer."
    },
    {
      "name": "tcp_keep_alive_timeout",
      "type": "Seconds",
      "description": "The time in seconds the connection needs to remain idle before TCP starts sending keepalive probes"
    },
    {
      "name": "temporary_data_in_cache_reserve_space_wait_lock_timeout_milliseconds",
      "type": "UInt64",
      "description": "Wait time to lock cache for space reservation for temporary data in filesystem cache"
    },
    {
      "name": "temporary_files_codec",
      "type": "String",
      "description": "Sets compression codec for temporary files used in sorting and joining operations on disk.\n\nPossible values:\n\n- LZ4 — [LZ4](https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)) compression is applied.\n- NONE — No compression is applied."
    },
    {
      "name": "temporary_live_view_timeout",
      "type": "Seconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert",
      "type": "Bool",
      "description": "Throw exception on INSERT query when the setting `deduplicate_blocks_in_dependent_materialized_views` is enabled along with `async_insert`. It guarantees correctness, because these features can't work together."
    },
    {
      "name": "throw_if_no_data_to_insert",
      "type": "Bool",
      "description": "Allows or forbids empty INSERTs, enabled by default (throws an error on an empty insert). Only applies to INSERTs using [`clickhouse-client`](/interfaces/cli) or using the [gRPC interface](/interfaces/grpc)."
    },
    {
      "name": "throw_on_error_from_cache_on_write_operations",
      "type": "Bool",
      "description": "Ignore error from cache when caching on write operations (INSERT, merges)"
    },
    {
      "name": "throw_on_max_partitions_per_insert_block",
      "type": "Bool",
      "description": "Allows you to control the behaviour when `max_partitions_per_insert_block` is reached.\n\nPossible values:\n- `true`  - When an insert block reaches `max_partitions_per_insert_block`, an exception is raised.\n- `false` - Logs a warning when `max_partitions_per_insert_block` is reached.\n\n:::tip\nThis can be useful if you're trying to understand the impact on users when changing [`max_partitions_per_insert_block`](/operations/settings/settings#max_partitions_per_insert_block).\n:::"
    },
    {
      "name": "throw_on_unsupported_query_inside_transaction",
      "type": "Bool",
      "description": "Throw exception if unsupported query is used inside transaction"
    },
    {
      "name": "timeout_before_checking_execution_speed",
      "type": "Seconds",
      "description": "Checks that execution speed is not too slow (no less than `min_execution_speed`),\nafter the specified time in seconds has expired."
    },
    {
      "name": "timeout_overflow_mode",
      "type": "OverflowMode",
      "description": "Sets what to do if the query is run longer than the `max_execution_time` or the\nestimated running time is longer than `max_estimated_execution_time`.\n\nPossible values:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result, as if the\nsource data ran out."
    },
    {
      "name": "timeout_overflow_mode_leaf",
      "type": "OverflowMode",
      "description": "Sets what happens when the query in leaf node run longer than `max_execution_time_leaf`.\n\nPossible values:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result, as if the\nsource data ran out."
    },
    {
      "name": "totals_auto_threshold",
      "type": "Float",
      "description": "The threshold for `totals_mode = 'auto'`.\nSee the section \"WITH TOTALS modifier\"."
    },
    {
      "name": "totals_mode",
      "type": "TotalsMode",
      "description": "How to calculate TOTALS when HAVING is present, as well as when max_rows_to_group_by and group_by_overflow_mode = 'any' are present.\nSee the section \"WITH TOTALS modifier\"."
    },
    {
      "name": "trace_profile_events",
      "type": "Bool",
      "description": "Enables or disables collecting stacktraces on each update of profile events along with the name of profile event and the value of increment and sending them into [trace_log](/operations/system-tables/trace_log).\n\nPossible values:\n\n- 1 — Tracing of profile events enabled.\n- 0 — Tracing of profile events disabled."
    },
    {
      "name": "transfer_overflow_mode",
      "type": "OverflowMode",
      "description": "Sets what happens when the amount of data exceeds one of the limits.\n\nPossible values:\n- `throw`: throw an exception (default).\n- `break`: stop executing the query and return the partial result, as if the\nsource data ran out."
    },
    {
      "name": "transform_null_in",
      "type": "Bool",
      "description": "Enables equality of [NULL](/sql-reference/syntax#null) values for [IN](../../sql-reference/operators/in.md) operator.\n\nBy default, `NULL` values can't be compared because `NULL` means undefined value. Thus, comparison `expr = NULL` must always return `false`. With this setting `NULL = NULL` returns `true` for `IN` operator.\n\nPossible values:\n\n- 0 — Comparison of `NULL` values in `IN` operator returns `false`.\n- 1 — Comparison of `NULL` values in `IN` operator returns `true`.\n\n**Example**\n\nConsider the `null_in` table:\n\n```text\n┌──idx─┬─────i─┐\n│    1 │     1 │\n│    2 │  NULL │\n│    3 │     3 │\n└──────┴───────┘\n```\n\nQuery:\n\n```sql\nSELECT idx, i FROM null_in WHERE i IN (1, NULL) SETTINGS transform_null_in = 0;\n```\n\nResult:\n\n```text\n┌──idx─┬────i─┐\n│    1 │    1 │\n└──────┴──────┘\n```\n\nQuery:\n\n```sql\nSELECT idx, i FROM null_in WHERE i IN (1, NULL) SETTINGS transform_null_in = 1;\n```\n\nResult:\n\n```text\n┌──idx─┬─────i─┐\n│    1 │     1 │\n│    2 │  NULL │\n└──────┴───────┘\n```\n\n**See Also**\n\n- [NULL Processing in IN Operators](/sql-reference/operators/in#null-processing)"
    },
    {
      "name": "traverse_shadow_remote_data_paths",
      "type": "Bool",
      "description": "Traverse frozen data (shadow directory) in addition to actual table data when query system.remote_data_paths"
    },
    {
      "name": "type_json_skip_duplicated_paths",
      "type": "Bool",
      "description": "When enabled, during parsing JSON object into JSON type duplicated paths will be ignored and only the first one will be inserted instead of an exception"
    },
    {
      "name": "union_default_mode",
      "type": "SetOperationMode",
      "description": "Sets a mode for combining `SELECT` query results. The setting is only used when shared with [UNION](../../sql-reference/statements/select/union.md) without explicitly specifying the `UNION ALL` or `UNION DISTINCT`.\n\nPossible values:\n\n- `'DISTINCT'` — ClickHouse outputs rows as a result of combining queries removing duplicate rows.\n- `'ALL'` — ClickHouse outputs all rows as a result of combining queries including duplicate rows.\n- `''` — ClickHouse generates an exception when used with `UNION`.\n\nSee examples in [UNION](../../sql-reference/statements/select/union.md)."
    },
    {
      "name": "unknown_packet_in_send_data",
      "type": "UInt64",
      "description": "Send unknown packet instead of data Nth data packet"
    },
    {
      "name": "update_insert_deduplication_token_in_dependent_materialized_views",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "update_parallel_mode",
      "type": "UpdateParallelMode",
      "description": "Determines the behavior of concurrent update queries.\n\nPossible values:\n- `sync` - run sequentially all `UPDATE` queries.\n- `auto` - run sequentially only `UPDATE` queries with dependencies between columns updated in one query and columns used in expressions of another query.\n- `async` - do not synchronize update queries."
    },
    {
      "name": "update_sequential_consistency",
      "type": "Bool",
      "description": "If true set of parts is updated to the latest version before execution of update."
    },
    {
      "name": "use_async_executor_for_materialized_views",
      "type": "Bool",
      "description": "Use async and potentially multithreaded execution of materialized view query, can speedup views processing during INSERT, but also consume more memory."
    },
    {
      "name": "use_cache_for_count_from_files",
      "type": "Bool",
      "description": "Enables caching of rows number during count from files in table functions `file`/`s3`/`url`/`hdfs`/`azureBlobStorage`.\n\nEnabled by default."
    },
    {
      "name": "use_client_time_zone",
      "type": "Bool",
      "description": "Use client timezone for interpreting DateTime string values, instead of adopting server timezone."
    },
    {
      "name": "use_compact_format_in_distributed_parts_names",
      "type": "Bool",
      "description": "Uses compact format for storing blocks for background (`distributed_foreground_insert`) INSERT into tables with `Distributed` engine.\n\nPossible values:\n\n- 0 — Uses `user[:password]@host:port#default_database` directory format.\n- 1 — Uses `[shard{shard_index}[_replica{replica_index}]]` directory format.\n\n:::note\n- with `use_compact_format_in_distributed_parts_names=0` changes from cluster definition will not be applied for background INSERT.\n- with `use_compact_format_in_distributed_parts_names=1` changing the order of the nodes in the cluster definition, will change the `shard_index`/`replica_index` so be aware.\n:::"
    },
    {
      "name": "use_concurrency_control",
      "type": "Bool",
      "description": "Respect the server's concurrency control (see the `concurrent_threads_soft_limit_num` and `concurrent_threads_soft_limit_ratio_to_cores` global server settings). If disabled, it allows using a larger number of threads even if the server is overloaded (not recommended for normal usage, and needed mostly for tests)."
    },
    {
      "name": "use_hedged_requests",
      "type": "Bool",
      "description": "Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query.\nNew connection is enabled in case existent connection(s) with replica(s) were not established within `hedged_connection_timeout`\nor no data was received within `receive_data_timeout`. Query uses the first connection which send non empty progress packet (or data packet, if `allow_changing_replica_until_first_data_packet`);\nother connections are cancelled. Queries with `max_parallel_replicas > 1` are supported.\n\nEnabled by default.\n\nDisabled by default on Cloud."
    },
    {
      "name": "use_hive_partitioning",
      "type": "Bool",
      "description": "When enabled, ClickHouse will detect Hive-style partitioning in path (`/name=value/`) in file-like table engines [File](/sql-reference/table-functions/file#hive-style-partitioning)/[S3](/sql-reference/table-functions/s3#hive-style-partitioning)/[URL](/sql-reference/table-functions/url#hive-style-partitioning)/[HDFS](/sql-reference/table-functions/hdfs#hive-style-partitioning)/[AzureBlobStorage](/sql-reference/table-functions/azureBlobStorage#hive-style-partitioning) and will allow to use partition columns as virtual columns in the query. These virtual columns will have the same names as in the partitioned path, but starting with `_`."
    },
    {
      "name": "use_iceberg_metadata_files_cache",
      "type": "Bool",
      "description": "If turned on, iceberg table function and iceberg storage may utilize the iceberg metadata files cache.\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "use_iceberg_partition_pruning",
      "type": "Bool",
      "description": "Use Iceberg partition pruning for Iceberg tables"
    },
    {
      "name": "use_index_for_in_with_subqueries",
      "type": "Bool",
      "description": "Try using an index if there is a subquery or a table expression on the right side of the IN operator."
    },
    {
      "name": "use_index_for_in_with_subqueries_max_values",
      "type": "UInt64",
      "description": "The maximum size of the set in the right-hand side of the IN operator to use table index for filtering. It allows to avoid performance degradation and higher memory usage due to the preparation of additional data structures for large queries. Zero means no limit."
    },
    {
      "name": "use_json_alias_for_old_object_type",
      "type": "Bool",
      "description": "When enabled, `JSON` data type alias will be used to create an old [Object('json')](../../sql-reference/data-types/json.md) type instead of the new [JSON](../../sql-reference/data-types/newjson.md) type."
    },
    {
      "name": "use_legacy_to_time",
      "type": "Bool",
      "description": "When enabled, allows to use legacy toTime function, which converts a date with time to a certain fixed date, while preserving the time.\nOtherwise, uses a new toTime function, that converts different type of data into the Time type.\nThe old legacy function is also unconditionally accessible as toTimeWithFixedDate."
    },
    {
      "name": "use_local_cache_for_remote_storage",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "use_mysql_types_in_show_columns",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "use_page_cache_for_disks_without_file_cache",
      "type": "Bool",
      "description": "Use userspace page cache for remote disks that don't have filesystem cache enabled."
    },
    {
      "name": "use_page_cache_with_distributed_cache",
      "type": "Bool",
      "description": "Use userspace page cache when distributed cache is used."
    },
    {
      "name": "use_query_cache",
      "type": "Bool",
      "description": "If turned on, `SELECT` queries may utilize the [query cache](../query-cache.md). Parameters [enable_reads_from_query_cache](#enable_reads_from_query_cache)\nand [enable_writes_to_query_cache](#enable_writes_to_query_cache) control in more detail how the cache is used.\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "use_query_condition_cache",
      "type": "Bool",
      "description": "Enable the [query condition cache](/operations/query-condition-cache). The cache stores ranges of granules in data parts which do not satisfy the condition in the `WHERE` clause,\nand reuse this information as an ephemeral index for subsequent queries.\n\nPossible values:\n\n- 0 - Disabled\n- 1 - Enabled"
    },
    {
      "name": "use_skip_indexes",
      "type": "Bool",
      "description": "Use data skipping indexes during query execution.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "use_skip_indexes_if_final",
      "type": "Bool",
      "description": "Controls whether skipping indexes are used when executing a query with the FINAL modifier.\n\nSkip indexes may exclude rows (granules) containing the latest data, which could lead to incorrect results from a query with the FINAL modifier. When this setting is enabled, skipping indexes are applied even with the FINAL modifier, potentially improving performance but with the risk of missing recent updates. This setting should be enabled in sync with the setting use_skip_indexes_if_final_exact_mode (default is enabled).\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "use_skip_indexes_if_final_exact_mode",
      "type": "Bool",
      "description": "Controls whether granules returned by a skipping index are expanded in newer parts to return correct results when executing a query with the FINAL modifier.\n\nUsing skip indexes may exclude rows (granules) containing the latest data which could lead to incorrect results. This setting can ensure that correct results are returned by scanning newer parts that have overlap with the ranges returned by the skip index. This setting should be disabled only if approximate results based on looking up the skip index are okay for an application.\n\nPossible values:\n\n- 0 — Disabled.\n- 1 — Enabled."
    },
    {
      "name": "use_structure_from_insertion_table_in_table_functions",
      "type": "UInt64",
      "description": "Use structure from insertion table instead of schema inference from data. Possible values: 0 - disabled, 1 - enabled, 2 - auto"
    },
    {
      "name": "use_uncompressed_cache",
      "type": "Bool",
      "description": "Whether to use a cache of uncompressed blocks. Accepts 0 or 1. By default, 0 (disabled).\nUsing the uncompressed cache (only for tables in the MergeTree family) can significantly reduce latency and increase throughput when working with a large number of short queries. Enable this setting for users who send frequent short requests. Also pay attention to the [uncompressed_cache_size](/operations/server-configuration-parameters/settings#uncompressed_cache_size) configuration parameter (only set in the config file) – the size of uncompressed cache blocks. By default, it is 8 GiB. The uncompressed cache is filled in as needed and the least-used data is automatically deleted.\n\nFor queries that read at least a somewhat large volume of data (one million rows or more), the uncompressed cache is disabled automatically to save space for truly small queries. This means that you can keep the 'use_uncompressed_cache' setting always set to 1."
    },
    {
      "name": "use_variant_as_common_type",
      "type": "Bool",
      "description": "Allows to use `Variant` type as a result type for [if](../../sql-reference/functions/conditional-functions.md/#if)/[multiIf](../../sql-reference/functions/conditional-functions.md/#multiif)/[array](../../sql-reference/functions/array-functions.md)/[map](../../sql-reference/functions/tuple-map-functions.md) functions when there is no common type for argument types.\n\nExample:\n\n```sql\nSET use_variant_as_common_type = 1;\nSELECT toTypeName(if(number % 2, number, range(number))) as variant_type FROM numbers(1);\nSELECT if(number % 2, number, range(number)) as variant FROM numbers(5);\n```\n\n```text\n┌─variant_type───────────────────┐\n│ Variant(Array(UInt64), UInt64) │\n└────────────────────────────────┘\n┌─variant───┐\n│ []        │\n│ 1         │\n│ [0,1]     │\n│ 3         │\n│ [0,1,2,3] │\n└───────────┘\n```\n\n```sql\nSET use_variant_as_common_type = 1;\nSELECT toTypeName(multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL)) AS variant_type FROM numbers(1);\nSELECT multiIf((number % 4) = 0, 42, (number % 4) = 1, [1, 2, 3], (number % 4) = 2, 'Hello, World!', NULL) AS variant FROM numbers(4);\n```\n\n```text\n─variant_type─────────────────────────┐\n│ Variant(Array(UInt8), String, UInt8) │\n└──────────────────────────────────────┘\n\n┌─variant───────┐\n│ 42            │\n│ [1,2,3]       │\n│ Hello, World! │\n│ ᴺᵁᴸᴸ          │\n└───────────────┘\n```\n\n```sql\nSET use_variant_as_common_type = 1;\nSELECT toTypeName(array(range(number), number, 'str_' || toString(number))) as array_of_variants_type from numbers(1);\nSELECT array(range(number), number, 'str_' || toString(number)) as array_of_variants FROM numbers(3);\n```\n\n```text\n┌─array_of_variants_type────────────────────────┐\n│ Array(Variant(Array(UInt64), String, UInt64)) │\n└───────────────────────────────────────────────┘\n\n┌─array_of_variants─┐\n│ [[],0,'str_0']    │\n│ [[0],1,'str_1']   │\n│ [[0,1],2,'str_2'] │\n└───────────────────┘\n```\n\n```sql\nSET use_variant_as_common_type = 1;\nSELECT toTypeName(map('a', range(number), 'b', number, 'c', 'str_' || toString(number))) as map_of_variants_type from numbers(1);\nSELECT map('a', range(number), 'b', number, 'c', 'str_' || toString(number)) as map_of_variants FROM numbers(3);\n```\n\n```text\n┌─map_of_variants_type────────────────────────────────┐\n│ Map(String, Variant(Array(UInt64), String, UInt64)) │\n└─────────────────────────────────────────────────────┘\n\n┌─map_of_variants───────────────┐\n│ {'a':[],'b':0,'c':'str_0'}    │\n│ {'a':[0],'b':1,'c':'str_1'}   │\n│ {'a':[0,1],'b':2,'c':'str_2'} │\n└───────────────────────────────┘\n```"
    },
    {
      "name": "use_with_fill_by_sorting_prefix",
      "type": "Bool",
      "description": "Columns preceding WITH FILL columns in ORDER BY clause form sorting prefix. Rows with different values in sorting prefix are filled independently"
    },
    {
      "name": "validate_enum_literals_in_operators",
      "type": "Bool",
      "description": "If enabled, validate enum literals in operators like `IN`, `NOT IN`, `==`, `!=` against the enum type and throw an exception if the literal is not a valid enum value."
    },
    {
      "name": "validate_experimental_and_suspicious_types_inside_nested_types",
      "type": "Bool",
      "description": "Validate usage of experimental and suspicious types inside nested types like Array/Map/Tuple"
    },
    {
      "name": "validate_mutation_query",
      "type": "Bool",
      "description": "Validate mutation queries before accepting them. Mutations are executed in the background, and running an invalid query will cause mutations to get stuck, requiring manual intervention.\n\nOnly change this setting if you encounter a backward-incompatible bug."
    },
    {
      "name": "validate_polygons",
      "type": "Bool",
      "description": "Enables or disables throwing an exception in the [pointInPolygon](/sql-reference/functions/geo/coordinates#pointinpolygon) function, if the polygon is self-intersecting or self-tangent.\n\nPossible values:\n\n- 0 — Throwing an exception is disabled. `pointInPolygon` accepts invalid polygons and returns possibly incorrect results for them.\n- 1 — Throwing an exception is enabled."
    },
    {
      "name": "vector_search_filter_strategy",
      "type": "VectorSearchFilterStrategy",
      "description": "If a vector search query has a WHERE clause, this setting determines if it is evaluated first (pre-filtering) OR if the vector similarity index is checked first (post-filtering). Possible values:\n- 'auto' - Postfiltering (the exact semantics may change in future).\n- 'postfilter' - Use vector similarity index to identify the nearest neighbours, then apply other filters\n- 'prefilter' - Evaluate other filters first, then perform brute-force search to identify neighbours."
    },
    {
      "name": "vector_search_postfilter_multiplier",
      "type": "Float",
      "description": "Multiply the fetched nearest neighbors from the vector similarity index by this number before performing post-filtering on other predicates."
    },
    {
      "name": "wait_changes_become_visible_after_commit_mode",
      "type": "TransactionsWaitCSNMode",
      "description": "Wait for committed changes to become actually visible in the latest snapshot"
    },
    {
      "name": "wait_for_async_insert",
      "type": "Bool",
      "description": "If true wait for processing of asynchronous insertion"
    },
    {
      "name": "wait_for_async_insert_timeout",
      "type": "Seconds",
      "description": "Timeout for waiting for processing asynchronous insertion"
    },
    {
      "name": "wait_for_window_view_fire_signal_timeout",
      "type": "Seconds",
      "description": "Timeout for waiting for window view fire signal in event time processing"
    },
    {
      "name": "window_view_clean_interval",
      "type": "Seconds",
      "description": "The clean interval of window view in seconds to free outdated data."
    },
    {
      "name": "window_view_heartbeat_interval",
      "type": "Seconds",
      "description": "The heartbeat interval in seconds to indicate watch query is alive."
    },
    {
      "name": "workload",
      "type": "String",
      "description": "Name of workload to be used to access resources"
    },
    {
      "name": "write_through_distributed_cache",
      "type": "Bool",
      "description": "Only has an effect in ClickHouse Cloud. Allow writing to distributed cache (writing to s3 will also be done by distributed cache)"
    },
    {
      "name": "zstd_window_log_max",
      "type": "Int64",
      "description": "Allows you to select the max window log of ZSTD (it will not be used for MergeTree family)"
    }
  ],
  "mergeTreeSettings": [
    {
      "name": "adaptive_write_buffer_initial_size",
      "type": "UInt64",
      "description": "\n    Initial size of an adaptive write buffer\n    "
    },
    {
      "name": "add_implicit_sign_column_constraint_for_collapsing_engine",
      "type": "Bool",
      "description": "\n    If true, adds an implicit constraint for the `sign` column of a CollapsingMergeTree\n    or VersionedCollapsingMergeTree table to allow only valid values (`1` and `-1`).\n    "
    },
    {
      "name": "add_minmax_index_for_numeric_columns",
      "type": "Bool",
      "description": "\n    When enabled, min-max (skipping) indices are added for all numeric columns\n    of the table.\n    "
    },
    {
      "name": "add_minmax_index_for_string_columns",
      "type": "Bool",
      "description": "\n    When enabled, min-max (skipping) indices are added for all string columns of\n    the table.\n    "
    },
    {
      "name": "allow_coalescing_columns_in_partition_or_order_key",
      "type": "Bool",
      "description": "\n    When enabled, allows coalescing columns in a CoalescingMergeTree table to be used in\n    the partition or sorting key.\n    "
    },
    {
      "name": "allow_experimental_replacing_merge_with_cleanup",
      "type": "Bool",
      "description": "\n    Allow experimental CLEANUP merges for ReplacingMergeTree with `is_deleted`\n    column. When enabled, allows using `OPTIMIZE ... FINAL CLEANUP` to manually\n    merge all parts in a partition down to a single part and removing any\n    deleted rows.\n\n    Also allows enabling such merges to happen automatically in the background\n    with settings `min_age_to_force_merge_seconds`,\n    `min_age_to_force_merge_on_partition_only` and\n    `enable_replacing_merge_with_cleanup_for_min_age_to_force_merge`.\n    "
    },
    {
      "name": "allow_experimental_reverse_key",
      "type": "Bool",
      "description": "\n    Enables support for descending sort order in MergeTree sorting keys. This\n    setting is particularly useful for time series analysis and Top-N queries,\n    allowing data to be stored in reverse chronological order to optimize query\n    performance.\n\n    With `allow_experimental_reverse_key` enabled, you can define descending sort\n    orders within the `ORDER BY` clause of a MergeTree table. This enables the\n    use of more efficient `ReadInOrder` optimizations instead of `ReadInReverseOrder`\n    for descending queries.\n\n    **Example**\n\n    ```sql\n    CREATE TABLE example\n    (\n    time DateTime,\n    key Int32,\n    value String\n    ) ENGINE = MergeTree\n    ORDER BY (time DESC, key)  -- Descending order on 'time' field\n    SETTINGS allow_experimental_reverse_key = 1;\n\n    SELECT * FROM example WHERE key = 'xxx' ORDER BY time DESC LIMIT 10;\n    ```\n\n    By using `ORDER BY time DESC` in the query, `ReadInOrder` is applied.\n\n    **Default Value:** false\n    "
    },
    {
      "name": "allow_floating_point_partition_key",
      "type": "Bool",
      "description": "\n    Enables to allow floating-point number as a partition key.\n\n    Possible values:\n    - `0` — Floating-point partition key not allowed.\n    - `1` — Floating-point partition key allowed.\n    "
    },
    {
      "name": "allow_nullable_key",
      "type": "Bool",
      "description": "\n    Allow Nullable types as primary keys.\n    "
    },
    {
      "name": "allow_reduce_blocking_parts_task",
      "type": "Bool",
      "description": "\n    Background task which reduces blocking parts for shared merge tree tables.\n    Only in ClickHouse Cloud\n    "
    },
    {
      "name": "allow_remote_fs_zero_copy_replication",
      "type": "Bool",
      "description": "\n    Don't use this setting in production, because it is not ready.\n    "
    },
    {
      "name": "allow_summing_columns_in_partition_or_order_key",
      "type": "Bool",
      "description": "\n    When enabled, allows summing columns in a SummingMergeTree table to be used in\n    the partition or sorting key.\n    "
    },
    {
      "name": "allow_suspicious_indices",
      "type": "Bool",
      "description": "\n    Reject primary/secondary indexes and sorting keys with identical expressions\n    "
    },
    {
      "name": "allow_vertical_merges_from_compact_to_wide_parts",
      "type": "Bool",
      "description": "\n    Allows vertical merges from compact to wide parts. This settings must have\n    the same value on all replicas.\n    "
    },
    {
      "name": "always_fetch_merged_part",
      "type": "Bool",
      "description": "\n    If true, this replica never merges parts and always downloads merged parts\n    from other replicas.\n\n    Possible values:\n    - true, false\n    "
    },
    {
      "name": "always_use_copy_instead_of_hardlinks",
      "type": "Bool",
      "description": "\n    Always copy data instead of hardlinking during mutations/replaces/detaches\n    and so on.\n    "
    },
    {
      "name": "apply_patches_on_merge",
      "type": "Bool",
      "description": "\n    If true patch parts are applied on merges\n    "
    },
    {
      "name": "assign_part_uuids",
      "type": "Bool",
      "description": "\n    When enabled, a unique part identifier will be assigned for every new part.\n    Before enabling, check that all replicas support UUID version 4.\n    "
    },
    {
      "name": "async_block_ids_cache_update_wait_ms",
      "type": "Milliseconds",
      "description": "\n    How long each insert iteration will wait for async_block_ids_cache update\n    "
    },
    {
      "name": "async_insert",
      "type": "Bool",
      "description": "\n    If true, data from INSERT query is stored in queue and later flushed to\n    table in background.\n    "
    },
    {
      "name": "background_task_preferred_step_execution_time_ms",
      "type": "Milliseconds",
      "description": "\n    Target time to execution of one step of merge or mutation. Can be exceeded if\n    one step takes longer time\n    "
    },
    {
      "name": "cache_populated_by_fetch",
      "type": "Bool",
      "description": "\n    :::note\n    This setting applies only to ClickHouse Cloud.\n    :::\n\n    When `cache_populated_by_fetch` is disabled (the default setting), new data\n    parts are loaded into the cache only when a query is run that requires those\n    parts.\n\n    If enabled, `cache_populated_by_fetch` will instead cause all nodes to load\n    new data parts from storage into their cache without requiring a query to\n    trigger such an action.\n\n    **See Also**\n\n    - [ignore_cold_parts_seconds](/operations/settings/settings#ignore_cold_parts_seconds)\n    - [prefer_warmed_unmerged_parts_seconds](/operations/settings/settings#prefer_warmed_unmerged_parts_seconds)\n    - [cache_warmer_threads](/operations/settings/settings#cache_warmer_threads)\n    "
    },
    {
      "name": "cache_populated_by_fetch_filename_regexp",
      "type": "String",
      "description": "\n    :::note\n    This setting applies only to ClickHouse Cloud.\n    :::\n\n    If not empty, only files that match this regex will be prewarmed into the cache after fetch (if `cache_populated_by_fetch` is enabled).\n    "
    },
    {
      "name": "check_delay_period",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "check_sample_column_is_correct",
      "type": "Bool",
      "description": "\n    Enables the check at table creation, that the data type of a column for s\n    ampling or sampling expression is correct. The data type must be one of unsigned\n    [integer types](/sql-reference/data-types/int-uint): `UInt8`, `UInt16`,\n    `UInt32`, `UInt64`.\n\n    Possible values:\n    - `true`  — The check is enabled.\n    - `false` — The check is disabled at table creation.\n\n    Default value: `true`.\n\n    By default, the ClickHouse server checks at table creation the data type of\n    a column for sampling or sampling expression. If you already have tables with\n    incorrect sampling expression and do not want the server to raise an exception\n    during startup, set `check_sample_column_is_correct` to `false`.\n    "
    },
    {
      "name": "clean_deleted_rows",
      "type": "CleanDeletedRows",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "cleanup_delay_period",
      "type": "UInt64",
      "description": "\n    Minimum period to clean old queue logs, blocks hashes and parts.\n    "
    },
    {
      "name": "cleanup_delay_period_random_add",
      "type": "UInt64",
      "description": "\n    Add uniformly distributed value from 0 to x seconds to cleanup_delay_period\n    to avoid thundering herd effect and subsequent DoS of ZooKeeper in case of\n    very large number of tables.\n    "
    },
    {
      "name": "cleanup_thread_preferred_points_per_iteration",
      "type": "UInt64",
      "description": "\n    Preferred batch size for background cleanup (points are abstract but 1 point\n    is approximately equivalent to 1 inserted block).\n    "
    },
    {
      "name": "cleanup_threads",
      "type": "UInt64",
      "description": "\n    Threads for cleanup of outdated threads. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "columns_and_secondary_indices_sizes_lazy_calculation",
      "type": "Bool",
      "description": "\n    Calculate columns and secondary indices sizes lazily on first request instead\n    of on table initialization.\n    "
    },
    {
      "name": "columns_to_prewarm_mark_cache",
      "type": "String",
      "description": "\n    List of columns to prewarm mark cache for (if enabled). Empty means all columns\n    "
    },
    {
      "name": "compact_parts_max_bytes_to_buffer",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Maximal number of bytes to write in a\n    single stripe in compact parts\n    "
    },
    {
      "name": "compact_parts_max_granules_to_buffer",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Maximal number of granules to write in a\n    single stripe in compact parts\n    "
    },
    {
      "name": "compact_parts_merge_max_bytes_to_prefetch_part",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Maximal size of compact part to read it\n    in a whole to memory during merge.\n    "
    },
    {
      "name": "compatibility_allow_sampling_expression_not_in_primary_key",
      "type": "Bool",
      "description": "\n    Allow to create a table with sampling expression not in primary key. This is\n    needed only to temporarily allow to run the server with wrong tables for\n    backward compatibility.\n    "
    },
    {
      "name": "compress_marks",
      "type": "Bool",
      "description": "\n    Marks support compression, reduce mark file size and speed up network\n    transmission.\n    "
    },
    {
      "name": "compress_primary_key",
      "type": "Bool",
      "description": "\n    Primary key support compression, reduce primary key file size and speed up\n    network transmission.\n    "
    },
    {
      "name": "concurrent_part_removal_threshold",
      "type": "UInt64",
      "description": "\n    Activate concurrent part removal (see 'max_part_removal_threads') only if\n    the number of inactive data parts is at least this.\n    "
    },
    {
      "name": "deduplicate_merge_projection_mode",
      "type": "DeduplicateMergeProjectionMode",
      "description": "\n    Whether to allow create projection for the table with non-classic MergeTree,\n    that is not (Replicated, Shared) MergeTree. Ignore option is purely for\n    compatibility which might result in incorrect answer. Otherwise, if allowed,\n    what is the action when merge projections, either drop or rebuild. So classic\n    MergeTree would ignore this setting. It also controls `OPTIMIZE DEDUPLICATE`\n    as well, but has effect on all MergeTree family members. Similar to the\n    option `lightweight_mutation_projection_mode`, it is also part level.\n\n    Possible values:\n    - `ignore`\n    - `throw`\n    - `drop`\n    - `rebuild`\n    "
    },
    {
      "name": "default_compression_codec",
      "type": "String",
      "description": "\n    Specifies the default compression codec to be used if none is defined for a particular column in the table declaration.\n    Compression codec selecting order for a column:\n        1. Compression codec defined for the column in the table declaration\n        2. Compression codec defined in `default_compression_codec` (this setting)\n        3. Default compression codec defined in `compression` settings\n    Default value: an empty string (not defined).\n    "
    },
    {
      "name": "detach_not_byte_identical_parts",
      "type": "Bool",
      "description": "\n    Enables or disables detaching a data part on a replica after a merge or a\n    mutation, if it is not byte-identical to data parts on other replicas. If\n    disabled, the data part is removed. Activate this setting if you want to\n    analyze such parts later.\n\n    The setting is applicable to `MergeTree` tables with enabled\n    [data replication](/engines/table-engines/mergetree-family/replacingmergetree).\n\n    Possible values:\n\n    - `0` — Parts are removed.\n    - `1` — Parts are detached.\n    "
    },
    {
      "name": "detach_old_local_parts_when_cloning_replica",
      "type": "Bool",
      "description": "\n    Do not remove old local parts when repairing lost replica.\n\n    Possible values:\n    - `true`\n    - `false`\n    "
    },
    {
      "name": "disable_detach_partition_for_zero_copy_replication",
      "type": "Bool",
      "description": "\n    Disable DETACH PARTITION query for zero copy replication.\n    "
    },
    {
      "name": "disable_fetch_partition_for_zero_copy_replication",
      "type": "Bool",
      "description": "\n    Disable FETCH PARTITION query for zero copy replication.\n    "
    },
    {
      "name": "disable_freeze_partition_for_zero_copy_replication",
      "type": "Bool",
      "description": "\n    Disable FREEZE PARTITION query for zero copy replication.\n    "
    },
    {
      "name": "disk",
      "type": "String",
      "description": "\n    Name of storage disk. Can be specified instead of storage policy.\n    "
    },
    {
      "name": "enable_block_number_column",
      "type": "Bool",
      "description": "\n    Enable persisting column _block_number for each row.\n    "
    },
    {
      "name": "enable_block_offset_column",
      "type": "Bool",
      "description": "\n    Persists virtual column `_block_number` on merges.\n    "
    },
    {
      "name": "enable_index_granularity_compression",
      "type": "Bool",
      "description": "\n    Compress in memory values of index granularity if it is possible\n    "
    },
    {
      "name": "enable_max_bytes_limit_for_min_age_to_force_merge",
      "type": "Bool",
      "description": "\n    If settings `min_age_to_force_merge_seconds` and\n    `min_age_to_force_merge_on_partition_only` should respect setting\n    `max_bytes_to_merge_at_max_space_in_pool`.\n\n    Possible values:\n    - `true`\n    - `false`\n    "
    },
    {
      "name": "enable_mixed_granularity_parts",
      "type": "Bool",
      "description": "\n    Enables or disables transitioning to control the granule size with the\n    `index_granularity_bytes` setting. Before version 19.11, there was only the\n    `index_granularity` setting for restricting granule size. The\n    `index_granularity_bytes` setting improves ClickHouse performance when\n    selecting data from tables with big rows (tens and hundreds of megabytes).\n    If you have tables with big rows, you can enable this setting for the tables\n    to improve the efficiency of `SELECT` queries.\n    "
    },
    {
      "name": "enable_replacing_merge_with_cleanup_for_min_age_to_force_merge",
      "type": "Bool",
      "description": "\n    Whether to use CLEANUP merges for ReplacingMergeTree when merging partitions\n    down to a single part. Requires `allow_experimental_replacing_merge_with_cleanup`,\n    `min_age_to_force_merge_seconds` and `min_age_to_force_merge_on_partition_only`\n    to be enabled.\n\n    Possible values:\n    - `true`\n    - `false`\n    "
    },
    {
      "name": "enable_the_endpoint_id_with_zookeeper_name_prefix",
      "type": "Bool",
      "description": "\n    Enable the endpoint id with zookeeper name prefix for the replicated merge\n    tree table.\n    "
    },
    {
      "name": "enable_vertical_merge_algorithm",
      "type": "UInt64",
      "description": "\n    Enable usage of Vertical merge algorithm.\n    "
    },
    {
      "name": "enforce_index_structure_match_on_partition_manipulation",
      "type": "Bool",
      "description": "\n    If this setting is enabled for destination table of a partition manipulation\n    query (`ATTACH/MOVE/REPLACE PARTITION`), the indices and projections must be\n    identical between the source and destination tables. Otherwise, the destination\n    table can have a superset of the source table's indices and projections.\n    "
    },
    {
      "name": "exclude_deleted_rows_for_part_size_in_merge",
      "type": "Bool",
      "description": "\n    If enabled, estimated actual size of data parts (i.e., excluding those rows\n    that have been deleted through `DELETE FROM`) will be used when selecting\n    parts to merge. Note that this behavior is only triggered for data parts\n    affected by `DELETE FROM` executed after this setting is enabled.\n\n    Possible values:\n    - `true`\n    - `false`\n\n    **See Also**\n    - [load_existing_rows_count_for_old_parts](#load_existing_rows_count_for_old_parts)\n      setting\n    "
    },
    {
      "name": "execute_merges_on_single_replica_time_threshold",
      "type": "Seconds",
      "description": "\n    When this setting has a value greater than zero, only a single replica starts\n    the merge immediately, and other replicas wait up to that amount of time to\n    download the result instead of doing merges locally. If the chosen replica\n    doesn't finish the merge during that amount of time, fallback to standard\n    behavior happens.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "fault_probability_after_part_commit",
      "type": "Float",
      "description": "\n    For testing. Do not change it.\n    "
    },
    {
      "name": "fault_probability_before_part_commit",
      "type": "Float",
      "description": "\n    For testing. Do not change it.\n    "
    },
    {
      "name": "finished_mutations_to_keep",
      "type": "UInt64",
      "description": "\n    How many records about mutations that are done to keep. If zero, then keep\n    all of them.\n    "
    },
    {
      "name": "force_read_through_cache_for_merges",
      "type": "Bool",
      "description": "\n    Force read-through filesystem cache for merges\n    "
    },
    {
      "name": "fsync_after_insert",
      "type": "Bool",
      "description": "\n    Do fsync for every inserted part. Significantly decreases performance of\n    inserts, not recommended to use with wide parts.\n    "
    },
    {
      "name": "fsync_part_directory",
      "type": "Bool",
      "description": "\n    Do fsync for part directory after all part operations (writes, renames, etc.).\n    "
    },
    {
      "name": "in_memory_parts_enable_wal",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "in_memory_parts_insert_sync",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "inactive_parts_to_delay_insert",
      "type": "UInt64",
      "description": "\n    If the number of inactive parts in a single partition in the table exceeds\n    the `inactive_parts_to_delay_insert` value, an `INSERT` is artificially\n    slowed down.\n\n    :::tip\n    It is useful when a server fails to clean up parts quickly enough.\n    :::\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "inactive_parts_to_throw_insert",
      "type": "UInt64",
      "description": "\n    If the number of inactive parts in a single partition more than the\n    `inactive_parts_to_throw_insert` value, `INSERT` is interrupted with the\n    following error:\n\n    > \"Too many inactive parts (N). Parts cleaning are processing significantly\n      slower than inserts\" exception.\"\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "index_granularity",
      "type": "UInt64",
      "description": "\n    Maximum number of data rows between the marks of an index. I.e how many rows\n    correspond to one primary key value.\n    "
    },
    {
      "name": "index_granularity_bytes",
      "type": "UInt64",
      "description": "\n    Maximum size of data granules in bytes.\n\n    To restrict the granule size only by number of rows, set to `0` (not recommended).\n    "
    },
    {
      "name": "initialization_retry_period",
      "type": "Seconds",
      "description": "\n    Retry period for table initialization, in seconds.\n    "
    },
    {
      "name": "kill_delay_period",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "kill_delay_period_random_add",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "kill_threads",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "lightweight_mutation_projection_mode",
      "type": "LightweightMutationProjectionMode",
      "description": "\n    By default, lightweight delete `DELETE` does not work for tables with\n    projections. This is because rows in a projection may be affected by a\n    `DELETE` operation. So the default value would be `throw`. However, this\n    option can change the behavior. With the value either `drop` or `rebuild`,\n    deletes will work with projections. `drop` would delete the projection so it\n    might be fast in the current query as projection gets deleted but slow in\n    future queries as no projection attached. `rebuild` would rebuild the\n    projection which might affect the performance of the current query, but\n    might speedup for future queries. A good thing is that these options would\n    only work in the part level, which means projections in the part that don't\n    get touched would stay intact instead of triggering any action like\n    drop or rebuild.\n\n    Possible values:\n    - `throw`\n    - `drop`\n    - `rebuild`\n    "
    },
    {
      "name": "load_existing_rows_count_for_old_parts",
      "type": "Bool",
      "description": "\n    If enabled along with [exclude_deleted_rows_for_part_size_in_merge](#exclude_deleted_rows_for_part_size_in_merge),\n    deleted rows count for existing data parts will be calculated during table\n    starting up. Note that it may slow down start up table loading.\n\n    Possible values:\n    - `true`\n    - `false`\n\n    **See Also**\n    - [exclude_deleted_rows_for_part_size_in_merge](#exclude_deleted_rows_for_part_size_in_merge) setting\n    "
    },
    {
      "name": "lock_acquire_timeout_for_background_operations",
      "type": "Seconds",
      "description": "\n    For background operations like merges, mutations etc. How many seconds before\n    failing to acquire table locks.\n    "
    },
    {
      "name": "marks_compress_block_size",
      "type": "NonZeroUInt64",
      "description": "\n    Mark compress block size, the actual size of the block to compress.\n    "
    },
    {
      "name": "marks_compression_codec",
      "type": "String",
      "description": "\n    Compression encoding used by marks, marks are small enough and cached, so\n    the default compression is ZSTD(3).\n    "
    },
    {
      "name": "materialize_skip_indexes_on_merge",
      "type": "Bool",
      "description": "\n    When enabled, merges build and store skip indices for new parts.\n    Otherwise they can be created/stored by explicit MATERIALIZE INDEX\n    "
    },
    {
      "name": "materialize_ttl_recalculate_only",
      "type": "Bool",
      "description": "\n    Only recalculate ttl info when MATERIALIZE TTL\n    "
    },
    {
      "name": "max_avg_part_size_for_too_many_parts",
      "type": "UInt64",
      "description": "\n    The 'too many parts' check according to 'parts_to_delay_insert' and\n    'parts_to_throw_insert' will be active only if the average part size (in the\n    relevant partition) is not larger than the specified threshold. If it is\n    larger than the specified threshold, the INSERTs will be neither delayed or\n    rejected. This allows to have hundreds of terabytes in a single table on a\n    single server if the parts are successfully merged to larger parts. This\n    does not affect the thresholds on inactive parts or total parts.\n    "
    },
    {
      "name": "max_bytes_to_merge_at_max_space_in_pool",
      "type": "UInt64",
      "description": "\n    The maximum total parts size (in bytes) to be merged into one part, if there\n    are enough resources available. Corresponds roughly to the maximum possible\n    part size created by an automatic background merge. (0 means merges will be disabled)\n\n    Possible values:\n\n    - Any non-negative integer.\n\n    The merge scheduler periodically analyzes the sizes and number of parts in\n    partitions, and if there are enough free resources in the pool, it starts\n    background merges. Merges occur until the total size of the source parts is\n    larger than `max_bytes_to_merge_at_max_space_in_pool`.\n\n    Merges initiated by [OPTIMIZE FINAL](/sql-reference/statements/optimize)\n    ignore `max_bytes_to_merge_at_max_space_in_pool` (only the free disk space\n    is taken into account).\n    "
    },
    {
      "name": "max_bytes_to_merge_at_min_space_in_pool",
      "type": "UInt64",
      "description": "\n    The maximum total part size (in bytes) to be merged into one part, with the\n    minimum available resources in the background pool.\n\n    Possible values:\n    - Any positive integer.\n\n    `max_bytes_to_merge_at_min_space_in_pool` defines the maximum total size of\n    parts which can be merged despite the lack of available disk space (in pool).\n    This is necessary to reduce the number of small parts and the chance of\n    `Too many parts` errors.\n    Merges book disk space by doubling the total merged parts sizes.\n    Thus, with a small amount of free disk space, a situation may occur in which\n    there is free space, but this space is already booked by ongoing large merges,\n    so other merges are unable to start, and the number of small parts grows\n    with every insert.\n    "
    },
    {
      "name": "max_cleanup_delay_period",
      "type": "UInt64",
      "description": "\n    Maximum period to clean old queue logs, blocks hashes and parts.\n    "
    },
    {
      "name": "max_compress_block_size",
      "type": "UInt64",
      "description": "\n    The maximum size of blocks of uncompressed data before compressing for writing\n    to a table. You can also specify this setting in the global settings\n    (see [max_compress_block_size](/operations/settings/merge-tree-settings#max_compress_block_size)\n    setting). The value specified when the table is created overrides the global\n    value for this setting.\n    "
    },
    {
      "name": "max_concurrent_queries",
      "type": "UInt64",
      "description": "\n    Max number of concurrently executed queries related to the MergeTree table.\n    Queries will still be limited by other `max_concurrent_queries` settings.\n\n    Possible values:\n    - Positive integer.\n    - `0` — No limit.\n\n    Default value: `0` (no limit).\n\n    **Example**\n\n    ```xml\n    <max_concurrent_queries>50</max_concurrent_queries>\n    ```\n    "
    },
    {
      "name": "max_delay_to_insert",
      "type": "UInt64",
      "description": "\n    The value in seconds, which is used to calculate the `INSERT` delay, if the\n    number of active parts in a single partition exceeds the\n    [parts_to_delay_insert](#parts_to_delay_insert) value.\n\n    Possible values:\n    - Any positive integer.\n\n    The delay (in milliseconds) for `INSERT` is calculated by the formula:\n\n    ```code\n    max_k = parts_to_throw_insert - parts_to_delay_insert\n    k = 1 + parts_count_in_partition - parts_to_delay_insert\n    delay_milliseconds = pow(max_delay_to_insert * 1000, k / max_k)\n    ```\n    For example, if a partition has 299 active parts and parts_to_throw_insert\n    = 300, parts_to_delay_insert = 150, max_delay_to_insert = 1, `INSERT` is\n    delayed for `pow( 1 * 1000, (1 + 299 - 150) / (300 - 150) ) = 1000`\n    milliseconds.\n\n    Starting from version 23.1 formula has been changed to:\n\n    ```code\n    allowed_parts_over_threshold = parts_to_throw_insert - parts_to_delay_insert\n    parts_over_threshold = parts_count_in_partition - parts_to_delay_insert + 1\n    delay_milliseconds = max(min_delay_to_insert_ms, (max_delay_to_insert * 1000)\n    * parts_over_threshold / allowed_parts_over_threshold)\n    ```\n\n    For example, if a partition has 224 active parts and parts_to_throw_insert\n    = 300, parts_to_delay_insert = 150, max_delay_to_insert = 1,\n    min_delay_to_insert_ms = 10, `INSERT` is delayed for `max( 10, 1 * 1000 *\n    (224 - 150 + 1) / (300 - 150) ) = 500` milliseconds.\n    "
    },
    {
      "name": "max_delay_to_mutate_ms",
      "type": "UInt64",
      "description": "\n    Max delay of mutating MergeTree table in milliseconds, if there are a lot of\n    unfinished mutations\n    "
    },
    {
      "name": "max_digestion_size_per_segment",
      "type": "UInt64",
      "description": "\n    Max number of bytes to digest per segment to build GIN index.\n    "
    },
    {
      "name": "max_file_name_length",
      "type": "UInt64",
      "description": "\n    The maximal length of the file name to keep it as is without hashing.\n    Takes effect only if setting `replace_long_file_name_to_hash` is enabled.\n    The value of this setting does not include the length of file extension. So,\n    it is recommended to set it below the maximum filename length (usually 255\n    bytes) with some gap to avoid filesystem errors.\n    "
    },
    {
      "name": "max_files_to_modify_in_alter_columns",
      "type": "UInt64",
      "description": "\n    Do not apply ALTER if number of files for modification(deletion, addition)\n    is greater than this setting.\n\n    Possible values:\n\n    - Any positive integer.\n\n    Default value: 75\n    "
    },
    {
      "name": "max_files_to_remove_in_alter_columns",
      "type": "UInt64",
      "description": "\n    Do not apply ALTER, if the number of files for deletion is greater than this\n    setting.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "max_merge_delayed_streams_for_parallel_write",
      "type": "UInt64",
      "description": "\n    The maximum number of streams (columns) that can be flushed in parallel\n    (analog of max_insert_delayed_streams_for_parallel_write for merges). Works\n    only for Vertical merges.\n    "
    },
    {
      "name": "max_merge_selecting_sleep_ms",
      "type": "UInt64",
      "description": "\n    Maximum time to wait before trying to select parts to merge again after no\n    parts were selected. A lower setting will trigger selecting tasks in\n    background_schedule_pool frequently which result in large amount of\n    requests to zookeeper in large-scale clusters\n    "
    },
    {
      "name": "max_number_of_merges_with_ttl_in_pool",
      "type": "UInt64",
      "description": "When there is\n    more than specified number of merges with TTL entries in pool, do not assign\n    new merge with TTL. This is to leave free threads for regular merges and\n    avoid \\\"Too many parts\\\"\n    "
    },
    {
      "name": "max_number_of_mutations_for_replica",
      "type": "UInt64",
      "description": "\n    Limit the number of part mutations per replica to the specified amount.\n    Zero means no limit on the number of mutations per replica (the execution can\n    still be constrained by other settings).\n    "
    },
    {
      "name": "max_part_loading_threads",
      "type": "MaxThreads",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_part_removal_threads",
      "type": "MaxThreads",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "max_partitions_to_read",
      "type": "Int64",
      "description": "\n    Limits the maximum number of partitions that can be accessed in one query.\n\n    The setting value specified when the table is created can be overridden via\n    query-level setting.\n\n    Possible values:\n    - Any positive integer.\n\n    You can also specify a query complexity setting [max_partitions_to_read](/operations/settings/settings#max_partitions_to_read)\n    at a query / session / profile level.\n    "
    },
    {
      "name": "max_parts_in_total",
      "type": "UInt64",
      "description": "\n    If the total number of active parts in all partitions of a table exceeds the\n    `max_parts_in_total` value `INSERT` is interrupted with the `Too many parts\n    (N)` exception.\n\n    Possible values:\n    - Any positive integer.\n\n    A large number of parts in a table reduces performance of ClickHouse queries\n    and increases ClickHouse boot time. Most often this is a consequence of an\n    incorrect design (mistakes when choosing a partitioning strategy - too small\n    partitions).\n    "
    },
    {
      "name": "max_parts_to_merge_at_once",
      "type": "UInt64",
      "description": "\n    Max amount of parts which can be merged at once (0 - disabled). Doesn't affect\n    OPTIMIZE FINAL query.\n    "
    },
    {
      "name": "max_postpone_time_for_failed_mutations_ms",
      "type": "UInt64",
      "description": "\n    The maximum postpone time for failed mutations.\n    "
    },
    {
      "name": "max_postpone_time_for_failed_replicated_fetches_ms",
      "type": "UInt64",
      "description": "\n    The maximum postpone time for failed replicated fetches.\n    "
    },
    {
      "name": "max_postpone_time_for_failed_replicated_merges_ms",
      "type": "UInt64",
      "description": "\n    The maximum postpone time for failed replicated merges.\n    "
    },
    {
      "name": "max_postpone_time_for_failed_replicated_tasks_ms",
      "type": "UInt64",
      "description": "\n    The maximum postpone time for failed replicated task. The value is used if the task is not a fetch, merge or mutation.\n    "
    },
    {
      "name": "max_projections",
      "type": "UInt64",
      "description": "\n    The maximum number of merge tree projections.\n    "
    },
    {
      "name": "max_replicated_fetches_network_bandwidth",
      "type": "UInt64",
      "description": "\n    Limits the maximum speed of data exchange over the network in bytes per\n    second for [replicated](../../engines/table-engines/mergetree-family/replication.md)\n    fetches. This setting is applied to a particular table, unlike the\n    [`max_replicated_fetches_network_bandwidth_for_server`](/operations/settings/merge-tree-settings#max_replicated_fetches_network_bandwidth)\n    setting, which is applied to the server.\n\n    You can limit both server network and network for a particular table, but for\n    this the value of the table-level setting should be less than server-level\n    one. Otherwise the server considers only the\n    `max_replicated_fetches_network_bandwidth_for_server` setting.\n\n    The setting isn't followed perfectly accurately.\n\n    Possible values:\n\n    - Positive integer.\n    - `0` — Unlimited.\n\n    Default value: `0`.\n\n    **Usage**\n\n    Could be used for throttling speed when replicating data to add or replace\n    new nodes.\n    "
    },
    {
      "name": "max_replicated_logs_to_keep",
      "type": "UInt64",
      "description": "\n    How many records may be in the ClickHouse Keeper log if there is inactive\n    replica. An inactive replica becomes lost when when this number exceed.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "max_replicated_merges_in_queue",
      "type": "UInt64",
      "description": "\n    How many tasks of merging and mutating parts are allowed simultaneously in\n    ReplicatedMergeTree queue.\n    "
    },
    {
      "name": "max_replicated_merges_with_ttl_in_queue",
      "type": "UInt64",
      "description": "\n    How many tasks of merging parts with TTL are allowed simultaneously in\n    ReplicatedMergeTree queue.\n    "
    },
    {
      "name": "max_replicated_mutations_in_queue",
      "type": "UInt64",
      "description": "\n    How many tasks of mutating parts are allowed simultaneously in\n    ReplicatedMergeTree queue.\n    "
    },
    {
      "name": "max_replicated_sends_network_bandwidth",
      "type": "UInt64",
      "description": "\n    Limits the maximum speed of data exchange over the network in bytes per\n    second for [replicated](/engines/table-engines/mergetree-family/replacingmergetree)\n    sends. This setting is applied to a particular table, unlike the\n    [`max_replicated_sends_network_bandwidth_for_server`](/operations/settings/merge-tree-settings#max_replicated_sends_network_bandwidth)\n    setting, which is applied to the server.\n\n    You can limit both server network and network for a particular table, but\n    for this the value of the table-level setting should be less than\n    server-level one. Otherwise the server considers only the\n    `max_replicated_sends_network_bandwidth_for_server` setting.\n\n    The setting isn't followed perfectly accurately.\n\n    Possible values:\n\n    - Positive integer.\n    - `0` — Unlimited.\n\n    **Usage**\n\n    Could be used for throttling speed when replicating data to add or replace\n    new nodes.\n    "
    },
    {
      "name": "max_suspicious_broken_parts",
      "type": "UInt64",
      "description": "\n    If the number of broken parts in a single partition exceeds the\n    `max_suspicious_broken_parts` value, automatic deletion is denied.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "max_suspicious_broken_parts_bytes",
      "type": "UInt64",
      "description": "\n    Max size of all broken parts, if more - deny automatic deletion.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "merge_max_block_size",
      "type": "NonZeroUInt64",
      "description": "\n    The number of rows that are read from the merged parts into memory.\n\n    Possible values:\n    - Any positive integer.\n\n    Merge reads rows from parts in blocks of `merge_max_block_size` rows, then\n    merges and writes the result into a new part. The read block is placed in RAM,\n    so `merge_max_block_size` affects the size of the RAM required for the merge.\n    Thus, merges can consume a large amount of RAM for tables with very wide rows\n    (if the average row size is 100kb, then when merging 10 parts,\n    (100kb * 10 * 8192) = ~ 8GB of RAM). By decreasing `merge_max_block_size`,\n    you can reduce the amount of RAM required for a merge but slow down a merge.\n    "
    },
    {
      "name": "merge_max_block_size_bytes",
      "type": "UInt64",
      "description": "\n    How many bytes in blocks should be formed for merge operations. By default\n    has the same value as `index_granularity_bytes`.\n    "
    },
    {
      "name": "merge_max_bytes_to_prewarm_cache",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Maximal size of part (compact or packed)\n    to prewarm cache during merge.\n    "
    },
    {
      "name": "merge_selecting_sleep_ms",
      "type": "UInt64",
      "description": "\n    Minimum time to wait before trying to select parts to merge again after no\n    parts were selected. A lower setting will trigger selecting tasks in\n    background_schedule_pool frequently which result in large amount of requests\n    to zookeeper in large-scale clusters\n    "
    },
    {
      "name": "merge_selecting_sleep_slowdown_factor",
      "type": "Float",
      "description": "\n    The sleep time for merge selecting task is multiplied by this factor when\n    there's nothing to merge and divided when a merge was assigned\n    "
    },
    {
      "name": "merge_selector_algorithm",
      "type": "MergeSelectorAlgorithm",
      "description": "\n    The algorithm to select parts for merges assignment\n    "
    },
    {
      "name": "merge_selector_base",
      "type": "Float",
      "description": "Affects write amplification of\n    assigned merges (expert level setting, don't change if you don't understand\n    what it is doing). Works for Simple and StochasticSimple merge selectors\n    "
    },
    {
      "name": "merge_selector_blurry_base_scale_factor",
      "type": "UInt64",
      "description": "\n    Controls when the logic kicks in relatively to the number of parts in\n    partition. The bigger the factor the more belated reaction will be.\n    "
    },
    {
      "name": "merge_selector_enable_heuristic_to_remove_small_parts_at_right",
      "type": "Bool",
      "description": "\n    Enable heuristic for selecting parts for merge which removes parts from right\n    side of range, if their size is less than specified ratio (0.01) of sum_size.\n    Works for Simple and StochasticSimple merge selectors\n    "
    },
    {
      "name": "merge_selector_window_size",
      "type": "UInt64",
      "description": "\n    How many parts to look at once.\n    "
    },
    {
      "name": "merge_total_max_bytes_to_prewarm_cache",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Maximal size of parts in total to prewarm\n    cache during merge.\n    "
    },
    {
      "name": "merge_tree_clear_old_broken_detached_parts_ttl_timeout_seconds",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "merge_tree_clear_old_parts_interval_seconds",
      "type": "UInt64",
      "description": "\n    Sets the interval in seconds for ClickHouse to execute the cleanup of old\n    parts, WALs, and mutations.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "merge_tree_clear_old_temporary_directories_interval_seconds",
      "type": "UInt64",
      "description": "\n    Sets the interval in seconds for ClickHouse to execute the cleanup of old\n    temporary directories.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "merge_tree_enable_clear_old_broken_detached",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "merge_with_recompression_ttl_timeout",
      "type": "Int64",
      "description": "\n    Minimum delay in seconds before repeating a merge with recompression TTL.\n    "
    },
    {
      "name": "merge_with_ttl_timeout",
      "type": "Int64",
      "description": "\n    Minimum delay in seconds before repeating a merge with delete TTL.\n    "
    },
    {
      "name": "merge_workload",
      "type": "String",
      "description": "\n    Used to regulate how resources are utilized and shared between merges and\n    other workloads. Specified value is used as `workload` setting value for\n    background merges of this table. If not specified (empty string), then\n    server setting `merge_workload` is used instead.\n\n    **See Also**\n    - [Workload Scheduling](/operations/workload-scheduling.md)\n    "
    },
    {
      "name": "min_absolute_delay_to_close",
      "type": "UInt64",
      "description": "\n    Minimal absolute delay to close, stop serving requests and not\n    return Ok during status check.\n    "
    },
    {
      "name": "min_age_to_force_merge_on_partition_only",
      "type": "Bool",
      "description": "\n    Whether `min_age_to_force_merge_seconds` should be applied only on the entire\n    partition and not on subset.\n\n    By default, ignores setting `max_bytes_to_merge_at_max_space_in_pool` (see\n    `enable_max_bytes_limit_for_min_age_to_force_merge`).\n\n    Possible values:\n    - true, false\n    "
    },
    {
      "name": "min_age_to_force_merge_seconds",
      "type": "UInt64",
      "description": "\n    Merge parts if every part in the range is older than the value of\n    `min_age_to_force_merge_seconds`.\n\n    By default, ignores setting `max_bytes_to_merge_at_max_space_in_pool`\n    (see `enable_max_bytes_limit_for_min_age_to_force_merge`).\n\n    Possible values:\n    - Positive integer.\n    "
    },
    {
      "name": "min_bytes_for_compact_part",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "min_bytes_for_full_part_storage",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Minimal uncompressed size in bytes to\n    use full type of storage for data part instead of packed\n    "
    },
    {
      "name": "min_bytes_for_wide_part",
      "type": "UInt64",
      "description": "\n    Minimum number of bytes/rows in a data part that can be stored in `Wide`\n    format. You can set one, both or none of these settings.\n    "
    },
    {
      "name": "min_bytes_to_prewarm_caches",
      "type": "UInt64",
      "description": "\n    Minimal size (uncompressed bytes) to prewarm mark cache and primary index cache\n    for new parts\n    "
    },
    {
      "name": "min_bytes_to_rebalance_partition_over_jbod",
      "type": "UInt64",
      "description": "\n    Sets minimal amount of bytes to enable balancing when distributing new big\n    parts over volume disks [JBOD](https://en.wikipedia.org/wiki/Non-RAID_drive_architectures).\n\n    Possible values:\n\n    - Positive integer.\n    - `0` — Balancing is disabled.\n\n    **Usage**\n\n    The value of the `min_bytes_to_rebalance_partition_over_jbod` setting should\n    not be less than the value of the\n    [max_bytes_to_merge_at_max_space_in_pool](/operations/settings/merge-tree-settings#max_bytes_to_merge_at_max_space_in_pool)\n    / 1024. Otherwise, ClickHouse throws an exception.\n    "
    },
    {
      "name": "min_compress_block_size",
      "type": "UInt64",
      "description": "\n    Minimum size of blocks of uncompressed data required for compression when\n    writing the next mark. You can also specify this setting in the global settings\n    (see [min_compress_block_size](/operations/settings/merge-tree-settings#min_compress_block_size)\n    setting). The value specified when the table is created overrides the global value\n    for this setting.\n    "
    },
    {
      "name": "min_compressed_bytes_to_fsync_after_fetch",
      "type": "UInt64",
      "description": "\n    Minimal number of compressed bytes to do fsync for part after fetch (0 - disabled)\n    "
    },
    {
      "name": "min_compressed_bytes_to_fsync_after_merge",
      "type": "UInt64",
      "description": "\n    Minimal number of compressed bytes to do fsync for part after merge (0 - disabled)\n    "
    },
    {
      "name": "min_delay_to_insert_ms",
      "type": "UInt64",
      "description": "\n    Min delay of inserting data into MergeTree table in milliseconds, if there\n    are a lot of unmerged parts in single partition.\n    "
    },
    {
      "name": "min_delay_to_mutate_ms",
      "type": "UInt64",
      "description": "\n    Min delay of mutating MergeTree table in milliseconds, if there are a lot of\n    unfinished mutations\n    "
    },
    {
      "name": "min_free_disk_bytes_to_perform_insert",
      "type": "UInt64",
      "description": "\n    The minimum number of bytes that should be free in disk space in order to\n    insert data. If the number of available free bytes is less than\n    `min_free_disk_bytes_to_perform_insert` then an exception is thrown and the\n    insert is not executed. Note that this setting:\n    - takes into account the `keep_free_space_bytes` setting.\n    - does not take into account the amount of data that will be written by the\n      `INSERT` operation.\n    - is only checked if a positive (non-zero) number of bytes is specified\n\n    Possible values:\n    - Any positive integer.\n\n    :::note\n    If both `min_free_disk_bytes_to_perform_insert` and `min_free_disk_ratio_to_perform_insert`\n    are specified, ClickHouse will count on the value that will allow to perform\n    inserts on a bigger amount of free memory.\n    :::\n    "
    },
    {
      "name": "min_free_disk_ratio_to_perform_insert",
      "type": "Float",
      "description": "\n    The minimum free to total disk space ratio to perform an `INSERT`. Must be a\n    floating point value between 0 and 1. Note that this setting:\n    - takes into account the `keep_free_space_bytes` setting.\n    - does not take into account the amount of data that will be written by the\n      `INSERT` operation.\n    - is only checked if a positive (non-zero) ratio is specified\n\n    Possible values:\n    - Float, 0.0 - 1.0\n\n    Note that if both `min_free_disk_ratio_to_perform_insert` and\n    `min_free_disk_bytes_to_perform_insert` are specified, ClickHouse will count\n    on the value that will allow to perform inserts on a bigger amount of free\n    memory.\n    "
    },
    {
      "name": "min_index_granularity_bytes",
      "type": "UInt64",
      "description": "\n    Min allowed size of data granules in bytes.\n\n    To provide a safeguard against accidentally creating tables with very low\n    `index_granularity_bytes`.\n    "
    },
    {
      "name": "min_marks_to_honor_max_concurrent_queries",
      "type": "UInt64",
      "description": "\n    The minimal number of marks read by the query for applying the [max_concurrent_queries](#max_concurrent_queries)\n    setting.\n\n    :::note\n    Queries will still be limited by other `max_concurrent_queries` settings.\n    :::\n\n    Possible values:\n    - Positive integer.\n    - `0` — Disabled (`max_concurrent_queries` limit applied to no queries).\n\n    **Example**\n\n    ```xml\n    <min_marks_to_honor_max_concurrent_queries>10</min_marks_to_honor_max_concurrent_queries>\n    ```\n    "
    },
    {
      "name": "min_merge_bytes_to_use_direct_io",
      "type": "UInt64",
      "description": "\n    The minimum data volume for merge operation that is required for using direct\n    I/O access to the storage disk. When merging data parts, ClickHouse calculates\n    the total storage volume of all the data to be merged. If the volume exceeds\n    `min_merge_bytes_to_use_direct_io` bytes, ClickHouse reads and writes the\n    data to the storage disk using the direct I/O interface (`O_DIRECT` option).\n    If `min_merge_bytes_to_use_direct_io = 0`, then direct I/O is disabled.\n    "
    },
    {
      "name": "min_parts_to_merge_at_once",
      "type": "UInt64",
      "description": "\n    Minimal amount of data parts which merge selector can pick to merge at once\n    (expert level setting, don't change if you don't understand what it is doing).\n    0 - disabled. Works for Simple and StochasticSimple merge selectors.\n    "
    },
    {
      "name": "min_relative_delay_to_close",
      "type": "UInt64",
      "description": "\n    Minimal delay from other replicas to close, stop serving\n    requests and not return Ok during status check.\n    "
    },
    {
      "name": "min_relative_delay_to_measure",
      "type": "UInt64",
      "description": "\n    Calculate relative replica delay only if absolute delay is not less that\n    this value.\n    "
    },
    {
      "name": "min_relative_delay_to_yield_leadership",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "min_replicated_logs_to_keep",
      "type": "UInt64",
      "description": "\n    Keep about this number of last records in ZooKeeper log, even if they are\n    obsolete. It doesn't affect work of tables: used only to diagnose ZooKeeper\n    log before cleaning.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "min_rows_for_compact_part",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "min_rows_for_full_part_storage",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Minimal number of rows to use full type\n    of storage for data part instead of packed\n    "
    },
    {
      "name": "min_rows_for_wide_part",
      "type": "UInt64",
      "description": "\n    Minimal number of rows to create part in wide format instead of compact\n    "
    },
    {
      "name": "min_rows_to_fsync_after_merge",
      "type": "UInt64",
      "description": "\n    Minimal number of rows to do fsync for part after merge (0 - disabled)\n    "
    },
    {
      "name": "mutation_workload",
      "type": "String",
      "description": "\n    Used to regulate how resources are utilized and shared between mutations and\n    other workloads. Specified value is used as `workload` setting value for\n    background mutations of this table. If not specified (empty string), then\n    server setting `mutation_workload` is used instead.\n\n    **See Also**\n    - [Workload Scheduling](/operations/workload-scheduling.md)\n    "
    },
    {
      "name": "non_replicated_deduplication_window",
      "type": "UInt64",
      "description": "\n    The number of the most recently inserted blocks in the non-replicated\n    [MergeTree](../../engines/table-engines/mergetree-family/mergetree.md) table\n    for which hash sums are stored to check for duplicates.\n\n    Possible values:\n    - Any positive integer.\n    - `0` (disable deduplication).\n\n    A deduplication mechanism is used, similar to replicated tables (see\n    [replicated_deduplication_window](#replicated_deduplication_window) setting).\n    The hash sums of the created parts are written to a local file on a disk.\n    "
    },
    {
      "name": "notify_newest_block_number",
      "type": "Bool",
      "description": "\n    Notify newest block number to SharedJoin or SharedSet. Only in ClickHouse Cloud.\n    "
    },
    {
      "name": "number_of_free_entries_in_pool_to_execute_mutation",
      "type": "UInt64",
      "description": "\n    When there is less than specified number of free entries in pool, do not\n    execute part mutations. This is to leave free threads for regular merges and\n    to avoid \"Too many parts\" errors.\n\n    Possible values:\n    - Any positive integer.\n\n    **Usage**\n\n    The value of the `number_of_free_entries_in_pool_to_execute_mutation` setting\n    should be less than the value of the [background_pool_size](/operations/server-configuration-parameters/settings.md/#background_pool_size)\n    * [background_merges_mutations_concurrency_ratio](/operations/server-configuration-parameters/settings.md/#background_merges_mutations_concurrency_ratio).\n    Otherwise, ClickHouse will throw an exception.\n    "
    },
    {
      "name": "number_of_free_entries_in_pool_to_execute_optimize_entire_partition",
      "type": "UInt64",
      "description": "\n    When there is less than specified number of free entries in pool, do not\n    execute optimizing entire partition in the background (this task generated\n    when set `min_age_to_force_merge_seconds` and enable\n    `min_age_to_force_merge_on_partition_only`). This is to leave free threads\n    for regular merges and avoid \"Too many parts\".\n\n    Possible values:\n    - Positive integer.\n\n    The value of the `number_of_free_entries_in_pool_to_execute_optimize_entire_partition`\n    setting should be less than the value of the\n    [background_pool_size](/operations/server-configuration-parameters/settings.md/#background_pool_size)\n    * [background_merges_mutations_concurrency_ratio](/operations/server-configuration-parameters/settings.md/#background_merges_mutations_concurrency_ratio).\n    Otherwise, ClickHouse throws an exception.\n    "
    },
    {
      "name": "number_of_free_entries_in_pool_to_lower_max_size_of_merge",
      "type": "UInt64",
      "description": "\n    When there is less than the specified number of free entries in pool\n    (or replicated queue), start to lower maximum size of merge to process\n    (or to put in queue).\n    This is to allow small merges to process - not filling the pool with long\n    running merges.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "number_of_mutations_to_delay",
      "type": "UInt64",
      "description": "If table has at least\n    that many unfinished mutations, artificially slow down mutations of table.\n    Disabled if set to 0\n    "
    },
    {
      "name": "number_of_mutations_to_throw",
      "type": "UInt64",
      "description": "\n    If table has at least that many unfinished mutations, throw 'Too many mutations'\n    exception. Disabled if set to 0\n    "
    },
    {
      "name": "number_of_partitions_to_consider_for_merge",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Up to top N partitions which we will\n    consider for merge. Partitions picked in a random weighted way where weight\n    is amount of data parts which can be merged in this partition.\n    "
    },
    {
      "name": "old_parts_lifetime",
      "type": "Seconds",
      "description": "\n    The time (in seconds) of storing inactive parts to protect against data loss\n    during spontaneous server reboots.\n\n    Possible values:\n    - Any positive integer.\n\n    After merging several parts into a new part, ClickHouse marks the original\n    parts as inactive and deletes them only after `old_parts_lifetime` seconds.\n    Inactive parts are removed if they are not used by current queries, i.e. if\n    the `refcount` of the part is 1.\n\n    `fsync` is not called for new parts, so for some time new parts exist only\n    in the server's RAM (OS cache). If the server is rebooted spontaneously, new\n    parts can be lost or damaged. To protect data inactive parts are not deleted\n    immediately.\n\n    During startup ClickHouse checks the integrity of the parts. If the merged\n    part is damaged ClickHouse returns the inactive parts to the active list,\n    and later merges them again. Then the damaged part is renamed (the `broken_`\n    prefix is added) and moved to the `detached` folder. If the merged part is\n    not damaged, then the original inactive parts are renamed (the `ignored_`\n    prefix is added) and moved to the `detached` folder.\n\n    The default `dirty_expire_centisecs` value (a Linux kernel setting) is 30\n    seconds (the maximum time that written data is stored only in RAM), but under\n    heavy loads on the disk system data can be written much later. Experimentally,\n    a value of 480 seconds was chosen for `old_parts_lifetime`, during which a\n    new part is guaranteed to be written to disk.\n    "
    },
    {
      "name": "optimize_row_order",
      "type": "Bool",
      "description": "\n    Controls if the row order should be optimized during inserts to improve the\n    compressability of the newly inserted table part.\n\n    Only has an effect for ordinary MergeTree-engine tables. Does nothing for\n    specialized MergeTree engine tables (e.g. CollapsingMergeTree).\n\n    MergeTree tables are (optionally) compressed using [compression codecs](/sql-reference/statements/create/table#column_compression_codec).\n    Generic compression codecs such as LZ4 and ZSTD achieve maximum compression\n    rates if the data exposes patterns. Long runs of the same value typically\n    compress very well.\n\n    If this setting is enabled, ClickHouse attempts to store the data in newly\n    inserted parts in a row order that minimizes the number of equal-value runs\n    across the columns of the new table part.\n    In other words, a small number of equal-value runs mean that individual runs\n    are long and compress well.\n\n    Finding the optimal row order is computationally infeasible (NP hard).\n    Therefore, ClickHouse uses a heuristics to quickly find a row order which\n    still improves compression rates over the original row order.\n\n    <details markdown=\"1\">\n\n    <summary>Heuristics for finding a row order</summary>\n\n    It is generally possible to shuffle the rows of a table (or table part)\n    freely as SQL considers the same table (table part) in different row order\n    equivalent.\n\n    This freedom of shuffling rows is restricted when a primary key is defined\n    for the table. In ClickHouse, a primary key `C1, C2, ..., CN` enforces that\n    the table rows are sorted by columns `C1`, `C2`, ... `Cn` ([clustered index](https://en.wikipedia.org/wiki/Database_index#Clustered)).\n    As a result, rows can only be shuffled within \"equivalence classes\" of row,\n    i.e. rows which have the same values in their primary key columns.\n    The intuition is that primary keys with high-cardinality, e.g. primary keys\n    involving a `DateTime64` timestamp column, lead to many small equivalence\n    classes. Likewise, tables with a low-cardinality primary key, create few and\n    large equivalence classes. A table with no primary key represents the extreme\n    case of a single equivalence class which spans all rows.\n\n    The fewer and the larger the equivalence classes are, the higher the degree\n    of freedom when re-shuffling rows.\n\n    The heuristics applied to find the best row order within each equivalence\n    class is suggested by D. Lemire, O. Kaser in\n    [Reordering columns for smaller indexes](https://doi.org/10.1016/j.ins.2011.02.002)\n    and based on sorting the rows within each equivalence class by ascending\n    cardinality of the non-primary key columns.\n\n    It performs three steps:\n    1. Find all equivalence classes based on the row values in primary key columns.\n    2. For each equivalence class, calculate (usually estimate) the cardinalities\n       of the non-primary-key columns.\n    3. For each equivalence class, sort the rows in order of ascending\n       non-primary-key column cardinality.\n\n    </details>\n\n    If enabled, insert operations incur additional CPU costs to analyze and\n    optimize the row order of the new data. INSERTs are expected to take 30-50%\n    longer depending on the data characteristics.\n    Compression rates of LZ4 or ZSTD improve on average by 20-40%.\n\n    This setting works best for tables with no primary key or a low-cardinality\n    primary key, i.e. a table with only few distinct primary key values.\n    High-cardinality primary keys, e.g. involving timestamp columns of type\n    `DateTime64`, are not expected to benefit from this setting.\n    "
    },
    {
      "name": "part_moves_between_shards_delay_seconds",
      "type": "UInt64",
      "description": "\n    Time to wait before/after moving parts between shards.\n    "
    },
    {
      "name": "part_moves_between_shards_enable",
      "type": "UInt64",
      "description": "\n    Experimental/Incomplete feature to move parts between shards. Does not take\n    into account sharding expressions.\n    "
    },
    {
      "name": "parts_to_delay_insert",
      "type": "UInt64",
      "description": "\n    If the number of active parts in a single partition exceeds the\n    `parts_to_delay_insert` value, an `INSERT` is artificially slowed down.\n\n    Possible values:\n    - Any positive integer.\n\n    ClickHouse artificially executes `INSERT` longer (adds 'sleep') so that the\n    background merge process can merge parts faster than they are added.\n    "
    },
    {
      "name": "parts_to_throw_insert",
      "type": "UInt64",
      "description": "\n    If the number of active parts in a single partition exceeds the\n    `parts_to_throw_insert` value, `INSERT` is interrupted with the `Too many\n    parts (N). Merges are processing significantly slower than inserts`\n    exception.\n\n    Possible values:\n    - Any positive integer.\n\n    To achieve maximum performance of `SELECT` queries, it is necessary to\n    minimize the number of parts processed, see [Merge Tree](/development/architecture#merge-tree).\n\n    Prior to version 23.6 this setting was set to 300. You can set a higher\n    different value, it will reduce the probability of the `Too many parts`\n    error, but at the same time `SELECT` performance might degrade. Also in case\n    of a merge issue (for example, due to insufficient disk space) you will\n    notice it later than you would with the original 300.\n\n    "
    },
    {
      "name": "prefer_fetch_merged_part_size_threshold",
      "type": "UInt64",
      "description": "\n    If the sum of the size of parts exceeds this threshold and the time since a\n    replication log entry creation is greater than\n    `prefer_fetch_merged_part_time_threshold`, then prefer fetching merged part\n    from a replica instead of doing merge locally. This is to speed up very long\n    merges.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "prefer_fetch_merged_part_time_threshold",
      "type": "Seconds",
      "description": "\n    If the time passed since a replication log (ClickHouse Keeper or ZooKeeper)\n    entry creation exceeds this threshold, and the sum of the size of parts is\n    greater than `prefer_fetch_merged_part_size_threshold`, then prefer fetching\n    merged part from a replica instead of doing merge locally. This is to speed\n    up very long merges.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "prewarm_mark_cache",
      "type": "Bool",
      "description": "If true mark cache will be\n    prewarmed by saving marks to mark cache on inserts, merges, fetches and on\n    startup of server\n    "
    },
    {
      "name": "prewarm_primary_key_cache",
      "type": "Bool",
      "description": "If true primary index\n    cache will be prewarmed by saving marks to mark cache on inserts, merges,\n    fetches and on startup of server\n    "
    },
    {
      "name": "primary_key_compress_block_size",
      "type": "NonZeroUInt64",
      "description": "\n    Primary compress block size, the actual size of the block to compress.\n    "
    },
    {
      "name": "primary_key_compression_codec",
      "type": "String",
      "description": "\n    Compression encoding used by primary, primary key is small enough and cached,\n    so the default compression is ZSTD(3).\n    "
    },
    {
      "name": "primary_key_lazy_load",
      "type": "Bool",
      "description": "Load primary key in memory on\n    first use instead of on table initialization. This can save memory in the\n    presence of a large number of tables.\n    "
    },
    {
      "name": "primary_key_ratio_of_unique_prefix_values_to_skip_suffix_columns",
      "type": "Float",
      "description": "\n    If the value of a column of the primary key in data part changes at least in\n    this ratio of times, skip loading next columns in memory. This allows to save\n    memory usage by not loading useless columns of the primary key.\n    "
    },
    {
      "name": "ratio_of_defaults_for_sparse_serialization",
      "type": "Float",
      "description": "\n    Minimal ratio of the number of _default_ values to the number of _all_ values\n    in a column. Setting this value causes the column to be stored using sparse\n    serializations.\n\n    If a column is sparse (contains mostly zeros), ClickHouse can encode it in\n    a sparse format and automatically optimize calculations - the data does not\n    require full decompression during queries. To enable this sparse\n    serialization, define the `ratio_of_defaults_for_sparse_serialization`\n    setting to be less than 1.0. If the value is greater than or equal to 1.0,\n    then the columns will be always written using the normal full serialization.\n\n    Possible values:\n\n    - Float between `0` and `1` to enable sparse serialization\n    - `1.0` (or greater) if you do not want to use sparse serialization\n\n    **Example**\n\n    Notice the `s` column in the following table is an empty string for 95% of\n    the rows. In `my_regular_table` we do not use sparse serialization, and in\n    `my_sparse_table` we set `ratio_of_defaults_for_sparse_serialization` to\n    0.95:\n\n    ```sql\n    CREATE TABLE my_regular_table\n    (\n        `id` UInt64,\n        `s` String\n    )\n    ENGINE = MergeTree\n    ORDER BY id;\n\n    INSERT INTO my_regular_table\n    SELECT\n        number AS id,\n        number % 20 = 0 ? toString(number): '' AS s\n    FROM\n        numbers(10000000);\n\n\n    CREATE TABLE my_sparse_table\n    (\n        `id` UInt64,\n        `s` String\n    )\n    ENGINE = MergeTree\n    ORDER BY id\n    SETTINGS ratio_of_defaults_for_sparse_serialization = 0.95;\n\n    INSERT INTO my_sparse_table\n    SELECT\n        number,\n        number % 20 = 0 ? toString(number): ''\n    FROM\n        numbers(10000000);\n    ```\n\n    Notice the `s` column in `my_sparse_table` uses less storage space on disk:\n\n    ```sql\n    SELECT table, name, data_compressed_bytes, data_uncompressed_bytes FROM system.columns\n    WHERE table LIKE 'my_%_table';\n    ```\n\n    ```response\n    ┌─table────────────┬─name─┬─data_compressed_bytes─┬─data_uncompressed_bytes─┐\n    │ my_regular_table │ id   │              37790741 │                75488328 │\n    │ my_regular_table │ s    │               2451377 │                12683106 │\n    │ my_sparse_table  │ id   │              37790741 │                75488328 │\n    │ my_sparse_table  │ s    │               2283454 │                 9855751 │\n    └──────────────────┴──────┴───────────────────────┴─────────────────────────┘\n    ```\n\n    You can verify if a column is using the sparse encoding by viewing the\n    `serialization_kind` column of the `system.parts_columns` table:\n\n    ```sql\n    SELECT column, serialization_kind FROM system.parts_columns\n    WHERE table LIKE 'my_sparse_table';\n    ```\n\n    You can see which parts of `s` were stored using the sparse serialization:\n\n    ```response\n    ┌─column─┬─serialization_kind─┐\n    │ id     │ Default            │\n    │ s      │ Default            │\n    │ id     │ Default            │\n    │ s      │ Default            │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    │ id     │ Default            │\n    │ s      │ Sparse             │\n    └────────┴────────────────────┘\n    ```\n    "
    },
    {
      "name": "reduce_blocking_parts_sleep_ms",
      "type": "UInt64",
      "description": "\n    Only available in ClickHouse Cloud. Minimum time to wait before trying to\n    reduce blocking parts again after no ranges were dropped/replaced. A lower\n    setting will trigger tasks in background_schedule_pool frequently which\n    results in large amount of requests to zookeeper in large-scale clusters\n    "
    },
    {
      "name": "refresh_parts_interval",
      "type": "Seconds",
      "description": "\n    If it is greater than zero - refresh the list of data parts from the underlying filesystem to check if the data was updated under the hood.\n    It can be set only if the table is located on readonly disks (which means that this is a readonly replica, while data is being written by another replica).\n    "
    },
    {
      "name": "remote_fs_execute_merges_on_single_replica_time_threshold",
      "type": "Seconds",
      "description": "\n    When this setting has a value greater than zero only a single replica starts\n    the merge immediately if merged part on shared storage and\n    `allow_remote_fs_zero_copy_replication` is enabled.\n\n    :::note\n    Zero-copy replication is not ready for production\n    Zero-copy replication is disabled by default in ClickHouse version 22.8 and\n    higher.\n\n    This feature is not recommended for production use.\n    :::\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "remote_fs_zero_copy_path_compatible_mode",
      "type": "Bool",
      "description": "\n    Run zero-copy in compatible mode during conversion process.\n    "
    },
    {
      "name": "remote_fs_zero_copy_zookeeper_path",
      "type": "String",
      "description": "\n    ZooKeeper path for zero-copy table-independent info.\n    "
    },
    {
      "name": "remove_empty_parts",
      "type": "Bool",
      "description": "\n    Remove empty parts after they were pruned by TTL, mutation, or collapsing\n    merge algorithm.\n    "
    },
    {
      "name": "remove_rolled_back_parts_immediately",
      "type": "Bool",
      "description": "\n    Setting for an incomplete experimental feature.\n    "
    },
    {
      "name": "remove_unused_patch_parts",
      "type": "Bool",
      "description": "\n    Remove in background patch parts which are applied for all active parts.\n    "
    },
    {
      "name": "replace_long_file_name_to_hash",
      "type": "Bool",
      "description": "\n    If the file name for column is too long (more than 'max_file_name_length'\n    bytes) replace it to SipHash128\n    "
    },
    {
      "name": "replicated_can_become_leader",
      "type": "Bool",
      "description": "\n    If true, replicated tables replicas on this node will try to acquire\n    leadership.\n\n    Possible values:\n    - `true`\n    - `false`\n    "
    },
    {
      "name": "replicated_deduplication_window",
      "type": "UInt64",
      "description": "\n    The number of most recently inserted blocks for which ClickHouse Keeper stores\n    hash sums to check for duplicates.\n\n    Possible values:\n    - Any positive integer.\n    - 0 (disable deduplication)\n\n    The `Insert` command creates one or more blocks (parts). For\n    [insert deduplication](../../engines/table-engines/mergetree-family/replication.md),\n    when writing into replicated tables, ClickHouse writes the hash sums of the\n    created parts into ClickHouse Keeper. Hash sums are stored only for the most\n    recent `replicated_deduplication_window` blocks. The oldest hash sums are\n    removed from ClickHouse Keeper.\n\n    A large number for `replicated_deduplication_window` slows down `Inserts`\n    because more entries need to be compared. The hash sum is calculated from\n    the composition of the field names and types and the data of the inserted\n    part (stream of bytes).\n    "
    },
    {
      "name": "replicated_deduplication_window_for_async_inserts",
      "type": "UInt64",
      "description": "\n    The number of most recently async inserted blocks for which ClickHouse Keeper\n    stores hash sums to check for duplicates.\n\n    Possible values:\n    - Any positive integer.\n    - 0 (disable deduplication for async_inserts)\n\n    The [Async Insert](/operations/settings/settings#async_insert) command will\n    be cached in one or more blocks (parts). For [insert deduplication](/engines/table-engines/mergetree-family/replication),\n    when writing into replicated tables, ClickHouse writes the hash sums of each\n    insert into ClickHouse Keeper. Hash sums are stored only for the most recent\n    `replicated_deduplication_window_for_async_inserts` blocks. The oldest hash\n    sums are removed from ClickHouse Keeper.\n    A large number of `replicated_deduplication_window_for_async_inserts` slows\n    down `Async Inserts` because it needs to compare more entries.\n    The hash sum is calculated from the composition of the field names and types\n    and the data of the insert (stream of bytes).\n    "
    },
    {
      "name": "replicated_deduplication_window_seconds",
      "type": "UInt64",
      "description": "\n    The number of seconds after which the hash sums of the inserted blocks are\n    removed from ClickHouse Keeper.\n\n    Possible values:\n    - Any positive integer.\n\n    Similar to [replicated_deduplication_window](#replicated_deduplication_window),\n    `replicated_deduplication_window_seconds` specifies how long to store hash\n    sums of blocks for insert deduplication. Hash sums older than\n    `replicated_deduplication_window_seconds` are removed from ClickHouse Keeper,\n    even if they are less than ` replicated_deduplication_window`.\n\n    The time is relative to the time of the most recent record, not to the wall\n    time. If it's the only record it will be stored forever.\n    "
    },
    {
      "name": "replicated_deduplication_window_seconds_for_async_inserts",
      "type": "UInt64",
      "description": "\n    The number of seconds after which the hash sums of the async inserts are\n    removed from ClickHouse Keeper.\n\n    Possible values:\n    - Any positive integer.\n\n    Similar to [replicated_deduplication_window_for_async_inserts](#replicated_deduplication_window_for_async_inserts),\n    `replicated_deduplication_window_seconds_for_async_inserts` specifies how\n    long to store hash sums of blocks for async insert deduplication. Hash sums\n    older than `replicated_deduplication_window_seconds_for_async_inserts` are\n    removed from ClickHouse Keeper, even if they are less than\n    `replicated_deduplication_window_for_async_inserts`.\n\n    The time is relative to the time of the most recent record, not to the wall\n    time. If it's the only record it will be stored forever.\n    "
    },
    {
      "name": "replicated_fetches_http_connection_timeout",
      "type": "Seconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_fetches_http_receive_timeout",
      "type": "Seconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_fetches_http_send_timeout",
      "type": "Seconds",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_max_mutations_in_one_entry",
      "type": "UInt64",
      "description": "\n    Max number of mutation commands that can be merged together and executed in\n    one MUTATE_PART entry (0 means unlimited)\n    "
    },
    {
      "name": "replicated_max_parallel_fetches",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_max_parallel_fetches_for_host",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_max_parallel_fetches_for_table",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_max_parallel_sends",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_max_parallel_sends_for_table",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "replicated_max_ratio_of_wrong_parts",
      "type": "Float",
      "description": "\n    If the ratio of wrong parts to total number of parts is less than this -\n    allow to start.\n\n    Possible values:\n    - Float, 0.0 - 1.0\n    "
    },
    {
      "name": "shared_merge_tree_create_per_replica_metadata_nodes",
      "type": "Bool",
      "description": "\n    Enables creation of per-replica /metadata and /columns nodes in ZooKeeper.\n    Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_disable_merges_and_mutations_assignment",
      "type": "Bool",
      "description": "\n    Stop merges assignment for shared merge tree. Only available in ClickHouse\n    Cloud\n    "
    },
    {
      "name": "shared_merge_tree_enable_coordinated_merges",
      "type": "Bool",
      "description": "\n    Enables coordinated merges strategy\n    "
    },
    {
      "name": "shared_merge_tree_enable_keeper_parts_extra_data",
      "type": "Bool",
      "description": "\n    Enables writing attributes into virtual parts and committing blocks in keeper\n    "
    },
    {
      "name": "shared_merge_tree_enable_outdated_parts_check",
      "type": "Bool",
      "description": "\n    Enable outdated parts check. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_idle_parts_update_seconds",
      "type": "UInt64",
      "description": "\n    Interval in seconds for parts update without being triggered by ZooKeeper\n    watch in the shared merge tree. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_initial_parts_update_backoff_ms",
      "type": "UInt64",
      "description": "\n    Initial backoff for parts update. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_interserver_http_connection_timeout_ms",
      "type": "UInt64",
      "description": "\n    Timeouts for interserver HTTP connection. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_interserver_http_timeout_ms",
      "type": "UInt64",
      "description": "\n    Timeouts for interserver HTTP communication. Only available in ClickHouse\n    Cloud\n    "
    },
    {
      "name": "shared_merge_tree_leader_update_period_random_add_seconds",
      "type": "UInt64",
      "description": "\n    Add uniformly distributed value from 0 to x seconds to\n    shared_merge_tree_leader_update_period to avoid thundering\n    herd effect. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_leader_update_period_seconds",
      "type": "UInt64",
      "description": "\n    Maximum period to recheck leadership for parts update. Only available in\n    ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_max_outdated_parts_to_process_at_once",
      "type": "UInt64",
      "description": "\n    Maximum amount of outdated parts leader will try to confirm for removal at\n    one HTTP request. Only available in ClickHouse Cloud.\n    "
    },
    {
      "name": "shared_merge_tree_max_parts_update_backoff_ms",
      "type": "UInt64",
      "description": "\n    Max backoff for parts update. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_max_parts_update_leaders_in_total",
      "type": "UInt64",
      "description": "\n    Maximum number of parts update leaders. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_max_parts_update_leaders_per_az",
      "type": "UInt64",
      "description": "\n    Maximum number of parts update leaders. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_max_replicas_for_parts_deletion",
      "type": "UInt64",
      "description": "\n    Max replicas which will participate in parts deletion (killer thread). Only\n    available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_max_replicas_to_merge_parts_for_each_parts_range",
      "type": "UInt64",
      "description": "\n    Max replicas which will try to assign potentially conflicting merges (allow\n    to avoid redundant conflicts in merges assignment). 0 means disabled. Only\n    available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_max_suspicious_broken_parts",
      "type": "UInt64",
      "description": "\n    Max broken parts for SMT, if more - deny automatic detach.\n    "
    },
    {
      "name": "shared_merge_tree_max_suspicious_broken_parts_bytes",
      "type": "UInt64",
      "description": "\n    Max size of all broken parts for SMT, if more - deny automatic detach.\n    "
    },
    {
      "name": "shared_merge_tree_memo_ids_remove_timeout_seconds",
      "type": "Int64",
      "description": "\n    How long we store insert memoization ids to avoid wrong actions during\n    insert retries. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_election_check_period_ms",
      "type": "Milliseconds",
      "description": "\n    Time between runs of merge coordinator election thread\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_factor",
      "type": "UInt64",
      "description": "\n    Time changing factor for delay of coordinator thread\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_fetch_fresh_metadata_period_ms",
      "type": "Milliseconds",
      "description": "\n    How often merge coordinator should sync with zookeeper to take fresh metadata\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_max_merge_request_size",
      "type": "UInt64",
      "description": "\n    Number of merges that coordinator can request from MergerMutator at once\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_max_period_ms",
      "type": "Milliseconds",
      "description": "\n    Maximum time between runs of merge coordinator thread\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_merges_prepare_count",
      "type": "UInt64",
      "description": "\n    Number of merge entries that coordinator should prepare and distribute across workers\n    "
    },
    {
      "name": "shared_merge_tree_merge_coordinator_min_period_ms",
      "type": "Milliseconds",
      "description": "\n    Minimum time between runs of merge coordinator thread\n    "
    },
    {
      "name": "shared_merge_tree_merge_worker_fast_timeout_ms",
      "type": "Milliseconds",
      "description": "\n    Timeout that merge worker thread will use if it is needed to update it's state after immediate action\n    "
    },
    {
      "name": "shared_merge_tree_merge_worker_regular_timeout_ms",
      "type": "Milliseconds",
      "description": "\n    Time between runs of merge worker thread\n    "
    },
    {
      "name": "shared_merge_tree_partitions_hint_ratio_to_reload_merge_pred_for_mutations",
      "type": "Float",
      "description": "\n    Will reload merge predicate in merge/mutate selecting task when `<candidate\n    partitions for mutations only (partitions that cannot be merged)>/<candidate\n    partitions for mutations>` ratio is higher than the setting. Only available\n    in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_parts_load_batch_size",
      "type": "UInt64",
      "description": "\n    Amount of fetch parts metadata jobs to schedule at once. Only available in\n    ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_postpone_next_merge_for_locally_merged_parts_ms",
      "type": "UInt64",
      "description": "\n    Time to keep a locally merged part without starting a new merge containing\n    this part. Gives other replicas a chance fetch the part and start this merge.\n    Only available in ClickHouse Cloud.\n    "
    },
    {
      "name": "shared_merge_tree_postpone_next_merge_for_locally_merged_parts_rows_threshold",
      "type": "UInt64",
      "description": "\n    Minimum size of part (in rows) to postpone assigning a next merge just after\n    merging it locally. Only available in ClickHouse Cloud.\n    "
    },
    {
      "name": "shared_merge_tree_range_for_merge_window_size",
      "type": "UInt64",
      "description": "\n    Time to keep a locally merged part without starting a new merge containing\n    this part. Gives other replicas a chance fetch the part and start this merge.\n    Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_read_virtual_parts_from_leader",
      "type": "Bool",
      "description": "\n    Read virtual parts from leader when possible. Only available in ClickHouse\n    Cloud\n    "
    },
    {
      "name": "shared_merge_tree_try_fetch_part_in_memory_data_from_replicas",
      "type": "Bool",
      "description": "\n    If enabled all the replicas try to fetch part in memory data (like primary\n    key, partition info and so on) from other replicas where it already exists.\n    "
    },
    {
      "name": "shared_merge_tree_use_metadata_hints_cache",
      "type": "Bool",
      "description": "\n    Enables requesting FS cache hints from in-memory\n    cache on other replicas. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_use_outdated_parts_compact_format",
      "type": "Bool",
      "description": "\n    Use compact format for outdated parts: reduces load to Keeper, improves\n    outdated parts processing. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "shared_merge_tree_use_too_many_parts_count_from_virtual_parts",
      "type": "Bool",
      "description": "\n    If enabled too many parts counter will rely on shared data in Keeper, not on\n    local replica state. Only available in ClickHouse Cloud\n    "
    },
    {
      "name": "simultaneous_parts_removal_limit",
      "type": "UInt64",
      "description": "\n    If there are a lot of outdated parts cleanup thread will try to delete up to\n    `simultaneous_parts_removal_limit` parts during one iteration.\n    `simultaneous_parts_removal_limit` set to `0` means unlimited.\n    "
    },
    {
      "name": "sleep_before_commit_local_part_in_replicated_table_ms",
      "type": "Milliseconds",
      "description": "\n    For testing. Do not change it.\n    "
    },
    {
      "name": "sleep_before_loading_outdated_parts_ms",
      "type": "UInt64",
      "description": "\n    For testing. Do not change it.\n    "
    },
    {
      "name": "storage_policy",
      "type": "String",
      "description": "\n    Name of storage disk policy\n    "
    },
    {
      "name": "table_disk",
      "type": "Bool",
      "description": "\n    This is table disk, the path/endpoint should point to the table data, not to\n    the database data. Can be set only for s3_plain/s3_plain_rewritable/web.\n    "
    },
    {
      "name": "temporary_directories_lifetime",
      "type": "Seconds",
      "description": "\n    How many seconds to keep tmp_-directories. You should not lower this value\n    because merges and mutations may not be able to work with low value of this\n    setting.\n    "
    },
    {
      "name": "try_fetch_recompressed_part_timeout",
      "type": "Seconds",
      "description": "\n    Timeout (in seconds) before starting merge with recompression. During this\n    time ClickHouse tries to fetch recompressed part from replica which assigned\n    this merge with recompression.\n\n    Recompression works slow in most cases, so we don't start merge with\n    recompression until this timeout and trying to fetch recompressed part from\n    replica which assigned this merge with recompression.\n\n    Possible values:\n    - Any positive integer.\n    "
    },
    {
      "name": "ttl_only_drop_parts",
      "type": "Bool",
      "description": "\n    Controls whether data parts are fully dropped in MergeTree tables when all\n    rows in that part have expired according to their `TTL` settings.\n\n    When `ttl_only_drop_parts` is disabled (by default), only the rows that have\n    expired based on their TTL settings are removed.\n\n    When `ttl_only_drop_parts` is enabled, the entire part is dropped if all\n    rows in that part have expired according to their `TTL` settings.\n    "
    },
    {
      "name": "use_adaptive_write_buffer_for_dynamic_subcolumns",
      "type": "Bool",
      "description": "\n    Allow to use adaptive writer buffers during writing dynamic subcolumns to\n    reduce memory usage\n    "
    },
    {
      "name": "use_async_block_ids_cache",
      "type": "Bool",
      "description": "\n    If true, we cache the hash sums of the async inserts.\n\n    Possible values:\n    - `true`\n    - `false`\n\n    A block bearing multiple async inserts will generate multiple hash sums.\n    When some of the inserts are duplicated, keeper will only return one\n    duplicated hash sum in one RPC, which will cause unnecessary RPC retries.\n    This cache will watch the hash sums path in Keeper. If updates are watched\n    in the Keeper, the cache will update as soon as possible, so that we are\n    able to filter the duplicated inserts in the memory.\n    "
    },
    {
      "name": "use_compact_variant_discriminators_serialization",
      "type": "Bool",
      "description": "\n    Enables compact mode for binary serialization of discriminators in Variant\n    data type.\n    This mode allows to use significantly less memory for storing discriminators\n    in parts when there is mostly one variant or a lot of NULL values.\n    "
    },
    {
      "name": "use_const_adaptive_granularity",
      "type": "Bool",
      "description": "\n    Always use constant granularity for whole part. It allows to compress in\n    memory values of index granularity. It can be useful in extremely large\n    workloads with thin tables.\n    "
    },
    {
      "name": "use_metadata_cache",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "use_minimalistic_checksums_in_zookeeper",
      "type": "Bool",
      "description": "\n    Use small format (dozens bytes) for part checksums in ZooKeeper instead of\n    ordinary ones (dozens KB). Before enabling check that all replicas support\n    new format.\n    "
    },
    {
      "name": "use_minimalistic_part_header_in_zookeeper",
      "type": "Bool",
      "description": "\n    Storage method of the data parts headers in ZooKeeper. If enabled, ZooKeeper\n    stores less data. For details, see [here](/operations/server-configuration-parameters/settings#use_minimalistic_part_header_in_zookeeper).\n    "
    },
    {
      "name": "use_primary_key_cache",
      "type": "Bool",
      "description": "Use cache for primary index\n    instead of saving all indexes in memory. Can be useful for very large tables\n    "
    },
    {
      "name": "vertical_merge_algorithm_min_bytes_to_activate",
      "type": "UInt64",
      "description": "\n    Minimal (approximate) uncompressed size in bytes in merging parts to activate\n    Vertical merge algorithm.\n    "
    },
    {
      "name": "vertical_merge_algorithm_min_columns_to_activate",
      "type": "UInt64",
      "description": "\n    Minimal amount of non-PK columns to activate Vertical merge algorithm.\n    "
    },
    {
      "name": "vertical_merge_algorithm_min_rows_to_activate",
      "type": "UInt64",
      "description": "\n    Minimal (approximate) sum of rows in\n    merging parts to activate Vertical merge algorithm.\n    "
    },
    {
      "name": "vertical_merge_remote_filesystem_prefetch",
      "type": "Bool",
      "description": "\n    If true prefetching of data from remote filesystem is used for the next\n    column during merge\n    "
    },
    {
      "name": "wait_for_unique_parts_send_before_shutdown_ms",
      "type": "Milliseconds",
      "description": "\n    Before shutdown table will wait for required amount time for unique parts\n    (exist only on current replica) to be fetched by other replicas (0 means\n    disabled).\n    "
    },
    {
      "name": "write_ahead_log_bytes_to_fsync",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "write_ahead_log_interval_ms_to_fsync",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "write_ahead_log_max_bytes",
      "type": "UInt64",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "write_final_mark",
      "type": "Bool",
      "description": "Obsolete setting, does nothing."
    },
    {
      "name": "write_marks_for_substreams_in_compact_parts",
      "type": "Bool",
      "description": "\n    Enables writing marks per each substream instead of per each column in Compact parts.\n    It allows to read individual subcolumns from the data part efficiently.\n    "
    },
    {
      "name": "zero_copy_concurrent_part_removal_max_postpone_ratio",
      "type": "Float",
      "description": "\n    Max percentage of top level parts to postpone removal in order to get\n    smaller independent ranges. Recommended not to change.\n    "
    },
    {
      "name": "zero_copy_concurrent_part_removal_max_split_times",
      "type": "UInt64",
      "description": "\n    Max recursion depth for splitting independent Outdated parts ranges into\n    smaller subranges. Recommended not to change.\n    "
    },
    {
      "name": "zero_copy_merge_mutation_min_parts_size_sleep_before_lock",
      "type": "UInt64",
      "description": "\n    If zero copy replication is enabled sleep random amount of time before trying\n    to lock depending on parts size for merge or mutation\n    "
    },
    {
      "name": "zero_copy_merge_mutation_min_parts_size_sleep_no_scale_before_lock",
      "type": "UInt64",
      "description": "\n    If zero copy replication is enabled sleep random amount of time up to 500ms\n    before trying to lock for merge or mutation.\n    "
    },
    {
      "name": "zookeeper_session_expiration_check_period",
      "type": "Seconds",
      "description": "\n    ZooKeeper session expiration check period, in seconds.\n\n    Possible values:\n    - Any positive integer.\n    "
    }
  ]
}
